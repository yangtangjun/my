/*! For license information please see main.js.LICENSE.txt */
(() => {
    var t = {
        231: t => {
            var e;
            self, e = function () {
                return (() => {
                    var t = {
                        4672: t => {
                            const e = {
                                html: document.documentElement,
                                body: document.body,
                                window: {w: window.innerWidth, h: window.innerHeight}
                            };
                            t.exports = e
                        }, 5336: t => {
                            t.exports = function (t, e) {
                                let n = null;
                                return function () {
                                    clearTimeout(n);
                                    const i = arguments, r = this;
                                    n = setTimeout((function () {
                                        t.apply(r, i)
                                    }), e)
                                }
                            }
                        }, 6077: (t, e, n) => {
                            var i = n(111);
                            t.exports = function (t) {
                                if (!i(t) && null !== t) throw TypeError("Can't set " + String(t) + " as a prototype");
                                return t
                            }
                        }, 1223: (t, e, n) => {
                            var i = n(5112), r = n(30), o = n(3070), s = i("unscopables"), a = Array.prototype;
                            null == a[s] && o.f(a, s, {configurable: !0, value: r(null)}), t.exports = function (t) {
                                a[s][t] = !0
                            }
                        }, 9670: (t, e, n) => {
                            var i = n(111);
                            t.exports = function (t) {
                                if (!i(t)) throw TypeError(String(t) + " is not an object");
                                return t
                            }
                        }, 1318: (t, e, n) => {
                            var i = n(5656), r = n(7466), o = n(1400), s = function (t) {
                                return function (e, n, s) {
                                    var a, l = i(e), c = r(l.length), u = o(s, c);
                                    if (t && n != n) {
                                        for (; c > u;) if ((a = l[u++]) != a) return !0
                                    } else for (; c > u; u++) if ((t || u in l) && l[u] === n) return t || u || 0;
                                    return !t && -1
                                }
                            };
                            t.exports = {includes: s(!0), indexOf: s(!1)}
                        }, 4326: t => {
                            var e = {}.toString;
                            t.exports = function (t) {
                                return e.call(t).slice(8, -1)
                            }
                        }, 9920: (t, e, n) => {
                            var i = n(6656), r = n(3887), o = n(1236), s = n(3070);
                            t.exports = function (t, e) {
                                for (var n = r(e), a = s.f, l = o.f, c = 0; c < n.length; c++) {
                                    var u = n[c];
                                    i(t, u) || a(t, u, l(e, u))
                                }
                            }
                        }, 8544: (t, e, n) => {
                            var i = n(7293);
                            t.exports = !i((function () {
                                function t() {
                                }

                                return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype
                            }))
                        }, 4994: (t, e, n) => {
                            "use strict";
                            var i = n(3383).IteratorPrototype, r = n(30), o = n(9114), s = n(8003), a = n(7497),
                                l = function () {
                                    return this
                                };
                            t.exports = function (t, e, n) {
                                var c = e + " Iterator";
                                return t.prototype = r(i, {next: o(1, n)}), s(t, c, !1, !0), a[c] = l, t
                            }
                        }, 8880: (t, e, n) => {
                            var i = n(9781), r = n(3070), o = n(9114);
                            t.exports = i ? function (t, e, n) {
                                return r.f(t, e, o(1, n))
                            } : function (t, e, n) {
                                return t[e] = n, t
                            }
                        }, 9114: t => {
                            t.exports = function (t, e) {
                                return {enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e}
                            }
                        }, 654: (t, e, n) => {
                            "use strict";
                            var i = n(2109), r = n(4994), o = n(9518), s = n(7674), a = n(8003), l = n(8880),
                                c = n(1320), u = n(5112), h = n(1913), d = n(7497), p = n(3383),
                                f = p.IteratorPrototype, m = p.BUGGY_SAFARI_ITERATORS, g = u("iterator"), v = "keys",
                                y = "values", x = "entries", _ = function () {
                                    return this
                                };
                            t.exports = function (t, e, n, u, p, b, w) {
                                r(n, e, u);
                                var S, M, T, E = function (t) {
                                        if (t === p && R) return R;
                                        if (!m && t in L) return L[t];
                                        switch (t) {
                                            case v:
                                            case y:
                                            case x:
                                                return function () {
                                                    return new n(this, t)
                                                }
                                        }
                                        return function () {
                                            return new n(this)
                                        }
                                    }, A = e + " Iterator", P = !1, L = t.prototype,
                                    C = L[g] || L["@@iterator"] || p && L[p], R = !m && C || E(p),
                                    I = "Array" == e && L.entries || C;
                                if (I && (S = o(I.call(new t)), f !== Object.prototype && S.next && (h || o(S) === f || (s ? s(S, f) : "function" != typeof S[g] && l(S, g, _)), a(S, A, !0, !0), h && (d[A] = _))), p == y && C && C.name !== y && (P = !0, R = function () {
                                    return C.call(this)
                                }), h && !w || L[g] === R || l(L, g, R), d[e] = R, p) if (M = {
                                    values: E(y),
                                    keys: b ? R : E(v),
                                    entries: E(x)
                                }, w) for (T in M) (m || P || !(T in L)) && c(L, T, M[T]); else i({
                                    target: e,
                                    proto: !0,
                                    forced: m || P
                                }, M);
                                return M
                            }
                        }, 9781: (t, e, n) => {
                            var i = n(7293);
                            t.exports = !i((function () {
                                return 7 != Object.defineProperty({}, 1, {
                                    get: function () {
                                        return 7
                                    }
                                })[1]
                            }))
                        }, 317: (t, e, n) => {
                            var i = n(7854), r = n(111), o = i.document, s = r(o) && r(o.createElement);
                            t.exports = function (t) {
                                return s ? o.createElement(t) : {}
                            }
                        }, 8324: t => {
                            t.exports = {
                                CSSRuleList: 0,
                                CSSStyleDeclaration: 0,
                                CSSValueList: 0,
                                ClientRectList: 0,
                                DOMRectList: 0,
                                DOMStringList: 0,
                                DOMTokenList: 1,
                                DataTransferItemList: 0,
                                FileList: 0,
                                HTMLAllCollection: 0,
                                HTMLCollection: 0,
                                HTMLFormElement: 0,
                                HTMLSelectElement: 0,
                                MediaList: 0,
                                MimeTypeArray: 0,
                                NamedNodeMap: 0,
                                NodeList: 1,
                                PaintRequestList: 0,
                                Plugin: 0,
                                PluginArray: 0,
                                SVGLengthList: 0,
                                SVGNumberList: 0,
                                SVGPathSegList: 0,
                                SVGPointList: 0,
                                SVGStringList: 0,
                                SVGTransformList: 0,
                                SourceBufferList: 0,
                                StyleSheetList: 0,
                                TextTrackCueList: 0,
                                TextTrackList: 0,
                                TouchList: 0
                            }
                        }, 5268: (t, e, n) => {
                            var i = n(4326), r = n(7854);
                            t.exports = "process" == i(r.process)
                        }, 8113: (t, e, n) => {
                            var i = n(5005);
                            t.exports = i("navigator", "userAgent") || ""
                        }, 7392: (t, e, n) => {
                            var i, r, o = n(7854), s = n(8113), a = o.process, l = a && a.versions, c = l && l.v8;
                            c ? r = (i = c.split("."))[0] + i[1] : s && (!(i = s.match(/Edge\/(\d+)/)) || i[1] >= 74) && (i = s.match(/Chrome\/(\d+)/)) && (r = i[1]), t.exports = r && +r
                        }, 748: t => {
                            t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
                        }, 2109: (t, e, n) => {
                            var i = n(7854), r = n(1236).f, o = n(8880), s = n(1320), a = n(3505), l = n(9920),
                                c = n(4705);
                            t.exports = function (t, e) {
                                var n, u, h, d, p, f = t.target, m = t.global, g = t.stat;
                                if (n = m ? i : g ? i[f] || a(f, {}) : (i[f] || {}).prototype) for (u in e) {
                                    if (d = e[u], h = t.noTargetGet ? (p = r(n, u)) && p.value : n[u], !c(m ? u : f + (g ? "." : "#") + u, t.forced) && void 0 !== h) {
                                        if (typeof d == typeof h) continue;
                                        l(d, h)
                                    }
                                    (t.sham || h && h.sham) && o(d, "sham", !0), s(n, u, d, t)
                                }
                            }
                        }, 7293: t => {
                            t.exports = function (t) {
                                try {
                                    return !!t()
                                } catch (t) {
                                    return !0
                                }
                            }
                        }, 5005: (t, e, n) => {
                            var i = n(857), r = n(7854), o = function (t) {
                                return "function" == typeof t ? t : void 0
                            };
                            t.exports = function (t, e) {
                                return arguments.length < 2 ? o(i[t]) || o(r[t]) : i[t] && i[t][e] || r[t] && r[t][e]
                            }
                        }, 7854: (t, e, n) => {
                            var i = function (t) {
                                return t && t.Math == Math && t
                            };
                            t.exports = i("object" == typeof globalThis && globalThis) || i("object" == typeof window && window) || i("object" == typeof self && self) || i("object" == typeof n.g && n.g) || function () {
                                return this
                            }() || Function("return this")()
                        }, 6656: (t, e, n) => {
                            var i = n(7908), r = {}.hasOwnProperty;
                            t.exports = function (t, e) {
                                return r.call(i(t), e)
                            }
                        }, 3501: t => {
                            t.exports = {}
                        }, 490: (t, e, n) => {
                            var i = n(5005);
                            t.exports = i("document", "documentElement")
                        }, 4664: (t, e, n) => {
                            var i = n(9781), r = n(7293), o = n(317);
                            t.exports = !i && !r((function () {
                                return 7 != Object.defineProperty(o("div"), "a", {
                                    get: function () {
                                        return 7
                                    }
                                }).a
                            }))
                        }, 8361: (t, e, n) => {
                            var i = n(7293), r = n(4326), o = "".split;
                            t.exports = i((function () {
                                return !Object("z").propertyIsEnumerable(0)
                            })) ? function (t) {
                                return "String" == r(t) ? o.call(t, "") : Object(t)
                            } : Object
                        }, 2788: (t, e, n) => {
                            var i = n(5465), r = Function.toString;
                            "function" != typeof i.inspectSource && (i.inspectSource = function (t) {
                                return r.call(t)
                            }), t.exports = i.inspectSource
                        }, 9909: (t, e, n) => {
                            var i, r, o, s = n(8536), a = n(7854), l = n(111), c = n(8880), u = n(6656), h = n(5465),
                                d = n(6200), p = n(3501), f = "Object already initialized", m = a.WeakMap;
                            if (s) {
                                var g = h.state || (h.state = new m), v = g.get, y = g.has, x = g.set;
                                i = function (t, e) {
                                    if (y.call(g, t)) throw new TypeError(f);
                                    return e.facade = t, x.call(g, t, e), e
                                }, r = function (t) {
                                    return v.call(g, t) || {}
                                }, o = function (t) {
                                    return y.call(g, t)
                                }
                            } else {
                                var _ = d("state");
                                p[_] = !0, i = function (t, e) {
                                    if (u(t, _)) throw new TypeError(f);
                                    return e.facade = t, c(t, _, e), e
                                }, r = function (t) {
                                    return u(t, _) ? t[_] : {}
                                }, o = function (t) {
                                    return u(t, _)
                                }
                            }
                            t.exports = {
                                set: i, get: r, has: o, enforce: function (t) {
                                    return o(t) ? r(t) : i(t, {})
                                }, getterFor: function (t) {
                                    return function (e) {
                                        var n;
                                        if (!l(e) || (n = r(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required");
                                        return n
                                    }
                                }
                            }
                        }, 4705: (t, e, n) => {
                            var i = n(7293), r = /#|\.prototype\./, o = function (t, e) {
                                var n = a[s(t)];
                                return n == c || n != l && ("function" == typeof e ? i(e) : !!e)
                            }, s = o.normalize = function (t) {
                                return String(t).replace(r, ".").toLowerCase()
                            }, a = o.data = {}, l = o.NATIVE = "N", c = o.POLYFILL = "P";
                            t.exports = o
                        }, 111: t => {
                            t.exports = function (t) {
                                return "object" == typeof t ? null !== t : "function" == typeof t
                            }
                        }, 1913: t => {
                            t.exports = !1
                        }, 3383: (t, e, n) => {
                            "use strict";
                            var i, r, o, s = n(7293), a = n(9518), l = n(8880), c = n(6656), u = n(5112), h = n(1913),
                                d = u("iterator"), p = !1;
                            [].keys && ("next" in (o = [].keys()) ? (r = a(a(o))) !== Object.prototype && (i = r) : p = !0);
                            var f = null == i || s((function () {
                                var t = {};
                                return i[d].call(t) !== t
                            }));
                            f && (i = {}), h && !f || c(i, d) || l(i, d, (function () {
                                return this
                            })), t.exports = {IteratorPrototype: i, BUGGY_SAFARI_ITERATORS: p}
                        }, 7497: t => {
                            t.exports = {}
                        }, 133: (t, e, n) => {
                            var i = n(5268), r = n(7392), o = n(7293);
                            t.exports = !!Object.getOwnPropertySymbols && !o((function () {
                                return !Symbol.sham && (i ? 38 === r : r > 37 && r < 41)
                            }))
                        }, 8536: (t, e, n) => {
                            var i = n(7854), r = n(2788), o = i.WeakMap;
                            t.exports = "function" == typeof o && /native code/.test(r(o))
                        }, 30: (t, e, n) => {
                            var i, r = n(9670), o = n(6048), s = n(748), a = n(3501), l = n(490), c = n(317),
                                u = n(6200), h = u("IE_PROTO"), d = function () {
                                }, p = function (t) {
                                    return "<script>" + t + "<\/script>"
                                }, f = function () {
                                    try {
                                        i = document.domain && new ActiveXObject("htmlfile")
                                    } catch (t) {
                                    }
                                    var t, e;
                                    f = i ? function (t) {
                                        t.write(p("")), t.close();
                                        var e = t.parentWindow.Object;
                                        return t = null, e
                                    }(i) : ((e = c("iframe")).style.display = "none", l.appendChild(e), e.src = String("javascript:"), (t = e.contentWindow.document).open(), t.write(p("document.F=Object")), t.close(), t.F);
                                    for (var n = s.length; n--;) delete f.prototype[s[n]];
                                    return f()
                                };
                            a[h] = !0, t.exports = Object.create || function (t, e) {
                                var n;
                                return null !== t ? (d.prototype = r(t), n = new d, d.prototype = null, n[h] = t) : n = f(), void 0 === e ? n : o(n, e)
                            }
                        }, 6048: (t, e, n) => {
                            var i = n(9781), r = n(3070), o = n(9670), s = n(1956);
                            t.exports = i ? Object.defineProperties : function (t, e) {
                                o(t);
                                for (var n, i = s(e), a = i.length, l = 0; a > l;) r.f(t, n = i[l++], e[n]);
                                return t
                            }
                        }, 3070: (t, e, n) => {
                            var i = n(9781), r = n(4664), o = n(9670), s = n(7593), a = Object.defineProperty;
                            e.f = i ? a : function (t, e, n) {
                                if (o(t), e = s(e, !0), o(n), r) try {
                                    return a(t, e, n)
                                } catch (t) {
                                }
                                if ("get" in n || "set" in n) throw TypeError("Accessors not supported");
                                return "value" in n && (t[e] = n.value), t
                            }
                        }, 1236: (t, e, n) => {
                            var i = n(9781), r = n(5296), o = n(9114), s = n(5656), a = n(7593), l = n(6656),
                                c = n(4664), u = Object.getOwnPropertyDescriptor;
                            e.f = i ? u : function (t, e) {
                                if (t = s(t), e = a(e, !0), c) try {
                                    return u(t, e)
                                } catch (t) {
                                }
                                if (l(t, e)) return o(!r.f.call(t, e), t[e])
                            }
                        }, 8006: (t, e, n) => {
                            var i = n(6324), r = n(748).concat("length", "prototype");
                            e.f = Object.getOwnPropertyNames || function (t) {
                                return i(t, r)
                            }
                        }, 5181: (t, e) => {
                            e.f = Object.getOwnPropertySymbols
                        }, 9518: (t, e, n) => {
                            var i = n(6656), r = n(7908), o = n(6200), s = n(8544), a = o("IE_PROTO"),
                                l = Object.prototype;
                            t.exports = s ? Object.getPrototypeOf : function (t) {
                                return t = r(t), i(t, a) ? t[a] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? l : null
                            }
                        }, 6324: (t, e, n) => {
                            var i = n(6656), r = n(5656), o = n(1318).indexOf, s = n(3501);
                            t.exports = function (t, e) {
                                var n, a = r(t), l = 0, c = [];
                                for (n in a) !i(s, n) && i(a, n) && c.push(n);
                                for (; e.length > l;) i(a, n = e[l++]) && (~o(c, n) || c.push(n));
                                return c
                            }
                        }, 1956: (t, e, n) => {
                            var i = n(6324), r = n(748);
                            t.exports = Object.keys || function (t) {
                                return i(t, r)
                            }
                        }, 5296: (t, e) => {
                            "use strict";
                            var n = {}.propertyIsEnumerable, i = Object.getOwnPropertyDescriptor,
                                r = i && !n.call({1: 2}, 1);
                            e.f = r ? function (t) {
                                var e = i(this, t);
                                return !!e && e.enumerable
                            } : n
                        }, 7674: (t, e, n) => {
                            var i = n(9670), r = n(6077);
                            t.exports = Object.setPrototypeOf || ("__proto__" in {} ? function () {
                                var t, e = !1, n = {};
                                try {
                                    (t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n, []), e = n instanceof Array
                                } catch (t) {
                                }
                                return function (n, o) {
                                    return i(n), r(o), e ? t.call(n, o) : n.__proto__ = o, n
                                }
                            }() : void 0)
                        }, 3887: (t, e, n) => {
                            var i = n(5005), r = n(8006), o = n(5181), s = n(9670);
                            t.exports = i("Reflect", "ownKeys") || function (t) {
                                var e = r.f(s(t)), n = o.f;
                                return n ? e.concat(n(t)) : e
                            }
                        }, 857: (t, e, n) => {
                            var i = n(7854);
                            t.exports = i
                        }, 1320: (t, e, n) => {
                            var i = n(7854), r = n(8880), o = n(6656), s = n(3505), a = n(2788), l = n(9909), c = l.get,
                                u = l.enforce, h = String(String).split("String");
                            (t.exports = function (t, e, n, a) {
                                var l, c = !!a && !!a.unsafe, d = !!a && !!a.enumerable, p = !!a && !!a.noTargetGet;
                                "function" == typeof n && ("string" != typeof e || o(n, "name") || r(n, "name", e), (l = u(n)).source || (l.source = h.join("string" == typeof e ? e : ""))), t !== i ? (c ? !p && t[e] && (d = !0) : delete t[e], d ? t[e] = n : r(t, e, n)) : d ? t[e] = n : s(e, n)
                            })(Function.prototype, "toString", (function () {
                                return "function" == typeof this && c(this).source || a(this)
                            }))
                        }, 4488: t => {
                            t.exports = function (t) {
                                if (null == t) throw TypeError("Can't call method on " + t);
                                return t
                            }
                        }, 3505: (t, e, n) => {
                            var i = n(7854), r = n(8880);
                            t.exports = function (t, e) {
                                try {
                                    r(i, t, e)
                                } catch (n) {
                                    i[t] = e
                                }
                                return e
                            }
                        }, 8003: (t, e, n) => {
                            var i = n(3070).f, r = n(6656), o = n(5112)("toStringTag");
                            t.exports = function (t, e, n) {
                                t && !r(t = n ? t : t.prototype, o) && i(t, o, {configurable: !0, value: e})
                            }
                        }, 6200: (t, e, n) => {
                            var i = n(2309), r = n(9711), o = i("keys");
                            t.exports = function (t) {
                                return o[t] || (o[t] = r(t))
                            }
                        }, 5465: (t, e, n) => {
                            var i = n(7854), r = n(3505), o = "__core-js_shared__", s = i[o] || r(o, {});
                            t.exports = s
                        }, 2309: (t, e, n) => {
                            var i = n(1913), r = n(5465);
                            (t.exports = function (t, e) {
                                return r[t] || (r[t] = void 0 !== e ? e : {})
                            })("versions", []).push({
                                version: "3.11.1",
                                mode: i ? "pure" : "global",
                                copyright: "Â© 2021 Denis Pushkarev (zloirock.ru)"
                            })
                        }, 1400: (t, e, n) => {
                            var i = n(9958), r = Math.max, o = Math.min;
                            t.exports = function (t, e) {
                                var n = i(t);
                                return n < 0 ? r(n + e, 0) : o(n, e)
                            }
                        }, 5656: (t, e, n) => {
                            var i = n(8361), r = n(4488);
                            t.exports = function (t) {
                                return i(r(t))
                            }
                        }, 9958: t => {
                            var e = Math.ceil, n = Math.floor;
                            t.exports = function (t) {
                                return isNaN(t = +t) ? 0 : (t > 0 ? n : e)(t)
                            }
                        }, 7466: (t, e, n) => {
                            var i = n(9958), r = Math.min;
                            t.exports = function (t) {
                                return t > 0 ? r(i(t), 9007199254740991) : 0
                            }
                        }, 7908: (t, e, n) => {
                            var i = n(4488);
                            t.exports = function (t) {
                                return Object(i(t))
                            }
                        }, 7593: (t, e, n) => {
                            var i = n(111);
                            t.exports = function (t, e) {
                                if (!i(t)) return t;
                                var n, r;
                                if (e && "function" == typeof (n = t.toString) && !i(r = n.call(t))) return r;
                                if ("function" == typeof (n = t.valueOf) && !i(r = n.call(t))) return r;
                                if (!e && "function" == typeof (n = t.toString) && !i(r = n.call(t))) return r;
                                throw TypeError("Can't convert object to primitive value")
                            }
                        }, 9711: t => {
                            var e = 0, n = Math.random();
                            t.exports = function (t) {
                                return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++e + n).toString(36)
                            }
                        }, 3307: (t, e, n) => {
                            var i = n(133);
                            t.exports = i && !Symbol.sham && "symbol" == typeof Symbol.iterator
                        }, 5112: (t, e, n) => {
                            var i = n(7854), r = n(2309), o = n(6656), s = n(9711), a = n(133), l = n(3307),
                                c = r("wks"), u = i.Symbol, h = l ? u : u && u.withoutSetter || s;
                            t.exports = function (t) {
                                return o(c, t) && (a || "string" == typeof c[t]) || (a && o(u, t) ? c[t] = u[t] : c[t] = h("Symbol." + t)), c[t]
                            }
                        }, 6992: (t, e, n) => {
                            "use strict";
                            var i = n(5656), r = n(1223), o = n(7497), s = n(9909), a = n(654), l = "Array Iterator",
                                c = s.set, u = s.getterFor(l);
                            t.exports = a(Array, "Array", (function (t, e) {
                                c(this, {type: l, target: i(t), index: 0, kind: e})
                            }), (function () {
                                var t = u(this), e = t.target, n = t.kind, i = t.index++;
                                return !e || i >= e.length ? (t.target = void 0, {
                                    value: void 0,
                                    done: !0
                                }) : "keys" == n ? {value: i, done: !1} : "values" == n ? {
                                    value: e[i],
                                    done: !1
                                } : {value: [i, e[i]], done: !1}
                            }), "values"), o.Arguments = o.Array, r("keys"), r("values"), r("entries")
                        }, 3948: (t, e, n) => {
                            var i = n(7854), r = n(8324), o = n(6992), s = n(8880), a = n(5112), l = a("iterator"),
                                c = a("toStringTag"), u = o.values;
                            for (var h in r) {
                                var d = i[h], p = d && d.prototype;
                                if (p) {
                                    if (p[l] !== u) try {
                                        s(p, l, u)
                                    } catch (t) {
                                        p[l] = u
                                    }
                                    if (p[c] || s(p, c, h), r[h]) for (var f in o) if (p[f] !== o[f]) try {
                                        s(p, f, o[f])
                                    } catch (t) {
                                        p[f] = o[f]
                                    }
                                }
                            }
                        }
                    }, e = {};

                    function n(i) {
                        var r = e[i];
                        if (void 0 !== r) return r.exports;
                        var o = e[i] = {exports: {}};
                        return t[i](o, o.exports, n), o.exports
                    }

                    n.n = t => {
                        var e = t && t.__esModule ? () => t.default : () => t;
                        return n.d(e, {a: e}), e
                    }, n.d = (t, e) => {
                        for (var i in e) n.o(e, i) && !n.o(t, i) && Object.defineProperty(t, i, {
                            enumerable: !0,
                            get: e[i]
                        })
                    }, n.g = function () {
                        if ("object" == typeof globalThis) return globalThis;
                        try {
                            return this || new Function("return this")()
                        } catch (t) {
                            if ("object" == typeof window) return window
                        }
                    }(), n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
                    var i = {};
                    return (() => {
                        "use strict";
                        n.d(i, {default: () => O});
                        var t = n(5336), e = n.n(t), r = n(4672), o = n.n(r);

                        function s() {
                            if (!(this instanceof s)) return new s;
                            this.size = 0, this.uid = 0, this.selectors = [], this.selectorObjects = {}, this.indexes = Object.create(this.indexes), this.activeIndexes = []
                        }

                        var a = window.document.documentElement,
                            l = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector;
                        s.prototype.matchesSelector = function (t, e) {
                            return l.call(t, e)
                        }, s.prototype.querySelectorAll = function (t, e) {
                            return e.querySelectorAll(t)
                        }, s.prototype.indexes = [];
                        var c = /^#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
                        s.prototype.indexes.push({
                            name: "ID", selector: function (t) {
                                var e;
                                if (e = t.match(c)) return e[0].slice(1)
                            }, element: function (t) {
                                if (t.id) return [t.id]
                            }
                        });
                        var u = /^\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
                        s.prototype.indexes.push({
                            name: "CLASS", selector: function (t) {
                                var e;
                                if (e = t.match(u)) return e[0].slice(1)
                            }, element: function (t) {
                                var e = t.className;
                                if (e) {
                                    if ("string" == typeof e) return e.split(/\s/);
                                    if ("object" == typeof e && "baseVal" in e) return e.baseVal.split(/\s/)
                                }
                            }
                        });
                        var h, d = /^((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
                        s.prototype.indexes.push({
                            name: "TAG", selector: function (t) {
                                var e;
                                if (e = t.match(d)) return e[0].toUpperCase()
                            }, element: function (t) {
                                return [t.nodeName.toUpperCase()]
                            }
                        }), s.prototype.indexes.default = {
                            name: "UNIVERSAL", selector: function () {
                                return !0
                            }, element: function () {
                                return [!0]
                            }
                        }, h = "function" == typeof window.Map ? window.Map : function () {
                            function t() {
                                this.map = {}
                            }

                            return t.prototype.get = function (t) {
                                return this.map[t + " "]
                            }, t.prototype.set = function (t, e) {
                                this.map[t + " "] = e
                            }, t
                        }();
                        var p = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g;

                        function f(t, e) {
                            var n, i, r, o, s, a, l = (t = t.slice(0).concat(t.default)).length, c = e, u = [];
                            do {
                                if (p.exec(""), (r = p.exec(c)) && (c = r[3], r[2] || !c)) for (n = 0; n < l; n++) if (s = (a = t[n]).selector(r[1])) {
                                    for (i = u.length, o = !1; i--;) if (u[i].index === a && u[i].key === s) {
                                        o = !0;
                                        break
                                    }
                                    o || u.push({index: a, key: s});
                                    break
                                }
                            } while (r);
                            return u
                        }

                        function m(t, e) {
                            var n, i, r;
                            for (n = 0, i = t.length; n < i; n++) if (r = t[n], e.isPrototypeOf(r)) return r
                        }

                        function g(t, e) {
                            return t.id - e.id
                        }

                        s.prototype.logDefaultIndexUsed = function () {
                        }, s.prototype.add = function (t, e) {
                            var n, i, r, o, s, a, l, c, u = this.activeIndexes, d = this.selectors,
                                p = this.selectorObjects;
                            if ("string" == typeof t) {
                                for (p[(n = {
                                    id: this.uid++,
                                    selector: t,
                                    data: e
                                }).id] = n, l = f(this.indexes, t), i = 0; i < l.length; i++) o = (c = l[i]).key, (s = m(u, r = c.index)) || ((s = Object.create(r)).map = new h, u.push(s)), r === this.indexes.default && this.logDefaultIndexUsed(n), (a = s.map.get(o)) || (a = [], s.map.set(o, a)), a.push(n);
                                this.size++, d.push(t)
                            }
                        }, s.prototype.remove = function (t, e) {
                            if ("string" == typeof t) {
                                var n, i, r, o, s, a, l, c, u = this.activeIndexes, h = this.selectors = [],
                                    d = this.selectorObjects, p = {}, m = 1 === arguments.length;
                                for (n = f(this.indexes, t), r = 0; r < n.length; r++) for (i = n[r], o = u.length; o--;) if (a = u[o], i.index.isPrototypeOf(a)) {
                                    if (l = a.map.get(i.key)) for (s = l.length; s--;) (c = l[s]).selector !== t || !m && c.data !== e || (l.splice(s, 1), p[c.id] = !0);
                                    break
                                }
                                for (r in p) delete d[r], this.size--;
                                for (r in d) h.push(d[r].selector)
                            }
                        }, s.prototype.queryAll = function (t) {
                            if (!this.selectors.length) return [];
                            var e, n, i, r, o, s, a, l, c = {}, u = [],
                                h = this.querySelectorAll(this.selectors.join(", "), t);
                            for (e = 0, i = h.length; e < i; e++) for (o = h[e], n = 0, r = (s = this.matches(o)).length; n < r; n++) c[(l = s[n]).id] ? a = c[l.id] : (a = {
                                id: l.id,
                                selector: l.selector,
                                data: l.data,
                                elements: []
                            }, c[l.id] = a, u.push(a)), a.elements.push(o);
                            return u.sort(g)
                        }, s.prototype.matches = function (t) {
                            if (!t) return [];
                            var e, n, i, r, o, s, a, l, c, u, h, d = this.activeIndexes, p = {}, f = [];
                            for (e = 0, r = d.length; e < r; e++) if (l = (a = d[e]).element(t)) for (n = 0, o = l.length; n < o; n++) if (c = a.map.get(l[n])) for (i = 0, s = c.length; i < s; i++) !p[h = (u = c[i]).id] && this.matchesSelector(t, u.selector) && (p[h] = !0, f.push(u));
                            return f.sort(g)
                        };
                        const v = {}, y = {}, x = ["mouseenter", "mouseleave"];

                        function _(t) {
                            void 0 === y[t] && (y[t] = [])
                        }

                        function b(t) {
                            return "string" == typeof t ? document.querySelectorAll(t) : t
                        }

                        function w(t) {
                            let e = function (t, e) {
                                const n = [];
                                let i = e;
                                do {
                                    if (1 !== i.nodeType) break;
                                    const e = t.matches(i);
                                    e.length && n.push({delegatedTarget: i, stack: e})
                                } while (i = i.parentElement);
                                return n
                            }(v[t.type], t.target);
                            if (e.length) for (let n = 0; n < e.length; n++) for (let i = 0; i < e[n].stack.length; i++) -1 !== x.indexOf(t.type) ? (S(t, e[n].delegatedTarget), t.target === e[n].delegatedTarget && e[n].stack[i].data(t)) : (S(t, e[n].delegatedTarget), e[n].stack[i].data(t))
                        }

                        function S(t, e) {
                            Object.defineProperty(t, "currentTarget", {configurable: !0, enumerable: !0, get: () => e})
                        }

                        function M(t) {
                            return JSON.parse(JSON.stringify(t))
                        }

                        const T = new class {
                            bindAll(t, e) {
                                void 0 === e && (e = Object.getOwnPropertyNames(Object.getPrototypeOf(t)));
                                for (let n = 0; n < e.length; n++) t[e[n]] = t[e[n]].bind(t)
                            }

                            on(t, e, n, i) {
                                if ("function" == typeof e && void 0 === n) return _(t), void y[t].push(e);
                                const r = t.split(" ");
                                for (let t = 0; t < r.length; t++) if (e.nodeType && 1 === e.nodeType || e === window || e === document) e.addEventListener(r[t], n, i); else {
                                    e = b(e);
                                    for (let o = 0; o < e.length; o++) e[o].addEventListener(r[t], n, i)
                                }
                            }

                            delegate(t, e, n) {
                                const i = t.split(" ");
                                for (let t = 0; t < i.length; t++) {
                                    let r = v[i[t]];
                                    void 0 === r && (r = new s, v[i[t]] = r, -1 !== x.indexOf(i[t]) ? document.addEventListener(i[t], w, !0) : document.addEventListener(i[t], w)), r.add(e, n)
                                }
                            }

                            off(t, e, n, i) {
                                if (void 0 === e) return void (y[t] = []);
                                if ("function" == typeof e) {
                                    _(t);
                                    for (let n = 0; n < y[t].length; n++) y[t][n] === e && y[t].splice(n, 1);
                                    return
                                }
                                const r = t.split(" ");
                                for (let t = 0; t < r.length; t++) {
                                    const o = v[r[t]];
                                    if (void 0 === o || (o.remove(e, n), 0 !== o.size)) if (void 0 === e.removeEventListener) {
                                        e = b(e);
                                        for (let o = 0; o < e.length; o++) e[o].removeEventListener(r[t], n, i)
                                    } else e.removeEventListener(r[t], n, i); else delete v[r[t]], document.removeEventListener(r[t], w)
                                }
                            }

                            emit(t, ...e) {
                                !function (t, e) {
                                    if (y[t]) for (let n = 0; n < y[t].length; n++) y[t][n](...e)
                                }(t, e)
                            }

                            debugDelegated() {
                                return M(v)
                            }

                            debugBus() {
                                return M(y)
                            }
                        };

                        function E(t, e, n) {
                            return e in t ? Object.defineProperty(t, e, {
                                value: n,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : t[e] = n, t
                        }

                        class A {
                            constructor(t = {}) {
                                E(this, "onRaf", (() => {
                                    T.emit(A.INTERNALRAF), this.options.disableRaf || requestAnimationFrame(this.onRaf)
                                })), this.options = t, this.addEvents()
                            }

                            addEvents() {
                                this.options.disableRaf || requestAnimationFrame(this.onRaf), this.options.disableResize || T.on("resize", window, e()((() => {
                                    this.onResize()
                                }), 150)), this.onScroll(), "ontouchstart" in document.documentElement && (o().isTouch = !0, this.detectMouse())
                            }

                            onScroll() {
                                T.on("wheel", window, (t => {
                                    T.emit(A.WHEEL, {event: t})
                                }), {passive: !1}), T.on("scroll", window, (t => {
                                    T.emit(A.INTERNALSCROLL, {event: t})
                                }), {passive: !0})
                            }

                            onResize({width: t, height: e} = {}) {
                                o().window.w = t || window.innerWidth, o().window.h = e || window.innerHeight, T.emit(A.RESIZE)
                            }

                            detectMouse() {
                                window.addEventListener("mousemove", (function t(e) {
                                    (Math.abs(e.movementX) > 0 || Math.abs(e.movementY) > 0) && (o().isTouch = !1, T.emit(A.MOUSEDETECTED), window.removeEventListener("mousemove", t))
                                }))
                            }
                        }

                        function P(t, e, n) {
                            return e in t ? Object.defineProperty(t, e, {
                                value: n,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : t[e] = n, t
                        }

                        E(A, "INTERNALRAF", "raf:internal"), E(A, "EXTERNALRAF", "raf:external"), E(A, "WHEEL", "wheel"), E(A, "INTERNALSCROLL", "scroll:internal"), E(A, "EXTERNALSCROLL", "scroll:external"), E(A, "RESIZE", "resize"), E(A, "MOUSEDETECTED", "mouseDetected"), E(A, "SCROLLEND", "scrollEnd"), n(3948);

                        class L {
                            constructor(t) {
                                P(this, "onMouseMove", (t => {
                                    this.mouseDown && (this.mousePos = t.clientY, this.position -= this.prevMousePos - this.mousePos, this.position = Math.min(Math.max(this.position, 0), this.maxY), this.prevMousePos = this.mousePos, this.controller.targetPos = this.position / this.maxY * this.controller.maxScroll, this.controller.clamp(), this.controller.syncScroll = !0, this.transform(), T.emit(A.EXTERNALSCROLL, -this.controller.targetPos))
                                })), P(this, "onMouseDown", (t => {
                                    this.mousePos = this.prevMousePos = t.clientY, this.mouseDown = !0, o().body.style.userSelect = "none", this.el.classList.add("active")
                                })), P(this, "onMouseUp", (() => {
                                    this.mouseDown = !1, o().body.style.removeProperty("user-select"), this.el.classList.remove("active")
                                })), this.controller = t, this.addHTML(), this.el = document.querySelector(this.controller.options.scrollbarEl), this.handle = document.querySelector(this.controller.options.scrollbarHandleEl), this.position = 0, this.mousePos = 0, this.prevMousePos = 0, this.addStyles(), this.addEvents()
                            }

                            transform() {
                                let t;
                                this.mouseDown ? t = this.position : (t = -this.controller.targetPos / -this.controller.maxScroll * (o().window.h - this.handleHeight), this.position = t), this.handle.style.transform = "translate3d(0, ".concat(t, "px, 0)")
                            }

                            show() {
                                this.el.classList.add("show")
                            }

                            hide() {
                                this.el.classList.remove("show")
                            }

                            addEvents() {
                                T.on("mousedown", this.handle, this.onMouseDown), T.on("mousemove", window, this.onMouseMove), T.on("mouseup", window, this.onMouseUp)
                            }

                            onResize() {
                                this.scale = (-this.controller.maxScroll + o().window.h) / o().window.h, this.scale <= 1 ? this.handle.style.height = 0 : (this.trueSize = o().window.h / this.scale, this.handleHeight = Math.max(this.trueSize, 40), this.handle.style.height = "".concat(this.handleHeight, "px"), this.maxY = o().window.h - this.handleHeight)
                            }

                            addHTML() {
                                if (document.querySelector(this.controller.options.scrollbarEl)) return;
                                const t = document.createElement("div");
                                t.classList.add(this.controller.options.scrollbarEl.substring(1)), t.innerHTML = '<div class="'.concat(this.controller.options.scrollbarHandleEl.substring(1), '"><div></div></div>'), document.body.appendChild(t)
                            }

                            addStyles() {
                                if (!this.controller.options.disableNativeScrollbar && !this.controller.options.scrollbarStyles) return;
                                let t = "";
                                this.controller.options.disableNativeScrollbar && (t += "html{scrollbar-width:none;}body{-ms-overflow-style:none;}body::-webkit-scrollbar{width:0;height:0;}"), this.controller.options.scrollbarStyles && (t += "".concat(this.controller.options.scrollbarEl, " {position:fixed;top:0;right:0;width:20px;height:100%;z-index:900;}.is-touch ").concat(this.controller.options.scrollbarEl, " {display:none;}").concat(this.controller.options.scrollbarEl, " > div {padding:6px 0;width:10px;height:0;margin:0 auto;visibility:hidden;}").concat(this.controller.options.scrollbarEl, " > div > div {width:100%;height:100%;border-radius:10px;opacity:0.3;background-color:#000;}").concat(this.controller.options.scrollbarEl, " > div > div:hover {opacity:0.9;}").concat(this.controller.options.scrollbarEl, ":hover > div, ").concat(this.controller.options.scrollbarEl, ".show > div, ").concat(this.controller.options.scrollbarEl, ".active > div {visibility:visible;}").concat(this.controller.options.scrollbarEl, ".active > div > div {opacity:0.9;}"));
                                const e = document.createElement("style");
                                e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t)), document.getElementsByTagName("head")[0].appendChild(e)
                            }

                            destroy() {
                                T.off("mousedown", this.handle, this.onMouseDown), T.off("mousemove", window, this.onMouseMove), T.off("mouseup", window, this.onMouseUp)
                            }
                        }

                        function C(t, e, n) {
                            return e in t ? Object.defineProperty(t, e, {
                                value: n,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : t[e] = n, t
                        }

                        class R {
                            constructor(t = {}) {
                                C(this, "onScroll", (({event: t}) => {
                                    if (this.scrolling || (this.options.customScrollbar && this.scrollbar.show(), this.toggleIframes(), this.scrolling = !0), o().isTouch || "wheel" !== t.type) {
                                        if (this.preventResizeScroll) return void (this.preventResizeScroll = !1);
                                        o().isTouch && "scrollTop" === this.options.touchScrollType ? this.targetPos = this.horizontalScroll ? -this.containerElement.scrollLeft : -this.containerElement.scrollTop : this.targetPos = -window.scrollY, o().isTouch && "transform" !== this.options.touchScrollType && (this.currentPos = this.targetPos)
                                    } else t.preventDefault(), this.syncScroll = !0, this.targetPos += -1 * t.deltaY;
                                    this.clamp(), this.options.customScrollbar && this.scrollbar.transform(), T.emit(A.EXTERNALSCROLL, -this.targetPos)
                                })), C(this, "onRAF", (() => {
                                    if (this.testFps && this.options.limitLerpRate && (this.time = .001 * performance.now(), this.delta = Math.min(60 * (this.time - this.startTime), 1), this.startTime = this.time), !this.render) return;
                                    Math.abs(this.targetPos - this.currentPos) < .5 ? (this.currentPos = this.targetPos, this.scrolling && !this.syncScroll && (this.scrolling = !1, this.options.customScrollbar && this.scrollbar.hide(), this.toggleIframes(!0), T.emit(A.SCROLLEND, -this.targetPos)), this.syncScroll && (window.scrollTo(0, -this.targetPos), this.syncScroll = !1)) : this.currentPos += (this.targetPos - this.currentPos) * this.ease * this.delta;
                                    const t = this.horizontalScroll ? this.currentPos : 0,
                                        e = this.horizontalScroll ? 0 : this.currentPos;
                                    this.applyTransform(t, e), T.emit(A.EXTERNALRAF, {
                                        targetPos: -this.targetPos,
                                        currentPos: -this.currentPos
                                    })
                                })), C(this, "onResize", (() => {
                                    if (this.scrollElementsLength > 1) {
                                        const t = this.scrollElements[this.scrollElementsLength - 1],
                                            e = window.getComputedStyle(t),
                                            n = parseFloat(this.horizontalScroll ? e.marginRight : e.marginBottom),
                                            i = t.getBoundingClientRect(),
                                            r = this.horizontalScroll ? i.right : i.bottom;
                                        this.scrollLength = r + n - this.currentPos
                                    } else this.scrollLength = this.horizontalScroll ? this.scrollElements[0].scrollWidth : this.scrollElements[0].scrollHeight;
                                    const t = this.horizontalScroll ? o().window.w : o().window.h;
                                    this.maxScroll = this.scrollLength > t ? -(this.scrollLength - t) : 0, this.clamp(), this.firstResize || (this.preventResizeScroll = !0), o().body.style.height = this.scrollLength + "px", this.options.customScrollbar && this.scrollbar.onResize(), this.firstResize = !1
                                })), C(this, "toggleFixedContainer", (() => {
                                    this.containerElement.style.position = "static";
                                    const t = this.currentPos;
                                    this.applyTransform(0, 0), requestAnimationFrame((() => {
                                        this.containerElement.style.position = "fixed";
                                        const e = this.horizontalScroll ? t : 0, n = this.horizontalScroll ? 0 : t;
                                        this.applyTransform(e, n)
                                    }))
                                })), this.options = t, this.targetPos = this.currentPos = this.prevScrollPos = this.maxScroll = 0, this.enabled = !1, this.render = !1, this.scrolling = !1, this.syncScroll = !1, this.horizontalScroll = !1, this.firstResize = !0, this.preventResizeScroll = !1, this.nativeScroll = !0, this.ease = o().isTouch ? this.options.touchEase : this.options.ease, this.originalScrollbarSetting = this.options.customScrollbar, this.testFps = !0, this.delta = 1, this.time = this.startTime = performance.now(), this.setElements(), o().isTouch ? (this.options.customScrollbar = !1, "transform" === this.options.touchScrollType ? this.setupSmoothScroll() : "scrollTop" === this.options.touchScrollType && (document.documentElement.classList.add("asscroll-touch"), this.addTouchStyles(), T.on("scroll", this.containerElement, (t => {
                                    T.emit(A.INTERNALSCROLL, {event: t})
                                }), {passive: !0}))) : this.setupSmoothScroll(), this.addEvents()
                            }

                            setElements() {
                                this.containerElement = "string" == typeof this.options.containerElement ? document.querySelector(this.options.containerElement) : this.options.containerElement, null === this.containerElement && console.error("ASScroll: could not find container element"), this.containerElement.setAttribute("asscroll-container", ""), this.scrollElements = "string" == typeof this.options.scrollElements ? document.querySelectorAll(this.options.scrollElements) : this.options.scrollElements, this.scrollElements.length && (this.scrollElements = [...this.scrollElements]), this.scrollElements = this.scrollElements.length ? this.scrollElements : [this.containerElement.firstElementChild], this.scrollElementsLength = this.scrollElements.length, this.scrollElements.forEach((t => t.setAttribute("asscroll", "")))
                            }

                            setupSmoothScroll() {
                                this.nativeScroll = !1, Object.assign(this.containerElement.style, {
                                    position: "fixed",
                                    top: "0px",
                                    left: "0px",
                                    width: "100%",
                                    height: "100%",
                                    contain: "content"
                                }), this.options.customScrollbar && (this.scrollbar = new L(this)), T.on(A.INTERNALRAF, this.onRAF), T.on(A.RESIZE, this.onResize), this.options.limitLerpRate && setTimeout((() => {
                                    this.testFps = !1, this.delta = .1 * Math.round(10 * this.delta)
                                }), 2e3)
                            }

                            applyTransform(t, e) {
                                for (let n = 0; n < this.scrollElementsLength; n++) this.scrollElements[n].style.transform = "translate3d(".concat(t, "px, ").concat(e, "px, 0px)")
                            }

                            enable({
                                       newScrollElements: t = !1,
                                       reset: e = !1,
                                       restore: n = !1,
                                       horizontalScroll: i = !1
                                   } = {}) {
                                this.enabled || (this.enabled = !0, this.render = !0, this.horizontalScroll = i, t && (this.scrollElements = t.length ? [...t] : [t], this.scrollElementsLength = this.scrollElements.length, this.scrollElements.forEach((t => t.setAttribute("asscroll", "")))), this.iframes = this.containerElement.querySelectorAll("iframe"), o().isTouch && "transform" !== this.options.touchScrollType ? (o().body.style.removeProperty("height"), this.maxScroll = -this.containerElement.scrollHeight, e && (this.targetPos = this.currentPos = 0, this.scrollTo(0, !1))) : (this.firstResize = !0, e && (this.targetPos = this.currentPos = 0, this.applyTransform(0, 0)), this.onResize()), n && this.scrollTo(this.prevScrollPos, !1), T.on(A.WHEEL, this.onScroll), T.on(A.INTERNALSCROLL, this.onScroll))
                            }

                            disable({inputOnly: t = !1} = {}) {
                                this.enabled && (this.enabled = !1, t || (this.render = !1), T.off(A.WHEEL, this.onScroll), T.off(A.INTERNALSCROLL, this.onScroll), this.prevScrollPos = this.targetPos, o().body.style.height = "0px")
                            }

                            clamp() {
                                this.targetPos = Math.max(Math.min(this.targetPos, 0), this.maxScroll)
                            }

                            scrollTo(t, e = !0) {
                                this.targetPos = t, o().isTouch && "transform" !== this.options.touchScrollType && ("scrollTop" === this.options.touchScrollType ? this.horizontalScroll ? this.containerElement.scrollTo(-this.targetPos, 0) : this.containerElement.scrollTo(0, -this.targetPos) : window.scrollTo(0, -this.targetPos)), this.clamp(), this.syncScroll = !0, e && T.emit(A.EXTERNALSCROLL, -this.targetPos)
                            }

                            toggleIframes(t) {
                                for (let e = 0; e < this.iframes.length; e++) this.iframes[e].style.pointerEvents = t ? "auto" : "none"
                            }

                            blockScrollEvent(t) {
                                t.stopPropagation()
                            }

                            addEvents() {
                                T.on(A.MOUSEDETECTED, (() => {
                                    "transform" !== this.options.touchScrollType && (this.options.customScrollbar = this.originalScrollbarSetting, this.ease = this.options.ease, this.setupSmoothScroll(), this.onResize())
                                })), o().isTouch || (T.on("mouseleave", document, (() => {
                                    window.scrollTo(0, -this.targetPos)
                                })), T.on("keydown", window, (t => {
                                    "ArrowUp" !== t.key && "ArrowDown" !== t.key && "PageUp" !== t.key && "PageDown" !== t.key && "Home" !== t.key && "End" !== t.key && "Tab" !== t.key || window.scrollTo(0, -this.targetPos), "Tab" === t.key && this.toggleFixedContainer()
                                })), T.delegate("click", 'a[href^="#"]', this.toggleFixedContainer), T.delegate("wheel", this.options.blockScrollClass, this.blockScrollEvent))
                            }

                            addTouchStyles() {
                                const t = ".asscroll-touch [asscroll-container] {position:absolute;top:0;left:0;right:0;bottom:-0.1px;overflow-y: auto;} .asscroll-touch [asscroll] {margin-bottom:0.1px;}",
                                    e = document.createElement("style");
                                e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t)), document.getElementsByTagName("head")[0].appendChild(e)
                            }
                        }

                        function I(t, e, n) {
                            return e in t ? Object.defineProperty(t, e, {
                                value: n,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : t[e] = n, t
                        }

                        const O = class {
                            constructor(t = {}) {
                                I(this, "update", (() => {
                                    this.events.onRaf()
                                })), I(this, "resize", (t => {
                                    this.events.onResize(t)
                                }));
                                const {
                                    containerElement: e = "[asscroll-container]",
                                    scrollElements: n = "[asscroll]",
                                    ease: i = .075,
                                    touchEase: r = 1,
                                    touchScrollType: o = "none",
                                    scrollbarEl: s = ".asscrollbar",
                                    scrollbarHandleEl: a = ".asscrollbar__handle",
                                    customScrollbar: l = !0,
                                    scrollbarStyles: c = !0,
                                    disableNativeScrollbar: u = !0,
                                    disableRaf: h = !1,
                                    disableResize: d = !1,
                                    limitLerpRate: p = !0,
                                    blockScrollClass: f = ".asscroll-block"
                                } = t;
                                this.events = new A({
                                    disableRaf: h,
                                    disableResize: d
                                }), this.controller = new R({
                                    containerElement: e,
                                    scrollElements: n,
                                    ease: i,
                                    touchEase: r,
                                    customScrollbar: l,
                                    scrollbarEl: s,
                                    scrollbarHandleEl: a,
                                    scrollbarStyles: c,
                                    disableNativeScrollbar: u,
                                    touchScrollType: o,
                                    limitLerpRate: p,
                                    blockScrollClass: f
                                })
                            }

                            enable(t) {
                                void 0 !== t && "object" != typeof t && console.warn("ASScroll: Please pass an object with your parameters. Since 2.0"), this.controller.enable(t)
                            }

                            disable(t) {
                                void 0 !== t && "object" != typeof t && console.warn("ASScroll: Please pass an object with your parameters. Since 2.0"), this.controller.disable(t)
                            }

                            on(t, e) {
                                "function" == typeof e ? "scroll" !== t ? "update" !== t ? "scrollEnd" !== t ? console.warn('ASScroll: "'.concat(t, '" is not a valid event')) : T.on(A.SCROLLEND, e) : T.on(A.EXTERNALRAF, e) : T.on(A.EXTERNALSCROLL, e) : console.error("ASScroll: Function not provided as second parameter")
                            }

                            off(t, e) {
                                "function" == typeof e ? "scroll" !== t ? "update" !== t ? "scrollEnd" !== t ? console.warn('ASScroll: "'.concat(t, '" is not a valid event')) : T.off(A.SCROLLEND, e) : T.off(A.EXTERNALRAF, e) : T.off(A.EXTERNALSCROLL, e) : console.error("ASScroll: Function not provided as second parameter")
                            }

                            scrollTo(t, e = !0) {
                                this.controller.scrollTo(-t, e)
                            }

                            get targetPos() {
                                return -this.controller.targetPos
                            }

                            get currentPos() {
                                return -this.controller.currentPos
                            }

                            set currentPos(t) {
                                this.controller.targetPos = this.controller.currentPos = -t
                            }

                            get maxScroll() {
                                return -this.controller.maxScroll
                            }

                            get containerElement() {
                                return this.controller.containerElement
                            }

                            get scrollElements() {
                                return this.controller.scrollElements
                            }

                            get isHorizontal() {
                                return this.controller.horizontalScroll
                            }

                            get isScrollJacking() {
                                return !this.controller.nativeScroll && this.controller.enabled
                            }

                            get scrollPos() {
                            }

                            get smoothScrollPos() {
                            }

                            onRaf() {
                            }

                            onResize() {
                            }
                        }
                    })(), i = i.default
                })()
            }, t.exports = e()
        }, 590: t => {
            "use strict";
            var e, n = "object" == typeof Reflect ? Reflect : null,
                i = n && "function" == typeof n.apply ? n.apply : function (t, e, n) {
                    return Function.prototype.apply.call(t, e, n)
                };
            e = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function (t) {
                return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))
            } : function (t) {
                return Object.getOwnPropertyNames(t)
            };
            var r = Number.isNaN || function (t) {
                return t != t
            };

            function o() {
                o.init.call(this)
            }

            t.exports = o, t.exports.once = function (t, e) {
                return new Promise((function (n, i) {
                    function r(n) {
                        t.removeListener(e, o), i(n)
                    }

                    function o() {
                        "function" == typeof t.removeListener && t.removeListener("error", r), n([].slice.call(arguments))
                    }

                    m(t, e, o, {once: !0}), "error" !== e && function (t, e, n) {
                        "function" == typeof t.on && m(t, "error", e, n)
                    }(t, r, {once: !0})
                }))
            }, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
            var s = 10;

            function a(t) {
                if ("function" != typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t)
            }

            function l(t) {
                return void 0 === t._maxListeners ? o.defaultMaxListeners : t._maxListeners
            }

            function c(t, e, n, i) {
                var r, o, s, c;
                if (a(n), void 0 === (o = t._events) ? (o = t._events = Object.create(null), t._eventsCount = 0) : (void 0 !== o.newListener && (t.emit("newListener", e, n.listener ? n.listener : n), o = t._events), s = o[e]), void 0 === s) s = o[e] = n, ++t._eventsCount; else if ("function" == typeof s ? s = o[e] = i ? [n, s] : [s, n] : i ? s.unshift(n) : s.push(n), (r = l(t)) > 0 && s.length > r && !s.warned) {
                    s.warned = !0;
                    var u = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    u.name = "MaxListenersExceededWarning", u.emitter = t, u.type = e, u.count = s.length, c = u, console && console.warn && console.warn(c)
                }
                return t
            }

            function u() {
                if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
            }

            function h(t, e, n) {
                var i = {fired: !1, wrapFn: void 0, target: t, type: e, listener: n}, r = u.bind(i);
                return r.listener = n, i.wrapFn = r, r
            }

            function d(t, e, n) {
                var i = t._events;
                if (void 0 === i) return [];
                var r = i[e];
                return void 0 === r ? [] : "function" == typeof r ? n ? [r.listener || r] : [r] : n ? function (t) {
                    for (var e = new Array(t.length), n = 0; n < e.length; ++n) e[n] = t[n].listener || t[n];
                    return e
                }(r) : f(r, r.length)
            }

            function p(t) {
                var e = this._events;
                if (void 0 !== e) {
                    var n = e[t];
                    if ("function" == typeof n) return 1;
                    if (void 0 !== n) return n.length
                }
                return 0
            }

            function f(t, e) {
                for (var n = new Array(e), i = 0; i < e; ++i) n[i] = t[i];
                return n
            }

            function m(t, e, n, i) {
                if ("function" == typeof t.on) i.once ? t.once(e, n) : t.on(e, n); else {
                    if ("function" != typeof t.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
                    t.addEventListener(e, (function r(o) {
                        i.once && t.removeEventListener(e, r), n(o)
                    }))
                }
            }

            Object.defineProperty(o, "defaultMaxListeners", {
                enumerable: !0, get: function () {
                    return s
                }, set: function (t) {
                    if ("number" != typeof t || t < 0 || r(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
                    s = t
                }
            }), o.init = function () {
                void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
            }, o.prototype.setMaxListeners = function (t) {
                if ("number" != typeof t || t < 0 || r(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
                return this._maxListeners = t, this
            }, o.prototype.getMaxListeners = function () {
                return l(this)
            }, o.prototype.emit = function (t) {
                for (var e = [], n = 1; n < arguments.length; n++) e.push(arguments[n]);
                var r = "error" === t, o = this._events;
                if (void 0 !== o) r = r && void 0 === o.error; else if (!r) return !1;
                if (r) {
                    var s;
                    if (e.length > 0 && (s = e[0]), s instanceof Error) throw s;
                    var a = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
                    throw a.context = s, a
                }
                var l = o[t];
                if (void 0 === l) return !1;
                if ("function" == typeof l) i(l, this, e); else {
                    var c = l.length, u = f(l, c);
                    for (n = 0; n < c; ++n) i(u[n], this, e)
                }
                return !0
            }, o.prototype.addListener = function (t, e) {
                return c(this, t, e, !1)
            }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function (t, e) {
                return c(this, t, e, !0)
            }, o.prototype.once = function (t, e) {
                return a(e), this.on(t, h(this, t, e)), this
            }, o.prototype.prependOnceListener = function (t, e) {
                return a(e), this.prependListener(t, h(this, t, e)), this
            }, o.prototype.removeListener = function (t, e) {
                var n, i, r, o, s;
                if (a(e), void 0 === (i = this._events)) return this;
                if (void 0 === (n = i[t])) return this;
                if (n === e || n.listener === e) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, n.listener || e)); else if ("function" != typeof n) {
                    for (r = -1, o = n.length - 1; o >= 0; o--) if (n[o] === e || n[o].listener === e) {
                        s = n[o].listener, r = o;
                        break
                    }
                    if (r < 0) return this;
                    0 === r ? n.shift() : function (t, e) {
                        for (; e + 1 < t.length; e++) t[e] = t[e + 1];
                        t.pop()
                    }(n, r), 1 === n.length && (i[t] = n[0]), void 0 !== i.removeListener && this.emit("removeListener", t, s || e)
                }
                return this
            }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function (t) {
                var e, n, i;
                if (void 0 === (n = this._events)) return this;
                if (void 0 === n.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[t] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[t]), this;
                if (0 === arguments.length) {
                    var r, o = Object.keys(n);
                    for (i = 0; i < o.length; ++i) "removeListener" !== (r = o[i]) && this.removeAllListeners(r);
                    return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
                }
                if ("function" == typeof (e = n[t])) this.removeListener(t, e); else if (void 0 !== e) for (i = e.length - 1; i >= 0; i--) this.removeListener(t, e[i]);
                return this
            }, o.prototype.listeners = function (t) {
                return d(this, t, !0)
            }, o.prototype.rawListeners = function (t) {
                return d(this, t, !1)
            }, o.listenerCount = function (t, e) {
                return "function" == typeof t.listenerCount ? t.listenerCount(e) : p.call(t, e)
            }, o.prototype.listenerCount = p, o.prototype.eventNames = function () {
                return this._eventsCount > 0 ? e(this._events) : []
            }
        }, 292: t => {
            t.exports = function () {
                var t = {};
                Object.defineProperty(t, "__esModule", {value: !0}), t.default = void 0, t.default = function (t) {
                    return !(!t || !t.Window) && t instanceof t.Window
                };
                var e = {};
                Object.defineProperty(e, "__esModule", {value: !0}), e.init = r, e.getWindow = function (e) {
                    return (0, t.default)(e) ? e : (e.ownerDocument || e).defaultView || i.window
                }, e.window = e.realWindow = void 0;
                var n = void 0;
                e.realWindow = n;
                var i = void 0;

                function r(t) {
                    e.realWindow = n = t;
                    var r = t.document.createTextNode("");
                    r.ownerDocument !== t.document && "function" == typeof t.wrap && t.wrap(r) === r && (t = t.wrap(t)), e.window = i = t
                }

                e.window = i, "undefined" != typeof window && window && r(window);
                var o = {};

                function s(t) {
                    return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                        return typeof t
                    } : function (t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    })(t)
                }

                Object.defineProperty(o, "__esModule", {value: !0}), o.default = void 0;
                var a = function (t) {
                    return !!t && "object" === s(t)
                }, l = function (t) {
                    return "function" == typeof t
                }, c = {
                    window: function (n) {
                        return n === e.window || (0, t.default)(n)
                    }, docFrag: function (t) {
                        return a(t) && 11 === t.nodeType
                    }, object: a, func: l, number: function (t) {
                        return "number" == typeof t
                    }, bool: function (t) {
                        return "boolean" == typeof t
                    }, string: function (t) {
                        return "string" == typeof t
                    }, element: function (t) {
                        if (!t || "object" !== s(t)) return !1;
                        var n = e.getWindow(t) || e.window;
                        return /object|function/.test(s(n.Element)) ? t instanceof n.Element : 1 === t.nodeType && "string" == typeof t.nodeName
                    }, plainObject: function (t) {
                        return a(t) && !!t.constructor && /function Object\b/.test(t.constructor.toString())
                    }, array: function (t) {
                        return a(t) && void 0 !== t.length && l(t.splice)
                    }
                };
                o.default = c;
                var u = {};

                function h(t) {
                    var e = t.interaction;
                    if ("drag" === e.prepared.name) {
                        var n = e.prepared.axis;
                        "x" === n ? (e.coords.cur.page.y = e.coords.start.page.y, e.coords.cur.client.y = e.coords.start.client.y, e.coords.velocity.client.y = 0, e.coords.velocity.page.y = 0) : "y" === n && (e.coords.cur.page.x = e.coords.start.page.x, e.coords.cur.client.x = e.coords.start.client.x, e.coords.velocity.client.x = 0, e.coords.velocity.page.x = 0)
                    }
                }

                function d(t) {
                    var e = t.iEvent, n = t.interaction;
                    if ("drag" === n.prepared.name) {
                        var i = n.prepared.axis;
                        if ("x" === i || "y" === i) {
                            var r = "x" === i ? "y" : "x";
                            e.page[r] = n.coords.start.page[r], e.client[r] = n.coords.start.client[r], e.delta[r] = 0
                        }
                    }
                }

                Object.defineProperty(u, "__esModule", {value: !0}), u.default = void 0;
                var p = {
                    id: "actions/drag",
                    install: function (t) {
                        var e = t.actions, n = t.Interactable, i = t.defaults;
                        n.prototype.draggable = p.draggable, e.map.drag = p, e.methodDict.drag = "draggable", i.actions.drag = p.defaults
                    },
                    listeners: {
                        "interactions:before-action-move": h,
                        "interactions:action-resume": h,
                        "interactions:action-move": d,
                        "auto-start:check": function (t) {
                            var e = t.interaction, n = t.interactable, i = t.buttons, r = n.options.drag;
                            if (r && r.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || 0 != (i & n.options.drag.mouseButtons))) return t.action = {
                                name: "drag",
                                axis: "start" === r.lockAxis ? r.startAxis : r.lockAxis
                            }, !1
                        }
                    },
                    draggable: function (t) {
                        return o.default.object(t) ? (this.options.drag.enabled = !1 !== t.enabled, this.setPerAction("drag", t), this.setOnEvents("drag", t), /^(xy|x|y|start)$/.test(t.lockAxis) && (this.options.drag.lockAxis = t.lockAxis), /^(xy|x|y)$/.test(t.startAxis) && (this.options.drag.startAxis = t.startAxis), this) : o.default.bool(t) ? (this.options.drag.enabled = t, this) : this.options.drag
                    },
                    beforeMove: h,
                    move: d,
                    defaults: {startAxis: "xy", lockAxis: "xy"},
                    getCursor: function () {
                        return "move"
                    }
                }, f = p;
                u.default = f;
                var m = {};
                Object.defineProperty(m, "__esModule", {value: !0}), m.default = void 0;
                var g = {
                    init: function (t) {
                        var e = t;
                        g.document = e.document, g.DocumentFragment = e.DocumentFragment || v, g.SVGElement = e.SVGElement || v, g.SVGSVGElement = e.SVGSVGElement || v, g.SVGElementInstance = e.SVGElementInstance || v, g.Element = e.Element || v, g.HTMLElement = e.HTMLElement || g.Element, g.Event = e.Event, g.Touch = e.Touch || v, g.PointerEvent = e.PointerEvent || e.MSPointerEvent
                    },
                    document: null,
                    DocumentFragment: null,
                    SVGElement: null,
                    SVGSVGElement: null,
                    SVGElementInstance: null,
                    Element: null,
                    HTMLElement: null,
                    Event: null,
                    Touch: null,
                    PointerEvent: null
                };

                function v() {
                }

                var y = g;
                m.default = y;
                var x = {};
                Object.defineProperty(x, "__esModule", {value: !0}), x.default = void 0;
                var _ = {
                    init: function (t) {
                        var e = m.default.Element, n = t.navigator || {};
                        _.supportsTouch = "ontouchstart" in t || o.default.func(t.DocumentTouch) && m.default.document instanceof t.DocumentTouch, _.supportsPointerEvent = !1 !== n.pointerEnabled && !!m.default.PointerEvent, _.isIOS = /iP(hone|od|ad)/.test(n.platform), _.isIOS7 = /iP(hone|od|ad)/.test(n.platform) && /OS 7[^\d]/.test(n.appVersion), _.isIe9 = /MSIE 9/.test(n.userAgent), _.isOperaMobile = "Opera" === n.appName && _.supportsTouch && /Presto/.test(n.userAgent), _.prefixedMatchesSelector = "matches" in e.prototype ? "matches" : "webkitMatchesSelector" in e.prototype ? "webkitMatchesSelector" : "mozMatchesSelector" in e.prototype ? "mozMatchesSelector" : "oMatchesSelector" in e.prototype ? "oMatchesSelector" : "msMatchesSelector", _.pEventTypes = _.supportsPointerEvent ? m.default.PointerEvent === t.MSPointerEvent ? {
                            up: "MSPointerUp",
                            down: "MSPointerDown",
                            over: "mouseover",
                            out: "mouseout",
                            move: "MSPointerMove",
                            cancel: "MSPointerCancel"
                        } : {
                            up: "pointerup",
                            down: "pointerdown",
                            over: "pointerover",
                            out: "pointerout",
                            move: "pointermove",
                            cancel: "pointercancel"
                        } : null, _.wheelEvent = m.default.document && "onmousewheel" in m.default.document ? "mousewheel" : "wheel"
                    },
                    supportsTouch: null,
                    supportsPointerEvent: null,
                    isIOS7: null,
                    isIOS: null,
                    isIe9: null,
                    isOperaMobile: null,
                    prefixedMatchesSelector: null,
                    pEventTypes: null,
                    wheelEvent: null
                }, b = _;
                x.default = b;
                var w = {};

                function S(t) {
                    var e = t.parentNode;
                    if (o.default.docFrag(e)) {
                        for (; (e = e.host) && o.default.docFrag(e);) ;
                        return e
                    }
                    return e
                }

                function M(t, n) {
                    return e.window !== e.realWindow && (n = n.replace(/\/deep\//g, " ")), t[x.default.prefixedMatchesSelector](n)
                }

                Object.defineProperty(w, "__esModule", {value: !0}), w.nodeContains = function (t, e) {
                    if (t.contains) return t.contains(e);
                    for (; e;) {
                        if (e === t) return !0;
                        e = e.parentNode
                    }
                    return !1
                }, w.closest = function (t, e) {
                    for (; o.default.element(t);) {
                        if (M(t, e)) return t;
                        t = S(t)
                    }
                    return null
                }, w.parentNode = S, w.matchesSelector = M, w.indexOfDeepestElement = function (t) {
                    for (var n, i = [], r = 0; r < t.length; r++) {
                        var o = t[r], s = t[n];
                        if (o && r !== n) if (s) {
                            var a = T(o), l = T(s);
                            if (a !== o.ownerDocument) if (l !== o.ownerDocument) if (a !== l) {
                                i = i.length ? i : E(s);
                                var c = void 0;
                                if (s instanceof m.default.HTMLElement && o instanceof m.default.SVGElement && !(o instanceof m.default.SVGSVGElement)) {
                                    if (o === l) continue;
                                    c = o.ownerSVGElement
                                } else c = o;
                                for (var u = E(c, s.ownerDocument), h = 0; u[h] && u[h] === i[h];) h++;
                                var d = [u[h - 1], u[h], i[h]];
                                if (d[0]) for (var p = d[0].lastChild; p;) {
                                    if (p === d[1]) {
                                        n = r, i = u;
                                        break
                                    }
                                    if (p === d[2]) break;
                                    p = p.previousSibling
                                }
                            } else f = o, g = s, (parseInt(e.getWindow(f).getComputedStyle(f).zIndex, 10) || 0) >= (parseInt(e.getWindow(g).getComputedStyle(g).zIndex, 10) || 0) && (n = r); else n = r
                        } else n = r
                    }
                    var f, g;
                    return n
                }, w.matchesUpTo = function (t, e, n) {
                    for (; o.default.element(t);) {
                        if (M(t, e)) return !0;
                        if ((t = S(t)) === n) return M(t, e)
                    }
                    return !1
                }, w.getActualElement = function (t) {
                    return t.correspondingUseElement || t
                }, w.getScrollXY = A, w.getElementClientRect = P, w.getElementRect = function (t) {
                    var n = P(t);
                    if (!x.default.isIOS7 && n) {
                        var i = A(e.getWindow(t));
                        n.left += i.x, n.right += i.x, n.top += i.y, n.bottom += i.y
                    }
                    return n
                }, w.getPath = function (t) {
                    for (var e = []; t;) e.push(t), t = S(t);
                    return e
                }, w.trySelector = function (t) {
                    return !!o.default.string(t) && (m.default.document.querySelector(t), !0)
                };
                var T = function (t) {
                    return t.parentNode || t.host
                };

                function E(t, e) {
                    for (var n, i = [], r = t; (n = T(r)) && r !== e && n !== r.ownerDocument;) i.unshift(r), r = n;
                    return i
                }

                function A(t) {
                    return {
                        x: (t = t || e.window).scrollX || t.document.documentElement.scrollLeft,
                        y: t.scrollY || t.document.documentElement.scrollTop
                    }
                }

                function P(t) {
                    var e = t instanceof m.default.SVGElement ? t.getBoundingClientRect() : t.getClientRects()[0];
                    return e && {
                        left: e.left,
                        right: e.right,
                        top: e.top,
                        bottom: e.bottom,
                        width: e.width || e.right - e.left,
                        height: e.height || e.bottom - e.top
                    }
                }

                var L = {};
                Object.defineProperty(L, "__esModule", {value: !0}), L.default = function (t, e) {
                    for (var n in e) t[n] = e[n];
                    return t
                };
                var C = {};

                function R(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var n = 0, i = Array(e); n < e; n++) i[n] = t[n];
                    return i
                }

                function I(t, e, n) {
                    return "parent" === t ? (0, w.parentNode)(n) : "self" === t ? e.getRect(n) : (0, w.closest)(n, t)
                }

                Object.defineProperty(C, "__esModule", {value: !0}), C.getStringOptionResult = I, C.resolveRectLike = function (t, e, n, i) {
                    var r, s = t;
                    return o.default.string(s) ? s = I(s, e, n) : o.default.func(s) && (s = s.apply(void 0, function (t) {
                        if (Array.isArray(t)) return R(t)
                    }(r = i) || function (t) {
                        if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
                    }(r) || function (t, e) {
                        if (t) {
                            if ("string" == typeof t) return R(t, e);
                            var n = Object.prototype.toString.call(t).slice(8, -1);
                            return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? R(t, e) : void 0
                        }
                    }(r) || function () {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }())), o.default.element(s) && (s = (0, w.getElementRect)(s)), s
                }, C.rectToXY = function (t) {
                    return t && {x: "x" in t ? t.x : t.left, y: "y" in t ? t.y : t.top}
                }, C.xywhToTlbr = function (t) {
                    return !t || "left" in t && "top" in t || ((t = (0, L.default)({}, t)).left = t.x || 0, t.top = t.y || 0, t.right = t.right || t.left + t.width, t.bottom = t.bottom || t.top + t.height), t
                }, C.tlbrToXywh = function (t) {
                    return !t || "x" in t && "y" in t || ((t = (0, L.default)({}, t)).x = t.left || 0, t.y = t.top || 0, t.width = t.width || (t.right || 0) - t.x, t.height = t.height || (t.bottom || 0) - t.y), t
                }, C.addEdges = function (t, e, n) {
                    t.left && (e.left += n.x), t.right && (e.right += n.x), t.top && (e.top += n.y), t.bottom && (e.bottom += n.y), e.width = e.right - e.left, e.height = e.bottom - e.top
                };
                var O = {};
                Object.defineProperty(O, "__esModule", {value: !0}), O.default = function (t, e, n) {
                    var i = t.options[n], r = i && i.origin || t.options.origin,
                        o = (0, C.resolveRectLike)(r, t, e, [t && e]);
                    return (0, C.rectToXY)(o) || {x: 0, y: 0}
                };
                var D = {};

                function z(t) {
                    return t.trim().split(/ +/)
                }

                Object.defineProperty(D, "__esModule", {value: !0}), D.default = function t(e, n, i) {
                    if (i = i || {}, o.default.string(e) && -1 !== e.search(" ") && (e = z(e)), o.default.array(e)) return e.reduce((function (e, r) {
                        return (0, L.default)(e, t(r, n, i))
                    }), i);
                    if (o.default.object(e) && (n = e, e = ""), o.default.func(n)) i[e] = i[e] || [], i[e].push(n); else if (o.default.array(n)) for (var r = 0; r < n.length; r++) {
                        var s;
                        s = n[r], t(e, s, i)
                    } else if (o.default.object(n)) for (var a in n) {
                        var l = z(a).map((function (t) {
                            return "".concat(e).concat(t)
                        }));
                        t(l, n[a], i)
                    }
                    return i
                };
                var k = {};
                Object.defineProperty(k, "__esModule", {value: !0}), k.default = void 0, k.default = function (t, e) {
                    return Math.sqrt(t * t + e * e)
                };
                var N = {};

                function B(t, e) {
                    for (var n in e) {
                        var i = B.prefixedPropREs, r = !1;
                        for (var o in i) if (0 === n.indexOf(o) && i[o].test(n)) {
                            r = !0;
                            break
                        }
                        r || "function" == typeof e[n] || (t[n] = e[n])
                    }
                    return t
                }

                Object.defineProperty(N, "__esModule", {value: !0}), N.default = void 0, B.prefixedPropREs = {
                    webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,
                    moz: /(Pressure)$/
                };
                var F = B;
                N.default = F;
                var U = {};

                function H(t) {
                    return t instanceof m.default.Event || t instanceof m.default.Touch
                }

                function V(t, e, n) {
                    return t = t || "page", (n = n || {}).x = e[t + "X"], n.y = e[t + "Y"], n
                }

                function G(t, e) {
                    return e = e || {
                        x: 0,
                        y: 0
                    }, x.default.isOperaMobile && H(t) ? (V("screen", t, e), e.x += window.scrollX, e.y += window.scrollY) : V("page", t, e), e
                }

                function W(t, e) {
                    return e = e || {}, x.default.isOperaMobile && H(t) ? V("screen", t, e) : V("client", t, e), e
                }

                function j(t) {
                    var e = [];
                    return o.default.array(t) ? (e[0] = t[0], e[1] = t[1]) : "touchend" === t.type ? 1 === t.touches.length ? (e[0] = t.touches[0], e[1] = t.changedTouches[0]) : 0 === t.touches.length && (e[0] = t.changedTouches[0], e[1] = t.changedTouches[1]) : (e[0] = t.touches[0], e[1] = t.touches[1]), e
                }

                function q(t) {
                    for (var e = {
                        pageX: 0,
                        pageY: 0,
                        clientX: 0,
                        clientY: 0,
                        screenX: 0,
                        screenY: 0
                    }, n = 0; n < t.length; n++) {
                        var i = t[n];
                        for (var r in e) e[r] += i[r]
                    }
                    for (var o in e) e[o] /= t.length;
                    return e
                }

                Object.defineProperty(U, "__esModule", {value: !0}), U.copyCoords = function (t, e) {
                    t.page = t.page || {}, t.page.x = e.page.x, t.page.y = e.page.y, t.client = t.client || {}, t.client.x = e.client.x, t.client.y = e.client.y, t.timeStamp = e.timeStamp
                }, U.setCoordDeltas = function (t, e, n) {
                    t.page.x = n.page.x - e.page.x, t.page.y = n.page.y - e.page.y, t.client.x = n.client.x - e.client.x, t.client.y = n.client.y - e.client.y, t.timeStamp = n.timeStamp - e.timeStamp
                }, U.setCoordVelocity = function (t, e) {
                    var n = Math.max(e.timeStamp / 1e3, .001);
                    t.page.x = e.page.x / n, t.page.y = e.page.y / n, t.client.x = e.client.x / n, t.client.y = e.client.y / n, t.timeStamp = n
                }, U.setZeroCoords = function (t) {
                    t.page.x = 0, t.page.y = 0, t.client.x = 0, t.client.y = 0
                }, U.isNativePointer = H, U.getXY = V, U.getPageXY = G, U.getClientXY = W, U.getPointerId = function (t) {
                    return o.default.number(t.pointerId) ? t.pointerId : t.identifier
                }, U.setCoords = function (t, e, n) {
                    var i = e.length > 1 ? q(e) : e[0];
                    G(i, t.page), W(i, t.client), t.timeStamp = n
                }, U.getTouchPair = j, U.pointerAverage = q, U.touchBBox = function (t) {
                    if (!t.length) return null;
                    var e = j(t), n = Math.min(e[0].pageX, e[1].pageX), i = Math.min(e[0].pageY, e[1].pageY),
                        r = Math.max(e[0].pageX, e[1].pageX), o = Math.max(e[0].pageY, e[1].pageY);
                    return {x: n, y: i, left: n, top: i, right: r, bottom: o, width: r - n, height: o - i}
                }, U.touchDistance = function (t, e) {
                    var n = e + "X", i = e + "Y", r = j(t), o = r[0][n] - r[1][n], s = r[0][i] - r[1][i];
                    return (0, k.default)(o, s)
                }, U.touchAngle = function (t, e) {
                    var n = e + "X", i = e + "Y", r = j(t), o = r[1][n] - r[0][n], s = r[1][i] - r[0][i];
                    return 180 * Math.atan2(s, o) / Math.PI
                }, U.getPointerType = function (t) {
                    return o.default.string(t.pointerType) ? t.pointerType : o.default.number(t.pointerType) ? [void 0, void 0, "touch", "pen", "mouse"][t.pointerType] : /touch/.test(t.type || "") || t instanceof m.default.Touch ? "touch" : "mouse"
                }, U.getEventTargets = function (t) {
                    var e = o.default.func(t.composedPath) ? t.composedPath() : t.path;
                    return [w.getActualElement(e ? e[0] : t.target), w.getActualElement(t.currentTarget)]
                }, U.newCoords = function () {
                    return {page: {x: 0, y: 0}, client: {x: 0, y: 0}, timeStamp: 0}
                }, U.coordsToEvent = function (t) {
                    return {
                        coords: t, get page() {
                            return this.coords.page
                        }, get client() {
                            return this.coords.client
                        }, get timeStamp() {
                            return this.coords.timeStamp
                        }, get pageX() {
                            return this.coords.page.x
                        }, get pageY() {
                            return this.coords.page.y
                        }, get clientX() {
                            return this.coords.client.x
                        }, get clientY() {
                            return this.coords.client.y
                        }, get pointerId() {
                            return this.coords.pointerId
                        }, get target() {
                            return this.coords.target
                        }, get type() {
                            return this.coords.type
                        }, get pointerType() {
                            return this.coords.pointerType
                        }, get buttons() {
                            return this.coords.buttons
                        }, preventDefault: function () {
                        }
                    }
                }, Object.defineProperty(U, "pointerExtend", {
                    enumerable: !0, get: function () {
                        return N.default
                    }
                });
                var X = {};

                function Y(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                }

                function J(t, e, n) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }

                Object.defineProperty(X, "__esModule", {value: !0}), X.BaseEvent = void 0;
                var Z = function () {
                    function t(e) {
                        !function (t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), J(this, "type", void 0), J(this, "target", void 0), J(this, "currentTarget", void 0), J(this, "interactable", void 0), J(this, "_interaction", void 0), J(this, "timeStamp", void 0), J(this, "immediatePropagationStopped", !1), J(this, "propagationStopped", !1), this._interaction = e
                    }

                    var e;
                    return (e = [{
                        key: "preventDefault", value: function () {
                        }
                    }, {
                        key: "stopPropagation", value: function () {
                            this.propagationStopped = !0
                        }
                    }, {
                        key: "stopImmediatePropagation", value: function () {
                            this.immediatePropagationStopped = this.propagationStopped = !0
                        }
                    }]) && Y(t.prototype, e), t
                }();
                X.BaseEvent = Z, Object.defineProperty(Z.prototype, "interaction", {
                    get: function () {
                        return this._interaction._proxy
                    }, set: function () {
                    }
                });
                var Q = {};
                Object.defineProperty(Q, "__esModule", {value: !0}), Q.find = Q.findIndex = Q.from = Q.merge = Q.remove = Q.contains = void 0, Q.contains = function (t, e) {
                    return -1 !== t.indexOf(e)
                }, Q.remove = function (t, e) {
                    return t.splice(t.indexOf(e), 1)
                };
                var K = function (t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        t.push(i)
                    }
                    return t
                };
                Q.merge = K, Q.from = function (t) {
                    return K([], t)
                };
                var $ = function (t, e) {
                    for (var n = 0; n < t.length; n++) if (e(t[n], n, t)) return n;
                    return -1
                };
                Q.findIndex = $, Q.find = function (t, e) {
                    return t[$(t, e)]
                };
                var tt = {};

                function et(t) {
                    return (et = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                        return typeof t
                    } : function (t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    })(t)
                }

                function nt(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                }

                function it(t, e) {
                    return (it = Object.setPrototypeOf || function (t, e) {
                        return t.__proto__ = e, t
                    })(t, e)
                }

                function rt(t, e) {
                    return !e || "object" !== et(e) && "function" != typeof e ? ot(t) : e
                }

                function ot(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function st(t) {
                    return (st = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    })(t)
                }

                function at(t, e, n) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }

                Object.defineProperty(tt, "__esModule", {value: !0}), tt.DropEvent = void 0;
                var lt = function (t) {
                    !function (t, e) {
                        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                        t.prototype = Object.create(e && e.prototype, {
                            constructor: {
                                value: t,
                                writable: !0,
                                configurable: !0
                            }
                        }), e && it(t, e)
                    }(o, t);
                    var e, n, i, r = (n = o, i = function () {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
                            }))), !0
                        } catch (t) {
                            return !1
                        }
                    }(), function () {
                        var t, e = st(n);
                        if (i) {
                            var r = st(this).constructor;
                            t = Reflect.construct(e, arguments, r)
                        } else t = e.apply(this, arguments);
                        return rt(this, t)
                    });

                    function o(t, e, n) {
                        var i;
                        !function (t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, o), at(ot(i = r.call(this, e._interaction)), "target", void 0), at(ot(i), "dropzone", void 0), at(ot(i), "dragEvent", void 0), at(ot(i), "relatedTarget", void 0), at(ot(i), "draggable", void 0), at(ot(i), "timeStamp", void 0), at(ot(i), "propagationStopped", !1), at(ot(i), "immediatePropagationStopped", !1);
                        var s = "dragleave" === n ? t.prev : t.cur, a = s.element, l = s.dropzone;
                        return i.type = n, i.target = a, i.currentTarget = a, i.dropzone = l, i.dragEvent = e, i.relatedTarget = e.target, i.draggable = e.interactable, i.timeStamp = e.timeStamp, i
                    }

                    return (e = [{
                        key: "reject", value: function () {
                            var t = this, e = this._interaction.dropState;
                            if ("dropactivate" === this.type || this.dropzone && e.cur.dropzone === this.dropzone && e.cur.element === this.target) if (e.prev.dropzone = this.dropzone, e.prev.element = this.target, e.rejected = !0, e.events.enter = null, this.stopImmediatePropagation(), "dropactivate" === this.type) {
                                var n = e.activeDrops, i = Q.findIndex(n, (function (e) {
                                    var n = e.dropzone, i = e.element;
                                    return n === t.dropzone && i === t.target
                                }));
                                e.activeDrops.splice(i, 1);
                                var r = new o(e, this.dragEvent, "dropdeactivate");
                                r.dropzone = this.dropzone, r.target = this.target, this.dropzone.fire(r)
                            } else this.dropzone.fire(new o(e, this.dragEvent, "dragleave"))
                        }
                    }, {
                        key: "preventDefault", value: function () {
                        }
                    }, {
                        key: "stopPropagation", value: function () {
                            this.propagationStopped = !0
                        }
                    }, {
                        key: "stopImmediatePropagation", value: function () {
                            this.immediatePropagationStopped = this.propagationStopped = !0
                        }
                    }]) && nt(o.prototype, e), o
                }(X.BaseEvent);
                tt.DropEvent = lt;
                var ct = {};

                function ut(t, e) {
                    for (var n = 0; n < t.slice().length; n++) {
                        var i = t.slice()[n], r = i.dropzone, o = i.element;
                        e.dropzone = r, e.target = o, r.fire(e), e.propagationStopped = e.immediatePropagationStopped = !1
                    }
                }

                function ht(t, e) {
                    for (var n = function (t, e) {
                        for (var n = t.interactables, i = [], r = 0; r < n.list.length; r++) {
                            var s = n.list[r];
                            if (s.options.drop.enabled) {
                                var a = s.options.drop.accept;
                                if (!(o.default.element(a) && a !== e || o.default.string(a) && !w.matchesSelector(e, a) || o.default.func(a) && !a({
                                    dropzone: s,
                                    draggableElement: e
                                }))) for (var l = o.default.string(s.target) ? s._context.querySelectorAll(s.target) : o.default.array(s.target) ? s.target : [s.target], c = 0; c < l.length; c++) {
                                    var u = l[c];
                                    u !== e && i.push({dropzone: s, element: u, rect: s.getRect(u)})
                                }
                            }
                        }
                        return i
                    }(t, e), i = 0; i < n.length; i++) {
                        var r = n[i];
                        r.rect = r.dropzone.getRect(r.element)
                    }
                    return n
                }

                function dt(t, e, n) {
                    for (var i = t.dropState, r = t.interactable, o = t.element, s = [], a = 0; a < i.activeDrops.length; a++) {
                        var l = i.activeDrops[a], c = l.dropzone, u = l.element, h = l.rect;
                        s.push(c.dropCheck(e, n, r, o, u, h) ? u : null)
                    }
                    var d = w.indexOfDeepestElement(s);
                    return i.activeDrops[d] || null
                }

                function pt(t, e, n) {
                    var i = t.dropState,
                        r = {enter: null, leave: null, activate: null, deactivate: null, move: null, drop: null};
                    return "dragstart" === n.type && (r.activate = new tt.DropEvent(i, n, "dropactivate"), r.activate.target = null, r.activate.dropzone = null), "dragend" === n.type && (r.deactivate = new tt.DropEvent(i, n, "dropdeactivate"), r.deactivate.target = null, r.deactivate.dropzone = null), i.rejected || (i.cur.element !== i.prev.element && (i.prev.dropzone && (r.leave = new tt.DropEvent(i, n, "dragleave"), n.dragLeave = r.leave.target = i.prev.element, n.prevDropzone = r.leave.dropzone = i.prev.dropzone), i.cur.dropzone && (r.enter = new tt.DropEvent(i, n, "dragenter"), n.dragEnter = i.cur.element, n.dropzone = i.cur.dropzone)), "dragend" === n.type && i.cur.dropzone && (r.drop = new tt.DropEvent(i, n, "drop"), n.dropzone = i.cur.dropzone, n.relatedTarget = i.cur.element), "dragmove" === n.type && i.cur.dropzone && (r.move = new tt.DropEvent(i, n, "dropmove"), r.move.dragmove = n, n.dropzone = i.cur.dropzone)), r
                }

                function ft(t, e) {
                    var n = t.dropState, i = n.activeDrops, r = n.cur, o = n.prev;
                    e.leave && o.dropzone.fire(e.leave), e.enter && r.dropzone.fire(e.enter), e.move && r.dropzone.fire(e.move), e.drop && r.dropzone.fire(e.drop), e.deactivate && ut(i, e.deactivate), n.prev.dropzone = r.dropzone, n.prev.element = r.element
                }

                function mt(t, e) {
                    var n = t.interaction, i = t.iEvent, r = t.event;
                    if ("dragmove" === i.type || "dragend" === i.type) {
                        var o = n.dropState;
                        e.dynamicDrop && (o.activeDrops = ht(e, n.element));
                        var s = i, a = dt(n, s, r);
                        o.rejected = o.rejected && !!a && a.dropzone === o.cur.dropzone && a.element === o.cur.element, o.cur.dropzone = a && a.dropzone, o.cur.element = a && a.element, o.events = pt(n, 0, s)
                    }
                }

                Object.defineProperty(ct, "__esModule", {value: !0}), ct.default = void 0;
                var gt = {
                    id: "actions/drop",
                    install: function (t) {
                        var e = t.actions, n = t.interactStatic, i = t.Interactable, r = t.defaults;
                        t.usePlugin(u.default), i.prototype.dropzone = function (t) {
                            return function (t, e) {
                                if (o.default.object(e)) {
                                    if (t.options.drop.enabled = !1 !== e.enabled, e.listeners) {
                                        var n = (0, D.default)(e.listeners),
                                            i = Object.keys(n).reduce((function (t, e) {
                                                return t[/^(enter|leave)/.test(e) ? "drag".concat(e) : /^(activate|deactivate|move)/.test(e) ? "drop".concat(e) : e] = n[e], t
                                            }), {});
                                        t.off(t.options.drop.listeners), t.on(i), t.options.drop.listeners = i
                                    }
                                    return o.default.func(e.ondrop) && t.on("drop", e.ondrop), o.default.func(e.ondropactivate) && t.on("dropactivate", e.ondropactivate), o.default.func(e.ondropdeactivate) && t.on("dropdeactivate", e.ondropdeactivate), o.default.func(e.ondragenter) && t.on("dragenter", e.ondragenter), o.default.func(e.ondragleave) && t.on("dragleave", e.ondragleave), o.default.func(e.ondropmove) && t.on("dropmove", e.ondropmove), /^(pointer|center)$/.test(e.overlap) ? t.options.drop.overlap = e.overlap : o.default.number(e.overlap) && (t.options.drop.overlap = Math.max(Math.min(1, e.overlap), 0)), "accept" in e && (t.options.drop.accept = e.accept), "checker" in e && (t.options.drop.checker = e.checker), t
                                }
                                return o.default.bool(e) ? (t.options.drop.enabled = e, t) : t.options.drop
                            }(this, t)
                        }, i.prototype.dropCheck = function (t, e, n, i, r, s) {
                            return function (t, e, n, i, r, s, a) {
                                var l = !1;
                                if (!(a = a || t.getRect(s))) return !!t.options.drop.checker && t.options.drop.checker(e, n, l, t, s, i, r);
                                var c = t.options.drop.overlap;
                                if ("pointer" === c) {
                                    var u = (0, O.default)(i, r, "drag"), h = U.getPageXY(e);
                                    h.x += u.x, h.y += u.y;
                                    var d = h.x > a.left && h.x < a.right, p = h.y > a.top && h.y < a.bottom;
                                    l = d && p
                                }
                                var f = i.getRect(r);
                                if (f && "center" === c) {
                                    var m = f.left + f.width / 2, g = f.top + f.height / 2;
                                    l = m >= a.left && m <= a.right && g >= a.top && g <= a.bottom
                                }
                                return f && o.default.number(c) && (l = Math.max(0, Math.min(a.right, f.right) - Math.max(a.left, f.left)) * Math.max(0, Math.min(a.bottom, f.bottom) - Math.max(a.top, f.top)) / (f.width * f.height) >= c), t.options.drop.checker && (l = t.options.drop.checker(e, n, l, t, s, i, r)), l
                            }(this, t, e, n, i, r, s)
                        }, n.dynamicDrop = function (e) {
                            return o.default.bool(e) ? (t.dynamicDrop = e, n) : t.dynamicDrop
                        }, (0, L.default)(e.phaselessTypes, {
                            dragenter: !0,
                            dragleave: !0,
                            dropactivate: !0,
                            dropdeactivate: !0,
                            dropmove: !0,
                            drop: !0
                        }), e.methodDict.drop = "dropzone", t.dynamicDrop = !1, r.actions.drop = gt.defaults
                    },
                    listeners: {
                        "interactions:before-action-start": function (t) {
                            var e = t.interaction;
                            "drag" === e.prepared.name && (e.dropState = {
                                cur: {dropzone: null, element: null},
                                prev: {dropzone: null, element: null},
                                rejected: null,
                                events: null,
                                activeDrops: []
                            })
                        }, "interactions:after-action-start": function (t, e) {
                            var n = t.interaction, i = (t.event, t.iEvent);
                            if ("drag" === n.prepared.name) {
                                var r = n.dropState;
                                r.activeDrops = null, r.events = null, r.activeDrops = ht(e, n.element), r.events = pt(n, 0, i), r.events.activate && (ut(r.activeDrops, r.events.activate), e.fire("actions/drop:start", {
                                    interaction: n,
                                    dragEvent: i
                                }))
                            }
                        }, "interactions:action-move": mt, "interactions:after-action-move": function (t, e) {
                            var n = t.interaction, i = t.iEvent;
                            "drag" === n.prepared.name && (ft(n, n.dropState.events), e.fire("actions/drop:move", {
                                interaction: n,
                                dragEvent: i
                            }), n.dropState.events = {})
                        }, "interactions:action-end": function (t, e) {
                            if ("drag" === t.interaction.prepared.name) {
                                var n = t.interaction, i = t.iEvent;
                                mt(t, e), ft(n, n.dropState.events), e.fire("actions/drop:end", {
                                    interaction: n,
                                    dragEvent: i
                                })
                            }
                        }, "interactions:stop": function (t) {
                            var e = t.interaction;
                            if ("drag" === e.prepared.name) {
                                var n = e.dropState;
                                n && (n.activeDrops = null, n.events = null, n.cur.dropzone = null, n.cur.element = null, n.prev.dropzone = null, n.prev.element = null, n.rejected = !1)
                            }
                        }
                    },
                    getActiveDrops: ht,
                    getDrop: dt,
                    getDropEvents: pt,
                    fireDropEvents: ft,
                    defaults: {enabled: !1, accept: null, overlap: "pointer"}
                }, vt = gt;
                ct.default = vt;
                var yt = {};

                function xt(t) {
                    var e = t.interaction, n = t.iEvent, i = t.phase;
                    if ("gesture" === e.prepared.name) {
                        var r = e.pointers.map((function (t) {
                            return t.pointer
                        })), s = "start" === i, a = "end" === i, l = e.interactable.options.deltaSource;
                        if (n.touches = [r[0], r[1]], s) n.distance = U.touchDistance(r, l), n.box = U.touchBBox(r), n.scale = 1, n.ds = 0, n.angle = U.touchAngle(r, l), n.da = 0, e.gesture.startDistance = n.distance, e.gesture.startAngle = n.angle; else if (a) {
                            var c = e.prevEvent;
                            n.distance = c.distance, n.box = c.box, n.scale = c.scale, n.ds = 0, n.angle = c.angle, n.da = 0
                        } else n.distance = U.touchDistance(r, l), n.box = U.touchBBox(r), n.scale = n.distance / e.gesture.startDistance, n.angle = U.touchAngle(r, l), n.ds = n.scale - e.gesture.scale, n.da = n.angle - e.gesture.angle;
                        e.gesture.distance = n.distance, e.gesture.angle = n.angle, o.default.number(n.scale) && n.scale !== 1 / 0 && !isNaN(n.scale) && (e.gesture.scale = n.scale)
                    }
                }

                Object.defineProperty(yt, "__esModule", {value: !0}), yt.default = void 0;
                var _t = {
                    id: "actions/gesture",
                    before: ["actions/drag", "actions/resize"],
                    install: function (t) {
                        var e = t.actions, n = t.Interactable, i = t.defaults;
                        n.prototype.gesturable = function (t) {
                            return o.default.object(t) ? (this.options.gesture.enabled = !1 !== t.enabled, this.setPerAction("gesture", t), this.setOnEvents("gesture", t), this) : o.default.bool(t) ? (this.options.gesture.enabled = t, this) : this.options.gesture
                        }, e.map.gesture = _t, e.methodDict.gesture = "gesturable", i.actions.gesture = _t.defaults
                    },
                    listeners: {
                        "interactions:action-start": xt,
                        "interactions:action-move": xt,
                        "interactions:action-end": xt,
                        "interactions:new": function (t) {
                            t.interaction.gesture = {angle: 0, distance: 0, scale: 1, startAngle: 0, startDistance: 0}
                        },
                        "auto-start:check": function (t) {
                            if (!(t.interaction.pointers.length < 2)) {
                                var e = t.interactable.options.gesture;
                                if (e && e.enabled) return t.action = {name: "gesture"}, !1
                            }
                        }
                    },
                    defaults: {},
                    getCursor: function () {
                        return ""
                    }
                }, bt = _t;
                yt.default = bt;
                var wt = {};

                function St(t, e, n, i, r, s, a) {
                    if (!e) return !1;
                    if (!0 === e) {
                        var l = o.default.number(s.width) ? s.width : s.right - s.left,
                            c = o.default.number(s.height) ? s.height : s.bottom - s.top;
                        if (a = Math.min(a, Math.abs(("left" === t || "right" === t ? l : c) / 2)), l < 0 && ("left" === t ? t = "right" : "right" === t && (t = "left")), c < 0 && ("top" === t ? t = "bottom" : "bottom" === t && (t = "top")), "left" === t) return n.x < (l >= 0 ? s.left : s.right) + a;
                        if ("top" === t) return n.y < (c >= 0 ? s.top : s.bottom) + a;
                        if ("right" === t) return n.x > (l >= 0 ? s.right : s.left) - a;
                        if ("bottom" === t) return n.y > (c >= 0 ? s.bottom : s.top) - a
                    }
                    return !!o.default.element(i) && (o.default.element(e) ? e === i : w.matchesUpTo(i, e, r))
                }

                function Mt(t) {
                    var e = t.iEvent, n = t.interaction;
                    if ("resize" === n.prepared.name && n.resizeAxes) {
                        var i = e;
                        n.interactable.options.resize.square ? ("y" === n.resizeAxes ? i.delta.x = i.delta.y : i.delta.y = i.delta.x, i.axes = "xy") : (i.axes = n.resizeAxes, "x" === n.resizeAxes ? i.delta.y = 0 : "y" === n.resizeAxes && (i.delta.x = 0))
                    }
                }

                Object.defineProperty(wt, "__esModule", {value: !0}), wt.default = void 0;
                var Tt = {
                    id: "actions/resize",
                    before: ["actions/drag"],
                    install: function (t) {
                        var e = t.actions, n = t.browser, i = t.Interactable, r = t.defaults;
                        Tt.cursors = function (t) {
                            return t.isIe9 ? {
                                x: "e-resize",
                                y: "s-resize",
                                xy: "se-resize",
                                top: "n-resize",
                                left: "w-resize",
                                bottom: "s-resize",
                                right: "e-resize",
                                topleft: "se-resize",
                                bottomright: "se-resize",
                                topright: "ne-resize",
                                bottomleft: "ne-resize"
                            } : {
                                x: "ew-resize",
                                y: "ns-resize",
                                xy: "nwse-resize",
                                top: "ns-resize",
                                left: "ew-resize",
                                bottom: "ns-resize",
                                right: "ew-resize",
                                topleft: "nwse-resize",
                                bottomright: "nwse-resize",
                                topright: "nesw-resize",
                                bottomleft: "nesw-resize"
                            }
                        }(n), Tt.defaultMargin = n.supportsTouch || n.supportsPointerEvent ? 20 : 10, i.prototype.resizable = function (e) {
                            return function (t, e, n) {
                                return o.default.object(e) ? (t.options.resize.enabled = !1 !== e.enabled, t.setPerAction("resize", e), t.setOnEvents("resize", e), o.default.string(e.axis) && /^x$|^y$|^xy$/.test(e.axis) ? t.options.resize.axis = e.axis : null === e.axis && (t.options.resize.axis = n.defaults.actions.resize.axis), o.default.bool(e.preserveAspectRatio) ? t.options.resize.preserveAspectRatio = e.preserveAspectRatio : o.default.bool(e.square) && (t.options.resize.square = e.square), t) : o.default.bool(e) ? (t.options.resize.enabled = e, t) : t.options.resize
                            }(this, e, t)
                        }, e.map.resize = Tt, e.methodDict.resize = "resizable", r.actions.resize = Tt.defaults
                    },
                    listeners: {
                        "interactions:new": function (t) {
                            t.interaction.resizeAxes = "xy"
                        }, "interactions:action-start": function (t) {
                            !function (t) {
                                var e = t.iEvent, n = t.interaction;
                                if ("resize" === n.prepared.name && n.prepared.edges) {
                                    var i = e, r = n.rect;
                                    n._rects = {
                                        start: (0, L.default)({}, r),
                                        corrected: (0, L.default)({}, r),
                                        previous: (0, L.default)({}, r),
                                        delta: {left: 0, right: 0, width: 0, top: 0, bottom: 0, height: 0}
                                    }, i.edges = n.prepared.edges, i.rect = n._rects.corrected, i.deltaRect = n._rects.delta
                                }
                            }(t), Mt(t)
                        }, "interactions:action-move": function (t) {
                            !function (t) {
                                var e = t.iEvent, n = t.interaction;
                                if ("resize" === n.prepared.name && n.prepared.edges) {
                                    var i = e, r = n.interactable.options.resize.invert,
                                        o = "reposition" === r || "negate" === r, s = n.rect, a = n._rects, l = a.start,
                                        c = a.corrected, u = a.delta, h = a.previous;
                                    if ((0, L.default)(h, c), o) {
                                        if ((0, L.default)(c, s), "reposition" === r) {
                                            if (c.top > c.bottom) {
                                                var d = c.top;
                                                c.top = c.bottom, c.bottom = d
                                            }
                                            if (c.left > c.right) {
                                                var p = c.left;
                                                c.left = c.right, c.right = p
                                            }
                                        }
                                    } else c.top = Math.min(s.top, l.bottom), c.bottom = Math.max(s.bottom, l.top), c.left = Math.min(s.left, l.right), c.right = Math.max(s.right, l.left);
                                    for (var f in c.width = c.right - c.left, c.height = c.bottom - c.top, c) u[f] = c[f] - h[f];
                                    i.edges = n.prepared.edges, i.rect = c, i.deltaRect = u
                                }
                            }(t), Mt(t)
                        }, "interactions:action-end": function (t) {
                            var e = t.iEvent, n = t.interaction;
                            if ("resize" === n.prepared.name && n.prepared.edges) {
                                var i = e;
                                i.edges = n.prepared.edges, i.rect = n._rects.corrected, i.deltaRect = n._rects.delta
                            }
                        }, "auto-start:check": function (t) {
                            var e = t.interaction, n = t.interactable, i = t.element, r = t.rect, s = t.buttons;
                            if (r) {
                                var a = (0, L.default)({}, e.coords.cur.page), l = n.options.resize;
                                if (l && l.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || 0 != (s & l.mouseButtons))) {
                                    if (o.default.object(l.edges)) {
                                        var c = {left: !1, right: !1, top: !1, bottom: !1};
                                        for (var u in c) c[u] = St(u, l.edges[u], a, e._latestPointer.eventTarget, i, r, l.margin || Tt.defaultMargin);
                                        c.left = c.left && !c.right, c.top = c.top && !c.bottom, (c.left || c.right || c.top || c.bottom) && (t.action = {
                                            name: "resize",
                                            edges: c
                                        })
                                    } else {
                                        var h = "y" !== l.axis && a.x > r.right - Tt.defaultMargin,
                                            d = "x" !== l.axis && a.y > r.bottom - Tt.defaultMargin;
                                        (h || d) && (t.action = {name: "resize", axes: (h ? "x" : "") + (d ? "y" : "")})
                                    }
                                    return !t.action && void 0
                                }
                            }
                        }
                    },
                    defaults: {
                        square: !1,
                        preserveAspectRatio: !1,
                        axis: "xy",
                        margin: NaN,
                        edges: null,
                        invert: "none"
                    },
                    cursors: null,
                    getCursor: function (t) {
                        var e = t.edges, n = t.axis, i = t.name, r = Tt.cursors, o = null;
                        if (n) o = r[i + n]; else if (e) {
                            for (var s = "", a = ["top", "bottom", "left", "right"], l = 0; l < a.length; l++) {
                                var c = a[l];
                                e[c] && (s += c)
                            }
                            o = r[s]
                        }
                        return o
                    },
                    defaultMargin: null
                }, Et = Tt;
                wt.default = Et;
                var At = {};
                Object.defineProperty(At, "__esModule", {value: !0}), At.default = void 0;
                var Pt = {
                    id: "actions", install: function (t) {
                        t.usePlugin(yt.default), t.usePlugin(wt.default), t.usePlugin(u.default), t.usePlugin(ct.default)
                    }
                };
                At.default = Pt;
                var Lt = {};
                Object.defineProperty(Lt, "__esModule", {value: !0}), Lt.default = void 0;
                var Ct, Rt, It = 0, Ot = {
                    request: function (t) {
                        return Ct(t)
                    }, cancel: function (t) {
                        return Rt(t)
                    }, init: function (t) {
                        if (Ct = t.requestAnimationFrame, Rt = t.cancelAnimationFrame, !Ct) for (var e = ["ms", "moz", "webkit", "o"], n = 0; n < e.length; n++) {
                            var i = e[n];
                            Ct = t["".concat(i, "RequestAnimationFrame")], Rt = t["".concat(i, "CancelAnimationFrame")] || t["".concat(i, "CancelRequestAnimationFrame")]
                        }
                        Ct = Ct && Ct.bind(t), Rt = Rt && Rt.bind(t), Ct || (Ct = function (e) {
                            var n = Date.now(), i = Math.max(0, 16 - (n - It)), r = t.setTimeout((function () {
                                e(n + i)
                            }), i);
                            return It = n + i, r
                        }, Rt = function (t) {
                            return clearTimeout(t)
                        })
                    }
                };
                Lt.default = Ot;
                var Dt = {};
                Object.defineProperty(Dt, "__esModule", {value: !0}), Dt.getContainer = kt, Dt.getScroll = Nt, Dt.getScrollSize = function (t) {
                    return o.default.window(t) && (t = window.document.body), {x: t.scrollWidth, y: t.scrollHeight}
                }, Dt.getScrollSizeDelta = function (t, e) {
                    var n = t.interaction, i = t.element, r = n && n.interactable.options[n.prepared.name].autoScroll;
                    if (!r || !r.enabled) return e(), {x: 0, y: 0};
                    var o = kt(r.container, n.interactable, i), s = Nt(o);
                    e();
                    var a = Nt(o);
                    return {x: a.x - s.x, y: a.y - s.y}
                }, Dt.default = void 0;
                var zt = {
                    defaults: {enabled: !1, margin: 60, container: null, speed: 300},
                    now: Date.now,
                    interaction: null,
                    i: 0,
                    x: 0,
                    y: 0,
                    isScrolling: !1,
                    prevTime: 0,
                    margin: 0,
                    speed: 0,
                    start: function (t) {
                        zt.isScrolling = !0, Lt.default.cancel(zt.i), t.autoScroll = zt, zt.interaction = t, zt.prevTime = zt.now(), zt.i = Lt.default.request(zt.scroll)
                    },
                    stop: function () {
                        zt.isScrolling = !1, zt.interaction && (zt.interaction.autoScroll = null), Lt.default.cancel(zt.i)
                    },
                    scroll: function () {
                        var t = zt.interaction, e = t.interactable, n = t.element, i = t.prepared.name,
                            r = e.options[i].autoScroll, s = kt(r.container, e, n), a = zt.now(),
                            l = (a - zt.prevTime) / 1e3, c = r.speed * l;
                        if (c >= 1) {
                            var u = {x: zt.x * c, y: zt.y * c};
                            if (u.x || u.y) {
                                var h = Nt(s);
                                o.default.window(s) ? s.scrollBy(u.x, u.y) : s && (s.scrollLeft += u.x, s.scrollTop += u.y);
                                var d = Nt(s), p = {x: d.x - h.x, y: d.y - h.y};
                                (p.x || p.y) && e.fire({
                                    type: "autoscroll",
                                    target: n,
                                    interactable: e,
                                    delta: p,
                                    interaction: t,
                                    container: s
                                })
                            }
                            zt.prevTime = a
                        }
                        zt.isScrolling && (Lt.default.cancel(zt.i), zt.i = Lt.default.request(zt.scroll))
                    },
                    check: function (t, e) {
                        var n;
                        return null == (n = t.options[e].autoScroll) ? void 0 : n.enabled
                    },
                    onInteractionMove: function (t) {
                        var e = t.interaction, n = t.pointer;
                        if (e.interacting() && zt.check(e.interactable, e.prepared.name)) if (e.simulation) zt.x = zt.y = 0; else {
                            var i, r, s, a, l = e.interactable, c = e.element, u = e.prepared.name,
                                h = l.options[u].autoScroll, d = kt(h.container, l, c);
                            if (o.default.window(d)) a = n.clientX < zt.margin, i = n.clientY < zt.margin, r = n.clientX > d.innerWidth - zt.margin, s = n.clientY > d.innerHeight - zt.margin; else {
                                var p = w.getElementClientRect(d);
                                a = n.clientX < p.left + zt.margin, i = n.clientY < p.top + zt.margin, r = n.clientX > p.right - zt.margin, s = n.clientY > p.bottom - zt.margin
                            }
                            zt.x = r ? 1 : a ? -1 : 0, zt.y = s ? 1 : i ? -1 : 0, zt.isScrolling || (zt.margin = h.margin, zt.speed = h.speed, zt.start(e))
                        }
                    }
                };

                function kt(t, n, i) {
                    return (o.default.string(t) ? (0, C.getStringOptionResult)(t, n, i) : t) || (0, e.getWindow)(i)
                }

                function Nt(t) {
                    return o.default.window(t) && (t = window.document.body), {x: t.scrollLeft, y: t.scrollTop}
                }

                var Bt = {
                    id: "auto-scroll", install: function (t) {
                        var e = t.defaults, n = t.actions;
                        t.autoScroll = zt, zt.now = function () {
                            return t.now()
                        }, n.phaselessTypes.autoscroll = !0, e.perAction.autoScroll = zt.defaults
                    }, listeners: {
                        "interactions:new": function (t) {
                            t.interaction.autoScroll = null
                        }, "interactions:destroy": function (t) {
                            t.interaction.autoScroll = null, zt.stop(), zt.interaction && (zt.interaction = null)
                        }, "interactions:stop": zt.stop, "interactions:action-move": function (t) {
                            return zt.onInteractionMove(t)
                        }
                    }
                };
                Dt.default = Bt;
                var Ft = {};
                Object.defineProperty(Ft, "__esModule", {value: !0}), Ft.warnOnce = function (t, n) {
                    var i = !1;
                    return function () {
                        return i || (e.window.console.warn(n), i = !0), t.apply(this, arguments)
                    }
                }, Ft.copyAction = function (t, e) {
                    return t.name = e.name, t.axis = e.axis, t.edges = e.edges, t
                }, Ft.sign = void 0, Ft.sign = function (t) {
                    return t >= 0 ? 1 : -1
                };
                var Ut = {};

                function Ht(t) {
                    return o.default.bool(t) ? (this.options.styleCursor = t, this) : null === t ? (delete this.options.styleCursor, this) : this.options.styleCursor
                }

                function Vt(t) {
                    return o.default.func(t) ? (this.options.actionChecker = t, this) : null === t ? (delete this.options.actionChecker, this) : this.options.actionChecker
                }

                Object.defineProperty(Ut, "__esModule", {value: !0}), Ut.default = void 0;
                var Gt = {
                    id: "auto-start/interactableMethods", install: function (t) {
                        var e = t.Interactable;
                        e.prototype.getAction = function (e, n, i, r) {
                            var o = function (t, e, n, i, r) {
                                var o = t.getRect(i), s = {
                                    action: null,
                                    interactable: t,
                                    interaction: n,
                                    element: i,
                                    rect: o,
                                    buttons: e.buttons || {0: 1, 1: 4, 3: 8, 4: 16}[e.button]
                                };
                                return r.fire("auto-start:check", s), s.action
                            }(this, n, i, r, t);
                            return this.options.actionChecker ? this.options.actionChecker(e, n, o, this, r, i) : o
                        }, e.prototype.ignoreFrom = (0, Ft.warnOnce)((function (t) {
                            return this._backCompatOption("ignoreFrom", t)
                        }), "Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue})."), e.prototype.allowFrom = (0, Ft.warnOnce)((function (t) {
                            return this._backCompatOption("allowFrom", t)
                        }), "Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue})."), e.prototype.actionChecker = Vt, e.prototype.styleCursor = Ht
                    }
                };
                Ut.default = Gt;
                var Wt = {};

                function jt(t, e, n, i, r) {
                    return e.testIgnoreAllow(e.options[t.name], n, i) && e.options[t.name].enabled && Jt(e, n, t, r) ? t : null
                }

                function qt(t, e, n, i, r, o, s) {
                    for (var a = 0, l = i.length; a < l; a++) {
                        var c = i[a], u = r[a], h = c.getAction(e, n, t, u);
                        if (h) {
                            var d = jt(h, c, u, o, s);
                            if (d) return {action: d, interactable: c, element: u}
                        }
                    }
                    return {action: null, interactable: null, element: null}
                }

                function Xt(t, e, n, i, r) {
                    var s = [], a = [], l = i;

                    function c(t) {
                        s.push(t), a.push(l)
                    }

                    for (; o.default.element(l);) {
                        s = [], a = [], r.interactables.forEachMatch(l, c);
                        var u = qt(t, e, n, s, a, i, r);
                        if (u.action && !u.interactable.options[u.action.name].manualStart) return u;
                        l = w.parentNode(l)
                    }
                    return {action: null, interactable: null, element: null}
                }

                function Yt(t, e, n) {
                    var i = e.action, r = e.interactable, o = e.element;
                    i = i || {name: null}, t.interactable = r, t.element = o, (0, Ft.copyAction)(t.prepared, i), t.rect = r && i.name ? r.getRect(o) : null, Kt(t, n), n.fire("autoStart:prepared", {interaction: t})
                }

                function Jt(t, e, n, i) {
                    var r = t.options, o = r[n.name].max, s = r[n.name].maxPerElement, a = i.autoStart.maxInteractions,
                        l = 0, c = 0, u = 0;
                    if (!(o && s && a)) return !1;
                    for (var h = 0; h < i.interactions.list.length; h++) {
                        var d = i.interactions.list[h], p = d.prepared.name;
                        if (d.interacting()) {
                            if (++l >= a) return !1;
                            if (d.interactable === t) {
                                if ((c += p === n.name ? 1 : 0) >= o) return !1;
                                if (d.element === e && (u++, p === n.name && u >= s)) return !1
                            }
                        }
                    }
                    return a > 0
                }

                function Zt(t, e) {
                    return o.default.number(t) ? (e.autoStart.maxInteractions = t, this) : e.autoStart.maxInteractions
                }

                function Qt(t, e, n) {
                    var i = n.autoStart.cursorElement;
                    i && i !== t && (i.style.cursor = ""), t.ownerDocument.documentElement.style.cursor = e, t.style.cursor = e, n.autoStart.cursorElement = e ? t : null
                }

                function Kt(t, e) {
                    var n = t.interactable, i = t.element, r = t.prepared;
                    if ("mouse" === t.pointerType && n && n.options.styleCursor) {
                        var s = "";
                        if (r.name) {
                            var a = n.options[r.name].cursorChecker;
                            s = o.default.func(a) ? a(r, n, i, t._interacting) : e.actions.map[r.name].getCursor(r)
                        }
                        Qt(t.element, s || "", e)
                    } else e.autoStart.cursorElement && Qt(e.autoStart.cursorElement, "", e)
                }

                Object.defineProperty(Wt, "__esModule", {value: !0}), Wt.default = void 0;
                var $t = {
                    id: "auto-start/base", before: ["actions"], install: function (t) {
                        var e = t.interactStatic, n = t.defaults;
                        t.usePlugin(Ut.default), n.base.actionChecker = null, n.base.styleCursor = !0, (0, L.default)(n.perAction, {
                            manualStart: !1,
                            max: 1 / 0,
                            maxPerElement: 1,
                            allowFrom: null,
                            ignoreFrom: null,
                            mouseButtons: 1
                        }), e.maxInteractions = function (e) {
                            return Zt(e, t)
                        }, t.autoStart = {maxInteractions: 1 / 0, withinInteractionLimit: Jt, cursorElement: null}
                    }, listeners: {
                        "interactions:down": function (t, e) {
                            var n = t.interaction, i = t.pointer, r = t.event, o = t.eventTarget;
                            n.interacting() || Yt(n, Xt(n, i, r, o, e), e)
                        }, "interactions:move": function (t, e) {
                            !function (t, e) {
                                var n = t.interaction, i = t.pointer, r = t.event, o = t.eventTarget;
                                "mouse" !== n.pointerType || n.pointerIsDown || n.interacting() || Yt(n, Xt(n, i, r, o, e), e)
                            }(t, e), function (t, e) {
                                var n = t.interaction;
                                if (n.pointerIsDown && !n.interacting() && n.pointerWasMoved && n.prepared.name) {
                                    e.fire("autoStart:before-start", t);
                                    var i = n.interactable, r = n.prepared.name;
                                    r && i && (i.options[r].manualStart || !Jt(i, n.element, n.prepared, e) ? n.stop() : (n.start(n.prepared, i, n.element), Kt(n, e)))
                                }
                            }(t, e)
                        }, "interactions:stop": function (t, e) {
                            var n = t.interaction, i = n.interactable;
                            i && i.options.styleCursor && Qt(n.element, "", e)
                        }
                    }, maxInteractions: Zt, withinInteractionLimit: Jt, validateAction: jt
                };
                Wt.default = $t;
                var te = {};
                Object.defineProperty(te, "__esModule", {value: !0}), te.default = void 0;
                var ee = {
                    id: "auto-start/dragAxis", listeners: {
                        "autoStart:before-start": function (t, e) {
                            var n = t.interaction, i = t.eventTarget, r = t.dx, s = t.dy;
                            if ("drag" === n.prepared.name) {
                                var a = Math.abs(r), l = Math.abs(s), c = n.interactable.options.drag, u = c.startAxis,
                                    h = a > l ? "x" : a < l ? "y" : "xy";
                                if (n.prepared.axis = "start" === c.lockAxis ? h[0] : c.lockAxis, "xy" !== h && "xy" !== u && u !== h) {
                                    n.prepared.name = null;
                                    for (var d = i, p = function (t) {
                                        if (t !== n.interactable) {
                                            var r = n.interactable.options.drag;
                                            if (!r.manualStart && t.testIgnoreAllow(r, d, i)) {
                                                var o = t.getAction(n.downPointer, n.downEvent, n, d);
                                                if (o && "drag" === o.name && function (t, e) {
                                                    if (!e) return !1;
                                                    var n = e.options.drag.startAxis;
                                                    return "xy" === t || "xy" === n || n === t
                                                }(h, t) && Wt.default.validateAction(o, t, d, i, e)) return t
                                            }
                                        }
                                    }; o.default.element(d);) {
                                        var f = e.interactables.forEachMatch(d, p);
                                        if (f) {
                                            n.prepared.name = "drag", n.interactable = f, n.element = d;
                                            break
                                        }
                                        d = (0, w.parentNode)(d)
                                    }
                                }
                            }
                        }
                    }
                };
                te.default = ee;
                var ne = {};

                function ie(t) {
                    var e = t.prepared && t.prepared.name;
                    if (!e) return null;
                    var n = t.interactable.options;
                    return n[e].hold || n[e].delay
                }

                Object.defineProperty(ne, "__esModule", {value: !0}), ne.default = void 0;
                var re = {
                    id: "auto-start/hold", install: function (t) {
                        var e = t.defaults;
                        t.usePlugin(Wt.default), e.perAction.hold = 0, e.perAction.delay = 0
                    }, listeners: {
                        "interactions:new": function (t) {
                            t.interaction.autoStartHoldTimer = null
                        }, "autoStart:prepared": function (t) {
                            var e = t.interaction, n = ie(e);
                            n > 0 && (e.autoStartHoldTimer = setTimeout((function () {
                                e.start(e.prepared, e.interactable, e.element)
                            }), n))
                        }, "interactions:move": function (t) {
                            var e = t.interaction, n = t.duplicate;
                            e.autoStartHoldTimer && e.pointerWasMoved && !n && (clearTimeout(e.autoStartHoldTimer), e.autoStartHoldTimer = null)
                        }, "autoStart:before-start": function (t) {
                            var e = t.interaction;
                            ie(e) > 0 && (e.prepared.name = null)
                        }
                    }, getHoldDuration: ie
                };
                ne.default = re;
                var oe = {};
                Object.defineProperty(oe, "__esModule", {value: !0}), oe.default = void 0;
                var se = {
                    id: "auto-start", install: function (t) {
                        t.usePlugin(Wt.default), t.usePlugin(ne.default), t.usePlugin(te.default)
                    }
                };
                oe.default = se;
                var ae = {};

                function le(t) {
                    return /^(always|never|auto)$/.test(t) ? (this.options.preventDefault = t, this) : o.default.bool(t) ? (this.options.preventDefault = t ? "always" : "never", this) : this.options.preventDefault
                }

                function ce(t) {
                    var e = t.interaction, n = t.event;
                    e.interactable && e.interactable.checkAndPreventDefault(n)
                }

                function ue(t) {
                    var n = t.Interactable;
                    n.prototype.preventDefault = le, n.prototype.checkAndPreventDefault = function (n) {
                        return function (t, n, i) {
                            var r = t.options.preventDefault;
                            if ("never" !== r) if ("always" !== r) {
                                if (n.events.supportsPassive && /^touch(start|move)$/.test(i.type)) {
                                    var s = (0, e.getWindow)(i.target).document, a = n.getDocOptions(s);
                                    if (!a || !a.events || !1 !== a.events.passive) return
                                }
                                /^(mouse|pointer|touch)*(down|start)/i.test(i.type) || o.default.element(i.target) && (0, w.matchesSelector)(i.target, "input,select,textarea,[contenteditable=true],[contenteditable=true] *") || i.preventDefault()
                            } else i.preventDefault()
                        }(this, t, n)
                    }, t.interactions.docEvents.push({
                        type: "dragstart", listener: function (e) {
                            for (var n = 0; n < t.interactions.list.length; n++) {
                                var i = t.interactions.list[n];
                                if (i.element && (i.element === e.target || (0, w.nodeContains)(i.element, e.target))) return void i.interactable.checkAndPreventDefault(e)
                            }
                        }
                    })
                }

                Object.defineProperty(ae, "__esModule", {value: !0}), ae.install = ue, ae.default = void 0;
                var he = {
                    id: "core/interactablePreventDefault",
                    install: ue,
                    listeners: ["down", "move", "up", "cancel"].reduce((function (t, e) {
                        return t["interactions:".concat(e)] = ce, t
                    }), {})
                };
                ae.default = he;
                var de = {};
                Object.defineProperty(de, "__esModule", {value: !0}), de.default = void 0, de.default = {};
                var pe, fe = {};
                Object.defineProperty(fe, "__esModule", {value: !0}), fe.default = void 0, function (t) {
                    t.touchAction = "touchAction", t.boxSizing = "boxSizing", t.noListeners = "noListeners"
                }(pe || (pe = {})), pe.touchAction, pe.boxSizing, pe.noListeners;
                var me = {
                    id: "dev-tools", install: function () {
                    }
                };
                fe.default = me;
                var ge = {};
                Object.defineProperty(ge, "__esModule", {value: !0}), ge.default = function t(e) {
                    var n = {};
                    for (var i in e) {
                        var r = e[i];
                        o.default.plainObject(r) ? n[i] = t(r) : o.default.array(r) ? n[i] = Q.from(r) : n[i] = r
                    }
                    return n
                };
                var ve = {};

                function ye(t, e) {
                    return function (t) {
                        if (Array.isArray(t)) return t
                    }(t) || function (t, e) {
                        if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) {
                            var n = [], i = !0, r = !1, o = void 0;
                            try {
                                for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); i = !0) ;
                            } catch (t) {
                                r = !0, o = t
                            } finally {
                                try {
                                    i || null == a.return || a.return()
                                } finally {
                                    if (r) throw o
                                }
                            }
                            return n
                        }
                    }(t, e) || function (t, e) {
                        if (t) {
                            if ("string" == typeof t) return xe(t, e);
                            var n = Object.prototype.toString.call(t).slice(8, -1);
                            return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? xe(t, e) : void 0
                        }
                    }(t, e) || function () {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function xe(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var n = 0, i = Array(e); n < e; n++) i[n] = t[n];
                    return i
                }

                function _e(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                }

                function be(t, e, n) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }

                Object.defineProperty(ve, "__esModule", {value: !0}), ve.getRectOffset = Me, ve.default = void 0;
                var we = function () {
                    function t(e) {
                        !function (t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), be(this, "states", []), be(this, "startOffset", {
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0
                        }), be(this, "startDelta", void 0), be(this, "result", void 0), be(this, "endResult", void 0), be(this, "edges", void 0), be(this, "interaction", void 0), this.interaction = e, this.result = Se()
                    }

                    var e;
                    return (e = [{
                        key: "start", value: function (t, e) {
                            var n = t.phase, i = this.interaction, r = function (t) {
                                var e = t.interactable.options[t.prepared.name], n = e.modifiers;
                                return n && n.length ? n : ["snap", "snapSize", "snapEdges", "restrict", "restrictEdges", "restrictSize"].map((function (t) {
                                    var n = e[t];
                                    return n && n.enabled && {options: n, methods: n._methods}
                                })).filter((function (t) {
                                    return !!t
                                }))
                            }(i);
                            this.prepareStates(r), this.edges = (0, L.default)({}, i.edges), this.startOffset = Me(i.rect, e), this.startDelta = {
                                x: 0,
                                y: 0
                            };
                            var o = this.fillArg({phase: n, pageCoords: e, preEnd: !1});
                            return this.result = Se(), this.startAll(o), this.result = this.setAll(o)
                        }
                    }, {
                        key: "fillArg", value: function (t) {
                            var e = this.interaction;
                            return t.interaction = e, t.interactable = e.interactable, t.element = e.element, t.rect = t.rect || e.rect, t.edges = this.edges, t.startOffset = this.startOffset, t
                        }
                    }, {
                        key: "startAll", value: function (t) {
                            for (var e = 0; e < this.states.length; e++) {
                                var n = this.states[e];
                                n.methods.start && (t.state = n, n.methods.start(t))
                            }
                        }
                    }, {
                        key: "setAll", value: function (t) {
                            var e = t.phase, n = t.preEnd, i = t.skipModifiers, r = t.rect;
                            t.coords = (0, L.default)({}, t.pageCoords), t.rect = (0, L.default)({}, r);
                            for (var o = i ? this.states.slice(i) : this.states, s = Se(t.coords, t.rect), a = 0; a < o.length; a++) {
                                var l, c = o[a], u = c.options, h = (0, L.default)({}, t.coords), d = null;
                                null != (l = c.methods) && l.set && this.shouldDo(u, n, e) && (t.state = c, d = c.methods.set(t), C.addEdges(this.interaction.edges, t.rect, {
                                    x: t.coords.x - h.x,
                                    y: t.coords.y - h.y
                                })), s.eventProps.push(d)
                            }
                            s.delta.x = t.coords.x - t.pageCoords.x, s.delta.y = t.coords.y - t.pageCoords.y, s.rectDelta.left = t.rect.left - r.left, s.rectDelta.right = t.rect.right - r.right, s.rectDelta.top = t.rect.top - r.top, s.rectDelta.bottom = t.rect.bottom - r.bottom;
                            var p = this.result.coords, f = this.result.rect;
                            if (p && f) {
                                var m = s.rect.left !== f.left || s.rect.right !== f.right || s.rect.top !== f.top || s.rect.bottom !== f.bottom;
                                s.changed = m || p.x !== s.coords.x || p.y !== s.coords.y
                            }
                            return s
                        }
                    }, {
                        key: "applyToInteraction", value: function (t) {
                            var e = this.interaction, n = t.phase, i = e.coords.cur, r = e.coords.start,
                                o = this.result, s = this.startDelta, a = o.delta;
                            "start" === n && (0, L.default)(this.startDelta, o.delta);
                            for (var l = 0; l < [[r, s], [i, a]].length; l++) {
                                var c = ye([[r, s], [i, a]][l], 2), u = c[0], h = c[1];
                                u.page.x += h.x, u.page.y += h.y, u.client.x += h.x, u.client.y += h.y
                            }
                            var d = this.result.rectDelta, p = t.rect || e.rect;
                            p.left += d.left, p.right += d.right, p.top += d.top, p.bottom += d.bottom, p.width = p.right - p.left, p.height = p.bottom - p.top
                        }
                    }, {
                        key: "setAndApply", value: function (t) {
                            var e = this.interaction, n = t.phase, i = t.preEnd, r = t.skipModifiers,
                                o = this.setAll(this.fillArg({
                                    preEnd: i,
                                    phase: n,
                                    pageCoords: t.modifiedCoords || e.coords.cur.page
                                }));
                            if (this.result = o, !o.changed && (!r || r < this.states.length) && e.interacting()) return !1;
                            if (t.modifiedCoords) {
                                var s = e.coords.cur.page,
                                    a = {x: t.modifiedCoords.x - s.x, y: t.modifiedCoords.y - s.y};
                                o.coords.x += a.x, o.coords.y += a.y, o.delta.x += a.x, o.delta.y += a.y
                            }
                            this.applyToInteraction(t)
                        }
                    }, {
                        key: "beforeEnd", value: function (t) {
                            var e = t.interaction, n = t.event, i = this.states;
                            if (i && i.length) {
                                for (var r = !1, o = 0; o < i.length; o++) {
                                    var s = i[o];
                                    t.state = s;
                                    var a = s.options, l = s.methods, c = l.beforeEnd && l.beforeEnd(t);
                                    if (c) return this.endResult = c, !1;
                                    r = r || !r && this.shouldDo(a, !0, t.phase, !0)
                                }
                                r && e.move({event: n, preEnd: !0})
                            }
                        }
                    }, {
                        key: "stop", value: function (t) {
                            var e = t.interaction;
                            if (this.states && this.states.length) {
                                var n = (0, L.default)({
                                    states: this.states,
                                    interactable: e.interactable,
                                    element: e.element,
                                    rect: null
                                }, t);
                                this.fillArg(n);
                                for (var i = 0; i < this.states.length; i++) {
                                    var r = this.states[i];
                                    n.state = r, r.methods.stop && r.methods.stop(n)
                                }
                                this.states = null, this.endResult = null
                            }
                        }
                    }, {
                        key: "prepareStates", value: function (t) {
                            this.states = [];
                            for (var e = 0; e < t.length; e++) {
                                var n = t[e], i = n.options, r = n.methods, o = n.name;
                                this.states.push({options: i, methods: r, index: e, name: o})
                            }
                            return this.states
                        }
                    }, {
                        key: "restoreInteractionCoords", value: function (t) {
                            var e = t.interaction, n = e.coords, i = e.rect, r = e.modification;
                            if (r.result) {
                                for (var o = r.startDelta, s = r.result, a = s.delta, l = s.rectDelta, c = [[n.start, o], [n.cur, a]], u = 0; u < c.length; u++) {
                                    var h = ye(c[u], 2), d = h[0], p = h[1];
                                    d.page.x -= p.x, d.page.y -= p.y, d.client.x -= p.x, d.client.y -= p.y
                                }
                                i.left -= l.left, i.right -= l.right, i.top -= l.top, i.bottom -= l.bottom
                            }
                        }
                    }, {
                        key: "shouldDo", value: function (t, e, n, i) {
                            return !(!t || !1 === t.enabled || i && !t.endOnly || t.endOnly && !e || "start" === n && !t.setStart)
                        }
                    }, {
                        key: "copyFrom", value: function (t) {
                            this.startOffset = t.startOffset, this.startDelta = t.startDelta, this.edges = t.edges, this.states = t.states.map((function (t) {
                                return (0, ge.default)(t)
                            })), this.result = Se((0, L.default)({}, t.result.coords), (0, L.default)({}, t.result.rect))
                        }
                    }, {
                        key: "destroy", value: function () {
                            for (var t in this) this[t] = null
                        }
                    }]) && _e(t.prototype, e), t
                }();

                function Se(t, e) {
                    return {
                        rect: e,
                        coords: t,
                        delta: {x: 0, y: 0},
                        rectDelta: {left: 0, right: 0, top: 0, bottom: 0},
                        eventProps: [],
                        changed: !0
                    }
                }

                function Me(t, e) {
                    return t ? {
                        left: e.x - t.left,
                        top: e.y - t.top,
                        right: t.right - e.x,
                        bottom: t.bottom - e.y
                    } : {left: 0, top: 0, right: 0, bottom: 0}
                }

                ve.default = we;
                var Te = {};

                function Ee(t) {
                    var e = t.iEvent, n = t.interaction.modification.result;
                    n && (e.modifiers = n.eventProps)
                }

                Object.defineProperty(Te, "__esModule", {value: !0}), Te.makeModifier = function (t, e) {
                    var n = t.defaults, i = {start: t.start, set: t.set, beforeEnd: t.beforeEnd, stop: t.stop},
                        r = function (t) {
                            var r = t || {};
                            for (var o in r.enabled = !1 !== r.enabled, n) o in r || (r[o] = n[o]);
                            var s = {
                                options: r, methods: i, name: e, enable: function () {
                                    return r.enabled = !0, s
                                }, disable: function () {
                                    return r.enabled = !1, s
                                }
                            };
                            return s
                        };
                    return e && "string" == typeof e && (r._defaults = n, r._methods = i), r
                }, Te.addEventModifiers = Ee, Te.default = void 0;
                var Ae = {
                    id: "modifiers/base", before: ["actions"], install: function (t) {
                        t.defaults.perAction.modifiers = []
                    }, listeners: {
                        "interactions:new": function (t) {
                            var e = t.interaction;
                            e.modification = new ve.default(e)
                        },
                        "interactions:before-action-start": function (t) {
                            var e = t.interaction.modification;
                            e.start(t, t.interaction.coords.start.page), t.interaction.edges = e.edges, e.applyToInteraction(t)
                        },
                        "interactions:before-action-move": function (t) {
                            return t.interaction.modification.setAndApply(t)
                        },
                        "interactions:before-action-end": function (t) {
                            return t.interaction.modification.beforeEnd(t)
                        },
                        "interactions:action-start": Ee,
                        "interactions:action-move": Ee,
                        "interactions:action-end": Ee,
                        "interactions:after-action-start": function (t) {
                            return t.interaction.modification.restoreInteractionCoords(t)
                        },
                        "interactions:after-action-move": function (t) {
                            return t.interaction.modification.restoreInteractionCoords(t)
                        },
                        "interactions:stop": function (t) {
                            return t.interaction.modification.stop(t)
                        }
                    }
                };
                Te.default = Ae;
                var Pe = {};
                Object.defineProperty(Pe, "__esModule", {value: !0}), Pe.defaults = void 0, Pe.defaults = {
                    base: {
                        preventDefault: "auto",
                        deltaSource: "page"
                    }, perAction: {enabled: !1, origin: {x: 0, y: 0}}, actions: {}
                };
                var Le = {};

                function Ce(t) {
                    return (Ce = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                        return typeof t
                    } : function (t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    })(t)
                }

                function Re(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                }

                function Ie(t, e) {
                    return (Ie = Object.setPrototypeOf || function (t, e) {
                        return t.__proto__ = e, t
                    })(t, e)
                }

                function Oe(t, e) {
                    return !e || "object" !== Ce(e) && "function" != typeof e ? De(t) : e
                }

                function De(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function ze(t) {
                    return (ze = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    })(t)
                }

                function ke(t, e, n) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }

                Object.defineProperty(Le, "__esModule", {value: !0}), Le.InteractEvent = void 0;
                var Ne = function (t) {
                    !function (t, e) {
                        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                        t.prototype = Object.create(e && e.prototype, {
                            constructor: {
                                value: t,
                                writable: !0,
                                configurable: !0
                            }
                        }), e && Ie(t, e)
                    }(o, t);
                    var e, n, i, r = (n = o, i = function () {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
                            }))), !0
                        } catch (t) {
                            return !1
                        }
                    }(), function () {
                        var t, e = ze(n);
                        if (i) {
                            var r = ze(this).constructor;
                            t = Reflect.construct(e, arguments, r)
                        } else t = e.apply(this, arguments);
                        return Oe(this, t)
                    });

                    function o(t, e, n, i, s, a, l) {
                        var c;
                        !function (t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, o), ke(De(c = r.call(this, t)), "target", void 0), ke(De(c), "currentTarget", void 0), ke(De(c), "relatedTarget", null), ke(De(c), "screenX", void 0), ke(De(c), "screenY", void 0), ke(De(c), "button", void 0), ke(De(c), "buttons", void 0), ke(De(c), "ctrlKey", void 0), ke(De(c), "shiftKey", void 0), ke(De(c), "altKey", void 0), ke(De(c), "metaKey", void 0), ke(De(c), "page", void 0), ke(De(c), "client", void 0), ke(De(c), "delta", void 0), ke(De(c), "rect", void 0), ke(De(c), "x0", void 0), ke(De(c), "y0", void 0), ke(De(c), "t0", void 0), ke(De(c), "dt", void 0), ke(De(c), "duration", void 0), ke(De(c), "clientX0", void 0), ke(De(c), "clientY0", void 0), ke(De(c), "velocity", void 0), ke(De(c), "speed", void 0), ke(De(c), "swipe", void 0), ke(De(c), "timeStamp", void 0), ke(De(c), "axes", void 0), ke(De(c), "preEnd", void 0), s = s || t.element;
                        var u = t.interactable, h = (u && u.options || Pe.defaults).deltaSource,
                            d = (0, O.default)(u, s, n), p = "start" === i, f = "end" === i,
                            m = p ? De(c) : t.prevEvent, g = p ? t.coords.start : f ? {
                                page: m.page,
                                client: m.client,
                                timeStamp: t.coords.cur.timeStamp
                            } : t.coords.cur;
                        return c.page = (0, L.default)({}, g.page), c.client = (0, L.default)({}, g.client), c.rect = (0, L.default)({}, t.rect), c.timeStamp = g.timeStamp, f || (c.page.x -= d.x, c.page.y -= d.y, c.client.x -= d.x, c.client.y -= d.y), c.ctrlKey = e.ctrlKey, c.altKey = e.altKey, c.shiftKey = e.shiftKey, c.metaKey = e.metaKey, c.button = e.button, c.buttons = e.buttons, c.target = s, c.currentTarget = s, c.preEnd = a, c.type = l || n + (i || ""), c.interactable = u, c.t0 = p ? t.pointers[t.pointers.length - 1].downTime : m.t0, c.x0 = t.coords.start.page.x - d.x, c.y0 = t.coords.start.page.y - d.y, c.clientX0 = t.coords.start.client.x - d.x, c.clientY0 = t.coords.start.client.y - d.y, c.delta = p || f ? {
                            x: 0,
                            y: 0
                        } : {
                            x: c[h].x - m[h].x,
                            y: c[h].y - m[h].y
                        }, c.dt = t.coords.delta.timeStamp, c.duration = c.timeStamp - c.t0, c.velocity = (0, L.default)({}, t.coords.velocity[h]), c.speed = (0, k.default)(c.velocity.x, c.velocity.y), c.swipe = f || "inertiastart" === i ? c.getSwipe() : null, c
                    }

                    return (e = [{
                        key: "getSwipe", value: function () {
                            var t = this._interaction;
                            if (t.prevEvent.speed < 600 || this.timeStamp - t.prevEvent.timeStamp > 150) return null;
                            var e = 180 * Math.atan2(t.prevEvent.velocityY, t.prevEvent.velocityX) / Math.PI;
                            e < 0 && (e += 360);
                            var n = 112.5 <= e && e < 247.5, i = 202.5 <= e && e < 337.5;
                            return {
                                up: i,
                                down: !i && 22.5 <= e && e < 157.5,
                                left: n,
                                right: !n && (292.5 <= e || e < 67.5),
                                angle: e,
                                speed: t.prevEvent.speed,
                                velocity: {x: t.prevEvent.velocityX, y: t.prevEvent.velocityY}
                            }
                        }
                    }, {
                        key: "preventDefault", value: function () {
                        }
                    }, {
                        key: "stopImmediatePropagation", value: function () {
                            this.immediatePropagationStopped = this.propagationStopped = !0
                        }
                    }, {
                        key: "stopPropagation", value: function () {
                            this.propagationStopped = !0
                        }
                    }]) && Re(o.prototype, e), o
                }(X.BaseEvent);
                Le.InteractEvent = Ne, Object.defineProperties(Ne.prototype, {
                    pageX: {
                        get: function () {
                            return this.page.x
                        }, set: function (t) {
                            this.page.x = t
                        }
                    }, pageY: {
                        get: function () {
                            return this.page.y
                        }, set: function (t) {
                            this.page.y = t
                        }
                    }, clientX: {
                        get: function () {
                            return this.client.x
                        }, set: function (t) {
                            this.client.x = t
                        }
                    }, clientY: {
                        get: function () {
                            return this.client.y
                        }, set: function (t) {
                            this.client.y = t
                        }
                    }, dx: {
                        get: function () {
                            return this.delta.x
                        }, set: function (t) {
                            this.delta.x = t
                        }
                    }, dy: {
                        get: function () {
                            return this.delta.y
                        }, set: function (t) {
                            this.delta.y = t
                        }
                    }, velocityX: {
                        get: function () {
                            return this.velocity.x
                        }, set: function (t) {
                            this.velocity.x = t
                        }
                    }, velocityY: {
                        get: function () {
                            return this.velocity.y
                        }, set: function (t) {
                            this.velocity.y = t
                        }
                    }
                });
                var Be = {};

                function Fe(t, e, n) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }

                Object.defineProperty(Be, "__esModule", {value: !0}), Be.PointerInfo = void 0, Be.PointerInfo = function t(e, n, i, r, o) {
                    !function (t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), Fe(this, "id", void 0), Fe(this, "pointer", void 0), Fe(this, "event", void 0), Fe(this, "downTime", void 0), Fe(this, "downTarget", void 0), this.id = e, this.pointer = n, this.event = i, this.downTime = r, this.downTarget = o
                };
                var Ue, He, Ve = {};

                function Ge(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                }

                function We(t, e, n) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }

                Object.defineProperty(Ve, "__esModule", {value: !0}), Object.defineProperty(Ve, "PointerInfo", {
                    enumerable: !0,
                    get: function () {
                        return Be.PointerInfo
                    }
                }), Ve.default = Ve.Interaction = Ve._ProxyMethods = Ve._ProxyValues = void 0, Ve._ProxyValues = Ue, function (t) {
                    t.interactable = "", t.element = "", t.prepared = "", t.pointerIsDown = "", t.pointerWasMoved = "", t._proxy = ""
                }(Ue || (Ve._ProxyValues = Ue = {})), Ve._ProxyMethods = He, function (t) {
                    t.start = "", t.move = "", t.end = "", t.stop = "", t.interacting = ""
                }(He || (Ve._ProxyMethods = He = {}));
                var je = 0, qe = function () {
                    function t(e) {
                        var n = this, i = e.pointerType, r = e.scopeFire;
                        !function (t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), We(this, "interactable", null), We(this, "element", null), We(this, "rect", void 0), We(this, "_rects", void 0), We(this, "edges", void 0), We(this, "_scopeFire", void 0), We(this, "prepared", {
                            name: null,
                            axis: null,
                            edges: null
                        }), We(this, "pointerType", void 0), We(this, "pointers", []), We(this, "downEvent", null), We(this, "downPointer", {}), We(this, "_latestPointer", {
                            pointer: null,
                            event: null,
                            eventTarget: null
                        }), We(this, "prevEvent", null), We(this, "pointerIsDown", !1), We(this, "pointerWasMoved", !1), We(this, "_interacting", !1), We(this, "_ending", !1), We(this, "_stopped", !0), We(this, "_proxy", null), We(this, "simulation", null), We(this, "doMove", (0, Ft.warnOnce)((function (t) {
                            this.move(t)
                        }), "The interaction.doMove() method has been renamed to interaction.move()")), We(this, "coords", {
                            start: U.newCoords(),
                            prev: U.newCoords(),
                            cur: U.newCoords(),
                            delta: U.newCoords(),
                            velocity: U.newCoords()
                        }), We(this, "_id", je++), this._scopeFire = r, this.pointerType = i;
                        var o = this;
                        this._proxy = {};
                        var s = function (t) {
                            Object.defineProperty(n._proxy, t, {
                                get: function () {
                                    return o[t]
                                }
                            })
                        };
                        for (var a in Ue) s(a);
                        var l = function (t) {
                            Object.defineProperty(n._proxy, t, {
                                value: function () {
                                    return o[t].apply(o, arguments)
                                }
                            })
                        };
                        for (var c in He) l(c);
                        this._scopeFire("interactions:new", {interaction: this})
                    }

                    var e;
                    return (e = [{
                        key: "pointerMoveTolerance", get: function () {
                            return 1
                        }
                    }, {
                        key: "pointerDown", value: function (t, e, n) {
                            var i = this.updatePointer(t, e, n, !0), r = this.pointers[i];
                            this._scopeFire("interactions:down", {
                                pointer: t,
                                event: e,
                                eventTarget: n,
                                pointerIndex: i,
                                pointerInfo: r,
                                type: "down",
                                interaction: this
                            })
                        }
                    }, {
                        key: "start", value: function (t, e, n) {
                            return !(this.interacting() || !this.pointerIsDown || this.pointers.length < ("gesture" === t.name ? 2 : 1) || !e.options[t.name].enabled) && ((0, Ft.copyAction)(this.prepared, t), this.interactable = e, this.element = n, this.rect = e.getRect(n), this.edges = this.prepared.edges ? (0, L.default)({}, this.prepared.edges) : {
                                left: !0,
                                right: !0,
                                top: !0,
                                bottom: !0
                            }, this._stopped = !1, this._interacting = this._doPhase({
                                interaction: this,
                                event: this.downEvent,
                                phase: "start"
                            }) && !this._stopped, this._interacting)
                        }
                    }, {
                        key: "pointerMove", value: function (t, e, n) {
                            this.simulation || this.modification && this.modification.endResult || this.updatePointer(t, e, n, !1);
                            var i, r,
                                o = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;
                            this.pointerIsDown && !this.pointerWasMoved && (i = this.coords.cur.client.x - this.coords.start.client.x, r = this.coords.cur.client.y - this.coords.start.client.y, this.pointerWasMoved = (0, k.default)(i, r) > this.pointerMoveTolerance);
                            var s = this.getPointerIndex(t), a = {
                                pointer: t,
                                pointerIndex: s,
                                pointerInfo: this.pointers[s],
                                event: e,
                                type: "move",
                                eventTarget: n,
                                dx: i,
                                dy: r,
                                duplicate: o,
                                interaction: this
                            };
                            o || U.setCoordVelocity(this.coords.velocity, this.coords.delta), this._scopeFire("interactions:move", a), o || this.simulation || (this.interacting() && (a.type = null, this.move(a)), this.pointerWasMoved && U.copyCoords(this.coords.prev, this.coords.cur))
                        }
                    }, {
                        key: "move", value: function (t) {
                            t && t.event || U.setZeroCoords(this.coords.delta), (t = (0, L.default)({
                                pointer: this._latestPointer.pointer,
                                event: this._latestPointer.event,
                                eventTarget: this._latestPointer.eventTarget,
                                interaction: this
                            }, t || {})).phase = "move", this._doPhase(t)
                        }
                    }, {
                        key: "pointerUp", value: function (t, e, n, i) {
                            var r = this.getPointerIndex(t);
                            -1 === r && (r = this.updatePointer(t, e, n, !1));
                            var o = /cancel$/i.test(e.type) ? "cancel" : "up";
                            this._scopeFire("interactions:".concat(o), {
                                pointer: t,
                                pointerIndex: r,
                                pointerInfo: this.pointers[r],
                                event: e,
                                eventTarget: n,
                                type: o,
                                curEventTarget: i,
                                interaction: this
                            }), this.simulation || this.end(e), this.removePointer(t, e)
                        }
                    }, {
                        key: "documentBlur", value: function (t) {
                            this.end(t), this._scopeFire("interactions:blur", {
                                event: t,
                                type: "blur",
                                interaction: this
                            })
                        }
                    }, {
                        key: "end", value: function (t) {
                            var e;
                            this._ending = !0, t = t || this._latestPointer.event, this.interacting() && (e = this._doPhase({
                                event: t,
                                interaction: this,
                                phase: "end"
                            })), this._ending = !1, !0 === e && this.stop()
                        }
                    }, {
                        key: "currentAction", value: function () {
                            return this._interacting ? this.prepared.name : null
                        }
                    }, {
                        key: "interacting", value: function () {
                            return this._interacting
                        }
                    }, {
                        key: "stop", value: function () {
                            this._scopeFire("interactions:stop", {interaction: this}), this.interactable = this.element = null, this._interacting = !1, this._stopped = !0, this.prepared.name = this.prevEvent = null
                        }
                    }, {
                        key: "getPointerIndex", value: function (t) {
                            var e = U.getPointerId(t);
                            return "mouse" === this.pointerType || "pen" === this.pointerType ? this.pointers.length - 1 : Q.findIndex(this.pointers, (function (t) {
                                return t.id === e
                            }))
                        }
                    }, {
                        key: "getPointerInfo", value: function (t) {
                            return this.pointers[this.getPointerIndex(t)]
                        }
                    }, {
                        key: "updatePointer", value: function (t, e, n, i) {
                            var r = U.getPointerId(t), o = this.getPointerIndex(t), s = this.pointers[o];
                            return i = !1 !== i && (i || /(down|start)$/i.test(e.type)), s ? s.pointer = t : (s = new Be.PointerInfo(r, t, e, null, null), o = this.pointers.length, this.pointers.push(s)), U.setCoords(this.coords.cur, this.pointers.map((function (t) {
                                return t.pointer
                            })), this._now()), U.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur), i && (this.pointerIsDown = !0, s.downTime = this.coords.cur.timeStamp, s.downTarget = n, U.pointerExtend(this.downPointer, t), this.interacting() || (U.copyCoords(this.coords.start, this.coords.cur), U.copyCoords(this.coords.prev, this.coords.cur), this.downEvent = e, this.pointerWasMoved = !1)), this._updateLatestPointer(t, e, n), this._scopeFire("interactions:update-pointer", {
                                pointer: t,
                                event: e,
                                eventTarget: n,
                                down: i,
                                pointerInfo: s,
                                pointerIndex: o,
                                interaction: this
                            }), o
                        }
                    }, {
                        key: "removePointer", value: function (t, e) {
                            var n = this.getPointerIndex(t);
                            if (-1 !== n) {
                                var i = this.pointers[n];
                                this._scopeFire("interactions:remove-pointer", {
                                    pointer: t,
                                    event: e,
                                    eventTarget: null,
                                    pointerIndex: n,
                                    pointerInfo: i,
                                    interaction: this
                                }), this.pointers.splice(n, 1), this.pointerIsDown = !1
                            }
                        }
                    }, {
                        key: "_updateLatestPointer", value: function (t, e, n) {
                            this._latestPointer.pointer = t, this._latestPointer.event = e, this._latestPointer.eventTarget = n
                        }
                    }, {
                        key: "destroy", value: function () {
                            this._latestPointer.pointer = null, this._latestPointer.event = null, this._latestPointer.eventTarget = null
                        }
                    }, {
                        key: "_createPreparedEvent", value: function (t, e, n, i) {
                            return new Le.InteractEvent(this, t, this.prepared.name, e, this.element, n, i)
                        }
                    }, {
                        key: "_fireEvent", value: function (t) {
                            this.interactable.fire(t), (!this.prevEvent || t.timeStamp >= this.prevEvent.timeStamp) && (this.prevEvent = t)
                        }
                    }, {
                        key: "_doPhase", value: function (t) {
                            var e = t.event, n = t.phase, i = t.preEnd, r = t.type, o = this.rect;
                            if (o && "move" === n && (C.addEdges(this.edges, o, this.coords.delta[this.interactable.options.deltaSource]), o.width = o.right - o.left, o.height = o.bottom - o.top), !1 === this._scopeFire("interactions:before-action-".concat(n), t)) return !1;
                            var s = t.iEvent = this._createPreparedEvent(e, n, i, r);
                            return this._scopeFire("interactions:action-".concat(n), t), "start" === n && (this.prevEvent = s), this._fireEvent(s), this._scopeFire("interactions:after-action-".concat(n), t), !0
                        }
                    }, {
                        key: "_now", value: function () {
                            return Date.now()
                        }
                    }]) && Ge(t.prototype, e), t
                }();
                Ve.Interaction = qe;
                var Xe = qe;
                Ve.default = Xe;
                var Ye = {};

                function Je(t) {
                    t.pointerIsDown && ($e(t.coords.cur, t.offset.total), t.offset.pending.x = 0, t.offset.pending.y = 0)
                }

                function Ze(t) {
                    Qe(t.interaction)
                }

                function Qe(t) {
                    if (!function (t) {
                        return !(!t.offset.pending.x && !t.offset.pending.y)
                    }(t)) return !1;
                    var e = t.offset.pending;
                    return $e(t.coords.cur, e), $e(t.coords.delta, e), C.addEdges(t.edges, t.rect, e), e.x = 0, e.y = 0, !0
                }

                function Ke(t) {
                    var e = t.x, n = t.y;
                    this.offset.pending.x += e, this.offset.pending.y += n, this.offset.total.x += e, this.offset.total.y += n
                }

                function $e(t, e) {
                    var n = t.page, i = t.client, r = e.x, o = e.y;
                    n.x += r, n.y += o, i.x += r, i.y += o
                }

                Object.defineProperty(Ye, "__esModule", {value: !0}), Ye.addTotal = Je, Ye.applyPending = Qe, Ye.default = void 0, Ve._ProxyMethods.offsetBy = "";
                var tn = {
                    id: "offset",
                    before: ["modifiers", "pointer-events", "actions", "inertia"],
                    install: function (t) {
                        t.Interaction.prototype.offsetBy = Ke
                    },
                    listeners: {
                        "interactions:new": function (t) {
                            t.interaction.offset = {total: {x: 0, y: 0}, pending: {x: 0, y: 0}}
                        },
                        "interactions:update-pointer": function (t) {
                            return Je(t.interaction)
                        },
                        "interactions:before-action-start": Ze,
                        "interactions:before-action-move": Ze,
                        "interactions:before-action-end": function (t) {
                            var e = t.interaction;
                            if (Qe(e)) return e.move({offset: !0}), e.end(), !1
                        },
                        "interactions:stop": function (t) {
                            var e = t.interaction;
                            e.offset.total.x = 0, e.offset.total.y = 0, e.offset.pending.x = 0, e.offset.pending.y = 0
                        }
                    }
                };
                Ye.default = tn;
                var en = {};

                function nn(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                }

                function rn(t, e, n) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }

                Object.defineProperty(en, "__esModule", {value: !0}), en.default = en.InertiaState = void 0;
                var on = function () {
                    function t(e) {
                        !function (t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), rn(this, "active", !1), rn(this, "isModified", !1), rn(this, "smoothEnd", !1), rn(this, "allowResume", !1), rn(this, "modification", void 0), rn(this, "modifierCount", 0), rn(this, "modifierArg", void 0), rn(this, "startCoords", void 0), rn(this, "t0", 0), rn(this, "v0", 0), rn(this, "te", 0), rn(this, "targetOffset", void 0), rn(this, "modifiedOffset", void 0), rn(this, "currentOffset", void 0), rn(this, "lambda_v0", 0), rn(this, "one_ve_v0", 0), rn(this, "timeout", void 0), rn(this, "interaction", void 0), this.interaction = e
                    }

                    var e;
                    return (e = [{
                        key: "start", value: function (t) {
                            var e = this.interaction, n = sn(e);
                            if (!n || !n.enabled) return !1;
                            var i = e.coords.velocity.client, r = (0, k.default)(i.x, i.y),
                                o = this.modification || (this.modification = new ve.default(e));
                            if (o.copyFrom(e.modification), this.t0 = e._now(), this.allowResume = n.allowResume, this.v0 = r, this.currentOffset = {
                                x: 0,
                                y: 0
                            }, this.startCoords = e.coords.cur.page, this.modifierArg = o.fillArg({
                                pageCoords: this.startCoords,
                                preEnd: !0,
                                phase: "inertiastart"
                            }), this.t0 - e.coords.cur.timeStamp < 50 && r > n.minSpeed && r > n.endSpeed) this.startInertia(); else {
                                if (o.result = o.setAll(this.modifierArg), !o.result.changed) return !1;
                                this.startSmoothEnd()
                            }
                            return e.modification.result.rect = null, e.offsetBy(this.targetOffset), e._doPhase({
                                interaction: e,
                                event: t,
                                phase: "inertiastart"
                            }), e.offsetBy({
                                x: -this.targetOffset.x,
                                y: -this.targetOffset.y
                            }), e.modification.result.rect = null, this.active = !0, e.simulation = this, !0
                        }
                    }, {
                        key: "startInertia", value: function () {
                            var t = this, e = this.interaction.coords.velocity.client, n = sn(this.interaction),
                                i = n.resistance, r = -Math.log(n.endSpeed / this.v0) / i;
                            this.targetOffset = {
                                x: (e.x - r) / i,
                                y: (e.y - r) / i
                            }, this.te = r, this.lambda_v0 = i / this.v0, this.one_ve_v0 = 1 - n.endSpeed / this.v0;
                            var o = this.modification, s = this.modifierArg;
                            s.pageCoords = {
                                x: this.startCoords.x + this.targetOffset.x,
                                y: this.startCoords.y + this.targetOffset.y
                            }, o.result = o.setAll(s), o.result.changed && (this.isModified = !0, this.modifiedOffset = {
                                x: this.targetOffset.x + o.result.delta.x,
                                y: this.targetOffset.y + o.result.delta.y
                            }), this.onNextFrame((function () {
                                return t.inertiaTick()
                            }))
                        }
                    }, {
                        key: "startSmoothEnd", value: function () {
                            var t = this;
                            this.smoothEnd = !0, this.isModified = !0, this.targetOffset = {
                                x: this.modification.result.delta.x,
                                y: this.modification.result.delta.y
                            }, this.onNextFrame((function () {
                                return t.smoothEndTick()
                            }))
                        }
                    }, {
                        key: "onNextFrame", value: function (t) {
                            var e = this;
                            this.timeout = Lt.default.request((function () {
                                e.active && t()
                            }))
                        }
                    }, {
                        key: "inertiaTick", value: function () {
                            var t, e, n, i, r, o = this, s = this.interaction, a = sn(s).resistance,
                                l = (s._now() - this.t0) / 1e3;
                            if (l < this.te) {
                                var c, u = 1 - (Math.exp(-a * l) - this.lambda_v0) / this.one_ve_v0;
                                this.isModified ? (t = this.targetOffset.x, e = this.targetOffset.y, n = this.modifiedOffset.x, i = this.modifiedOffset.y, c = {
                                    x: an(r = u, 0, t, n),
                                    y: an(r, 0, e, i)
                                }) : c = {x: this.targetOffset.x * u, y: this.targetOffset.y * u};
                                var h = {x: c.x - this.currentOffset.x, y: c.y - this.currentOffset.y};
                                this.currentOffset.x += h.x, this.currentOffset.y += h.y, s.offsetBy(h), s.move(), this.onNextFrame((function () {
                                    return o.inertiaTick()
                                }))
                            } else s.offsetBy({
                                x: this.modifiedOffset.x - this.currentOffset.x,
                                y: this.modifiedOffset.y - this.currentOffset.y
                            }), this.end()
                        }
                    }, {
                        key: "smoothEndTick", value: function () {
                            var t = this, e = this.interaction, n = e._now() - this.t0, i = sn(e).smoothEndDuration;
                            if (n < i) {
                                var r = {x: ln(n, 0, this.targetOffset.x, i), y: ln(n, 0, this.targetOffset.y, i)},
                                    o = {x: r.x - this.currentOffset.x, y: r.y - this.currentOffset.y};
                                this.currentOffset.x += o.x, this.currentOffset.y += o.y, e.offsetBy(o), e.move({skipModifiers: this.modifierCount}), this.onNextFrame((function () {
                                    return t.smoothEndTick()
                                }))
                            } else e.offsetBy({
                                x: this.targetOffset.x - this.currentOffset.x,
                                y: this.targetOffset.y - this.currentOffset.y
                            }), this.end()
                        }
                    }, {
                        key: "resume", value: function (t) {
                            var e = t.pointer, n = t.event, i = t.eventTarget, r = this.interaction;
                            r.offsetBy({
                                x: -this.currentOffset.x,
                                y: -this.currentOffset.y
                            }), r.updatePointer(e, n, i, !0), r._doPhase({
                                interaction: r,
                                event: n,
                                phase: "resume"
                            }), (0, U.copyCoords)(r.coords.prev, r.coords.cur), this.stop()
                        }
                    }, {
                        key: "end", value: function () {
                            this.interaction.move(), this.interaction.end(), this.stop()
                        }
                    }, {
                        key: "stop", value: function () {
                            this.active = this.smoothEnd = !1, this.interaction.simulation = null, Lt.default.cancel(this.timeout)
                        }
                    }]) && nn(t.prototype, e), t
                }();

                function sn(t) {
                    var e = t.interactable, n = t.prepared;
                    return e && e.options && n.name && e.options[n.name].inertia
                }

                function an(t, e, n, i) {
                    var r = 1 - t;
                    return r * r * e + 2 * r * t * n + t * t * i
                }

                function ln(t, e, n, i) {
                    return -n * (t /= i) * (t - 2) + e
                }

                en.InertiaState = on;
                var cn = {
                    id: "inertia", before: ["modifiers", "actions"], install: function (t) {
                        var e = t.defaults;
                        t.usePlugin(Ye.default), t.usePlugin(Te.default), t.actions.phases.inertiastart = !0, t.actions.phases.resume = !0, e.perAction.inertia = {
                            enabled: !1,
                            resistance: 10,
                            minSpeed: 100,
                            endSpeed: 10,
                            allowResume: !0,
                            smoothEndDuration: 300
                        }
                    }, listeners: {
                        "interactions:new": function (t) {
                            var e = t.interaction;
                            e.inertia = new on(e)
                        },
                        "interactions:before-action-end": function (t) {
                            var e = t.interaction, n = t.event;
                            return (!e._interacting || e.simulation || !e.inertia.start(n)) && null
                        },
                        "interactions:down": function (t) {
                            var e = t.interaction, n = t.eventTarget, i = e.inertia;
                            if (i.active) for (var r = n; o.default.element(r);) {
                                if (r === e.element) {
                                    i.resume(t);
                                    break
                                }
                                r = w.parentNode(r)
                            }
                        },
                        "interactions:stop": function (t) {
                            var e = t.interaction.inertia;
                            e.active && e.stop()
                        },
                        "interactions:before-action-resume": function (t) {
                            var e = t.interaction.modification;
                            e.stop(t), e.start(t, t.interaction.coords.cur.page), e.applyToInteraction(t)
                        },
                        "interactions:before-action-inertiastart": function (t) {
                            return t.interaction.modification.setAndApply(t)
                        },
                        "interactions:action-resume": Te.addEventModifiers,
                        "interactions:action-inertiastart": Te.addEventModifiers,
                        "interactions:after-action-inertiastart": function (t) {
                            return t.interaction.modification.restoreInteractionCoords(t)
                        },
                        "interactions:after-action-resume": function (t) {
                            return t.interaction.modification.restoreInteractionCoords(t)
                        }
                    }
                };
                en.default = cn;
                var un = {};

                function hn(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                }

                function dn(t, e, n) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }

                function pn(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        if (t.immediatePropagationStopped) break;
                        i(t)
                    }
                }

                Object.defineProperty(un, "__esModule", {value: !0}), un.Eventable = void 0;
                var fn = function () {
                    function t(e) {
                        !function (t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), dn(this, "options", void 0), dn(this, "types", {}), dn(this, "propagationStopped", !1), dn(this, "immediatePropagationStopped", !1), dn(this, "global", void 0), this.options = (0, L.default)({}, e || {})
                    }

                    var e;
                    return (e = [{
                        key: "fire", value: function (t) {
                            var e, n = this.global;
                            (e = this.types[t.type]) && pn(t, e), !t.propagationStopped && n && (e = n[t.type]) && pn(t, e)
                        }
                    }, {
                        key: "on", value: function (t, e) {
                            var n = (0, D.default)(t, e);
                            for (t in n) this.types[t] = Q.merge(this.types[t] || [], n[t])
                        }
                    }, {
                        key: "off", value: function (t, e) {
                            var n = (0, D.default)(t, e);
                            for (t in n) {
                                var i = this.types[t];
                                if (i && i.length) for (var r = 0; r < n[t].length; r++) {
                                    var o = n[t][r], s = i.indexOf(o);
                                    -1 !== s && i.splice(s, 1)
                                }
                            }
                        }
                    }, {
                        key: "getRect", value: function (t) {
                            return null
                        }
                    }]) && hn(t.prototype, e), t
                }();
                un.Eventable = fn;
                var mn = {};
                Object.defineProperty(mn, "__esModule", {value: !0}), mn.default = function (t, e) {
                    if (e.phaselessTypes[t]) return !0;
                    for (var n in e.map) if (0 === t.indexOf(n) && t.substr(n.length) in e.phases) return !0;
                    return !1
                };
                var gn = {};
                Object.defineProperty(gn, "__esModule", {value: !0}), gn.createInteractStatic = function (t) {
                    var e = function e(n, i) {
                        var r = t.interactables.get(n, i);
                        return r || ((r = t.interactables.new(n, i)).events.global = e.globalEvents), r
                    };
                    return e.getPointerAverage = U.pointerAverage, e.getTouchBBox = U.touchBBox, e.getTouchDistance = U.touchDistance, e.getTouchAngle = U.touchAngle, e.getElementRect = w.getElementRect, e.getElementClientRect = w.getElementClientRect, e.matchesSelector = w.matchesSelector, e.closest = w.closest, e.globalEvents = {}, e.version = "1.10.11", e.scope = t, e.use = function (t, e) {
                        return this.scope.usePlugin(t, e), this
                    }, e.isSet = function (t, e) {
                        return !!this.scope.interactables.get(t, e && e.context)
                    }, e.on = (0, Ft.warnOnce)((function (t, e, n) {
                        if (o.default.string(t) && -1 !== t.search(" ") && (t = t.trim().split(/ +/)), o.default.array(t)) {
                            for (var i = 0; i < t.length; i++) {
                                var r = t[i];
                                this.on(r, e, n)
                            }
                            return this
                        }
                        if (o.default.object(t)) {
                            for (var s in t) this.on(s, t[s], e);
                            return this
                        }
                        return (0, mn.default)(t, this.scope.actions) ? this.globalEvents[t] ? this.globalEvents[t].push(e) : this.globalEvents[t] = [e] : this.scope.events.add(this.scope.document, t, e, {options: n}), this
                    }), "The interact.on() method is being deprecated"), e.off = (0, Ft.warnOnce)((function (t, e, n) {
                        if (o.default.string(t) && -1 !== t.search(" ") && (t = t.trim().split(/ +/)), o.default.array(t)) {
                            for (var i = 0; i < t.length; i++) {
                                var r = t[i];
                                this.off(r, e, n)
                            }
                            return this
                        }
                        if (o.default.object(t)) {
                            for (var s in t) this.off(s, t[s], e);
                            return this
                        }
                        var a;
                        return (0, mn.default)(t, this.scope.actions) ? t in this.globalEvents && -1 !== (a = this.globalEvents[t].indexOf(e)) && this.globalEvents[t].splice(a, 1) : this.scope.events.remove(this.scope.document, t, e, n), this
                    }), "The interact.off() method is being deprecated"), e.debug = function () {
                        return this.scope
                    }, e.supportsTouch = function () {
                        return x.default.supportsTouch
                    }, e.supportsPointerEvent = function () {
                        return x.default.supportsPointerEvent
                    }, e.stop = function () {
                        for (var t = 0; t < this.scope.interactions.list.length; t++) this.scope.interactions.list[t].stop();
                        return this
                    }, e.pointerMoveTolerance = function (t) {
                        return o.default.number(t) ? (this.scope.interactions.pointerMoveTolerance = t, this) : this.scope.interactions.pointerMoveTolerance
                    }, e.addDocument = function (t, e) {
                        this.scope.addDocument(t, e)
                    }, e.removeDocument = function (t) {
                        this.scope.removeDocument(t)
                    }, e
                };
                var vn = {};

                function yn(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                }

                function xn(t, e, n) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }

                Object.defineProperty(vn, "__esModule", {value: !0}), vn.Interactable = void 0;
                var _n = function () {
                    function t(n, i, r, o) {
                        !function (t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), xn(this, "options", void 0), xn(this, "_actions", void 0), xn(this, "target", void 0), xn(this, "events", new un.Eventable), xn(this, "_context", void 0), xn(this, "_win", void 0), xn(this, "_doc", void 0), xn(this, "_scopeEvents", void 0), xn(this, "_rectChecker", void 0), this._actions = i.actions, this.target = n, this._context = i.context || r, this._win = (0, e.getWindow)((0, w.trySelector)(n) ? this._context : n), this._doc = this._win.document, this._scopeEvents = o, this.set(i)
                    }

                    var n;
                    return (n = [{
                        key: "_defaults", get: function () {
                            return {base: {}, perAction: {}, actions: {}}
                        }
                    }, {
                        key: "setOnEvents", value: function (t, e) {
                            return o.default.func(e.onstart) && this.on("".concat(t, "start"), e.onstart), o.default.func(e.onmove) && this.on("".concat(t, "move"), e.onmove), o.default.func(e.onend) && this.on("".concat(t, "end"), e.onend), o.default.func(e.oninertiastart) && this.on("".concat(t, "inertiastart"), e.oninertiastart), this
                        }
                    }, {
                        key: "updatePerActionListeners", value: function (t, e, n) {
                            (o.default.array(e) || o.default.object(e)) && this.off(t, e), (o.default.array(n) || o.default.object(n)) && this.on(t, n)
                        }
                    }, {
                        key: "setPerAction", value: function (t, e) {
                            var n = this._defaults;
                            for (var i in e) {
                                var r = i, s = this.options[t], a = e[r];
                                "listeners" === r && this.updatePerActionListeners(t, s.listeners, a), o.default.array(a) ? s[r] = Q.from(a) : o.default.plainObject(a) ? (s[r] = (0, L.default)(s[r] || {}, (0, ge.default)(a)), o.default.object(n.perAction[r]) && "enabled" in n.perAction[r] && (s[r].enabled = !1 !== a.enabled)) : o.default.bool(a) && o.default.object(n.perAction[r]) ? s[r].enabled = a : s[r] = a
                            }
                        }
                    }, {
                        key: "getRect", value: function (t) {
                            return t = t || (o.default.element(this.target) ? this.target : null), o.default.string(this.target) && (t = t || this._context.querySelector(this.target)), (0, w.getElementRect)(t)
                        }
                    }, {
                        key: "rectChecker", value: function (t) {
                            var e = this;
                            return o.default.func(t) ? (this._rectChecker = t, this.getRect = function (t) {
                                var n = (0, L.default)({}, e._rectChecker(t));
                                return "width" in n || (n.width = n.right - n.left, n.height = n.bottom - n.top), n
                            }, this) : null === t ? (delete this.getRect, delete this._rectChecker, this) : this.getRect
                        }
                    }, {
                        key: "_backCompatOption", value: function (t, e) {
                            if ((0, w.trySelector)(e) || o.default.object(e)) {
                                for (var n in this.options[t] = e, this._actions.map) this.options[n][t] = e;
                                return this
                            }
                            return this.options[t]
                        }
                    }, {
                        key: "origin", value: function (t) {
                            return this._backCompatOption("origin", t)
                        }
                    }, {
                        key: "deltaSource", value: function (t) {
                            return "page" === t || "client" === t ? (this.options.deltaSource = t, this) : this.options.deltaSource
                        }
                    }, {
                        key: "context", value: function () {
                            return this._context
                        }
                    }, {
                        key: "inContext", value: function (t) {
                            return this._context === t.ownerDocument || (0, w.nodeContains)(this._context, t)
                        }
                    }, {
                        key: "testIgnoreAllow", value: function (t, e, n) {
                            return !this.testIgnore(t.ignoreFrom, e, n) && this.testAllow(t.allowFrom, e, n)
                        }
                    }, {
                        key: "testAllow", value: function (t, e, n) {
                            return !t || !!o.default.element(n) && (o.default.string(t) ? (0, w.matchesUpTo)(n, t, e) : !!o.default.element(t) && (0, w.nodeContains)(t, n))
                        }
                    }, {
                        key: "testIgnore", value: function (t, e, n) {
                            return !(!t || !o.default.element(n)) && (o.default.string(t) ? (0, w.matchesUpTo)(n, t, e) : !!o.default.element(t) && (0, w.nodeContains)(t, n))
                        }
                    }, {
                        key: "fire", value: function (t) {
                            return this.events.fire(t), this
                        }
                    }, {
                        key: "_onOff", value: function (t, e, n, i) {
                            o.default.object(e) && !o.default.array(e) && (i = n, n = null);
                            var r = "on" === t ? "add" : "remove", s = (0, D.default)(e, n);
                            for (var a in s) {
                                "wheel" === a && (a = x.default.wheelEvent);
                                for (var l = 0; l < s[a].length; l++) {
                                    var c = s[a][l];
                                    (0, mn.default)(a, this._actions) ? this.events[t](a, c) : o.default.string(this.target) ? this._scopeEvents["".concat(r, "Delegate")](this.target, this._context, a, c, i) : this._scopeEvents[r](this.target, a, c, i)
                                }
                            }
                            return this
                        }
                    }, {
                        key: "on", value: function (t, e, n) {
                            return this._onOff("on", t, e, n)
                        }
                    }, {
                        key: "off", value: function (t, e, n) {
                            return this._onOff("off", t, e, n)
                        }
                    }, {
                        key: "set", value: function (t) {
                            var e = this._defaults;
                            for (var n in o.default.object(t) || (t = {}), this.options = (0, ge.default)(e.base), this._actions.methodDict) {
                                var i = n, r = this._actions.methodDict[i];
                                this.options[i] = {}, this.setPerAction(i, (0, L.default)((0, L.default)({}, e.perAction), e.actions[i])), this[r](t[i])
                            }
                            for (var s in t) o.default.func(this[s]) && this[s](t[s]);
                            return this
                        }
                    }, {
                        key: "unset", value: function () {
                            if (o.default.string(this.target)) for (var t in this._scopeEvents.delegatedEvents) for (var e = this._scopeEvents.delegatedEvents[t], n = e.length - 1; n >= 0; n--) {
                                var i = e[n], r = i.selector, s = i.context, a = i.listeners;
                                r === this.target && s === this._context && e.splice(n, 1);
                                for (var l = a.length - 1; l >= 0; l--) this._scopeEvents.removeDelegate(this.target, this._context, t, a[l][0], a[l][1])
                            } else this._scopeEvents.remove(this.target, "all")
                        }
                    }]) && yn(t.prototype, n), t
                }();
                vn.Interactable = _n;
                var bn = {};

                function wn(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                }

                function Sn(t, e, n) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }

                Object.defineProperty(bn, "__esModule", {value: !0}), bn.InteractableSet = void 0;
                var Mn = function () {
                    function t(e) {
                        var n = this;
                        !function (t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), Sn(this, "list", []), Sn(this, "selectorMap", {}), Sn(this, "scope", void 0), this.scope = e, e.addListeners({
                            "interactable:unset": function (t) {
                                var e = t.interactable, i = e.target, r = e._context,
                                    s = o.default.string(i) ? n.selectorMap[i] : i[n.scope.id],
                                    a = Q.findIndex(s, (function (t) {
                                        return t.context === r
                                    }));
                                s[a] && (s[a].context = null, s[a].interactable = null), s.splice(a, 1)
                            }
                        })
                    }

                    var e;
                    return (e = [{
                        key: "new", value: function (t, e) {
                            e = (0, L.default)(e || {}, {actions: this.scope.actions});
                            var n = new this.scope.Interactable(t, e, this.scope.document, this.scope.events),
                                i = {context: n._context, interactable: n};
                            return this.scope.addDocument(n._doc), this.list.push(n), o.default.string(t) ? (this.selectorMap[t] || (this.selectorMap[t] = []), this.selectorMap[t].push(i)) : (n.target[this.scope.id] || Object.defineProperty(t, this.scope.id, {
                                value: [],
                                configurable: !0
                            }), t[this.scope.id].push(i)), this.scope.fire("interactable:new", {
                                target: t,
                                options: e,
                                interactable: n,
                                win: this.scope._win
                            }), n
                        }
                    }, {
                        key: "get", value: function (t, e) {
                            var n = e && e.context || this.scope.document, i = o.default.string(t),
                                r = i ? this.selectorMap[t] : t[this.scope.id];
                            if (!r) return null;
                            var s = Q.find(r, (function (e) {
                                return e.context === n && (i || e.interactable.inContext(t))
                            }));
                            return s && s.interactable
                        }
                    }, {
                        key: "forEachMatch", value: function (t, e) {
                            for (var n = 0; n < this.list.length; n++) {
                                var i = this.list[n], r = void 0;
                                if ((o.default.string(i.target) ? o.default.element(t) && w.matchesSelector(t, i.target) : t === i.target) && i.inContext(t) && (r = e(i)), void 0 !== r) return r
                            }
                        }
                    }]) && wn(t.prototype, e), t
                }();
                bn.InteractableSet = Mn;
                var Tn = {};

                function En(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                }

                function An(t, e, n) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }

                function Pn(t, e) {
                    return function (t) {
                        if (Array.isArray(t)) return t
                    }(t) || function (t, e) {
                        if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) {
                            var n = [], i = !0, r = !1, o = void 0;
                            try {
                                for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); i = !0) ;
                            } catch (t) {
                                r = !0, o = t
                            } finally {
                                try {
                                    i || null == a.return || a.return()
                                } finally {
                                    if (r) throw o
                                }
                            }
                            return n
                        }
                    }(t, e) || function (t, e) {
                        if (t) {
                            if ("string" == typeof t) return Ln(t, e);
                            var n = Object.prototype.toString.call(t).slice(8, -1);
                            return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Ln(t, e) : void 0
                        }
                    }(t, e) || function () {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function Ln(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var n = 0, i = Array(e); n < e; n++) i[n] = t[n];
                    return i
                }

                Object.defineProperty(Tn, "__esModule", {value: !0}), Tn.default = void 0;
                var Cn = function () {
                    function t(e) {
                        !function (t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), An(this, "currentTarget", void 0), An(this, "originalEvent", void 0), An(this, "type", void 0), this.originalEvent = e, (0, N.default)(this, e)
                    }

                    var e;
                    return (e = [{
                        key: "preventOriginalDefault", value: function () {
                            this.originalEvent.preventDefault()
                        }
                    }, {
                        key: "stopPropagation", value: function () {
                            this.originalEvent.stopPropagation()
                        }
                    }, {
                        key: "stopImmediatePropagation", value: function () {
                            this.originalEvent.stopImmediatePropagation()
                        }
                    }]) && En(t.prototype, e), t
                }();

                function Rn(t) {
                    if (!o.default.object(t)) return {capture: !!t, passive: !1};
                    var e = (0, L.default)({}, t);
                    return e.capture = !!t.capture, e.passive = !!t.passive, e
                }

                var In = {
                    id: "events", install: function (t) {
                        var e, n = [], i = {}, r = [], s = {
                            add: a,
                            remove: l,
                            addDelegate: function (t, e, n, o, s) {
                                var l = Rn(s);
                                if (!i[n]) {
                                    i[n] = [];
                                    for (var h = 0; h < r.length; h++) {
                                        var d = r[h];
                                        a(d, n, c), a(d, n, u, !0)
                                    }
                                }
                                var p = i[n], f = Q.find(p, (function (n) {
                                    return n.selector === t && n.context === e
                                }));
                                f || (f = {selector: t, context: e, listeners: []}, p.push(f)), f.listeners.push([o, l])
                            },
                            removeDelegate: function (t, e, n, r, o) {
                                var s, a = Rn(o), h = i[n], d = !1;
                                if (h) for (s = h.length - 1; s >= 0; s--) {
                                    var p = h[s];
                                    if (p.selector === t && p.context === e) {
                                        for (var f = p.listeners, m = f.length - 1; m >= 0; m--) {
                                            var g = Pn(f[m], 2), v = g[0], y = g[1], x = y.capture, _ = y.passive;
                                            if (v === r && x === a.capture && _ === a.passive) {
                                                f.splice(m, 1), f.length || (h.splice(s, 1), l(e, n, c), l(e, n, u, !0)), d = !0;
                                                break
                                            }
                                        }
                                        if (d) break
                                    }
                                }
                            },
                            delegateListener: c,
                            delegateUseCapture: u,
                            delegatedEvents: i,
                            documents: r,
                            targets: n,
                            supportsOptions: !1,
                            supportsPassive: !1
                        };

                        function a(t, e, i, r) {
                            var o = Rn(r), a = Q.find(n, (function (e) {
                                return e.eventTarget === t
                            }));
                            a || (a = {
                                eventTarget: t,
                                events: {}
                            }, n.push(a)), a.events[e] || (a.events[e] = []), t.addEventListener && !Q.contains(a.events[e], i) && (t.addEventListener(e, i, s.supportsOptions ? o : o.capture), a.events[e].push(i))
                        }

                        function l(t, e, i, r) {
                            var o = Rn(r), a = Q.findIndex(n, (function (e) {
                                return e.eventTarget === t
                            })), c = n[a];
                            if (c && c.events) if ("all" !== e) {
                                var u = !1, h = c.events[e];
                                if (h) {
                                    if ("all" === i) {
                                        for (var d = h.length - 1; d >= 0; d--) l(t, e, h[d], o);
                                        return
                                    }
                                    for (var p = 0; p < h.length; p++) if (h[p] === i) {
                                        t.removeEventListener(e, i, s.supportsOptions ? o : o.capture), h.splice(p, 1), 0 === h.length && (delete c.events[e], u = !0);
                                        break
                                    }
                                }
                                u && !Object.keys(c.events).length && n.splice(a, 1)
                            } else for (e in c.events) c.events.hasOwnProperty(e) && l(t, e, "all")
                        }

                        function c(t, e) {
                            for (var n = Rn(e), r = new Cn(t), s = i[t.type], a = Pn(U.getEventTargets(t), 1)[0], l = a; o.default.element(l);) {
                                for (var c = 0; c < s.length; c++) {
                                    var u = s[c], h = u.selector, d = u.context;
                                    if (w.matchesSelector(l, h) && w.nodeContains(d, a) && w.nodeContains(d, l)) {
                                        var p = u.listeners;
                                        r.currentTarget = l;
                                        for (var f = 0; f < p.length; f++) {
                                            var m = Pn(p[f], 2), g = m[0], v = m[1], y = v.capture, x = v.passive;
                                            y === n.capture && x === n.passive && g(r)
                                        }
                                    }
                                }
                                l = w.parentNode(l)
                            }
                        }

                        function u(t) {
                            return c(t, !0)
                        }

                        return null == (e = t.document) || e.createElement("div").addEventListener("test", null, {
                            get capture() {
                                return s.supportsOptions = !0
                            }, get passive() {
                                return s.supportsPassive = !0
                            }
                        }), t.events = s, s
                    }
                };
                Tn.default = In;
                var On = {};
                Object.defineProperty(On, "__esModule", {value: !0}), On.default = void 0;
                var Dn = {
                    methodOrder: ["simulationResume", "mouseOrPen", "hasPointer", "idle"], search: function (t) {
                        for (var e = 0; e < Dn.methodOrder.length; e++) {
                            var n;
                            n = Dn.methodOrder[e];
                            var i = Dn[n](t);
                            if (i) return i
                        }
                        return null
                    }, simulationResume: function (t) {
                        var e = t.pointerType, n = t.eventType, i = t.eventTarget, r = t.scope;
                        if (!/down|start/i.test(n)) return null;
                        for (var o = 0; o < r.interactions.list.length; o++) {
                            var s = r.interactions.list[o], a = i;
                            if (s.simulation && s.simulation.allowResume && s.pointerType === e) for (; a;) {
                                if (a === s.element) return s;
                                a = w.parentNode(a)
                            }
                        }
                        return null
                    }, mouseOrPen: function (t) {
                        var e, n = t.pointerId, i = t.pointerType, r = t.eventType, o = t.scope;
                        if ("mouse" !== i && "pen" !== i) return null;
                        for (var s = 0; s < o.interactions.list.length; s++) {
                            var a = o.interactions.list[s];
                            if (a.pointerType === i) {
                                if (a.simulation && !zn(a, n)) continue;
                                if (a.interacting()) return a;
                                e || (e = a)
                            }
                        }
                        if (e) return e;
                        for (var l = 0; l < o.interactions.list.length; l++) {
                            var c = o.interactions.list[l];
                            if (!(c.pointerType !== i || /down/i.test(r) && c.simulation)) return c
                        }
                        return null
                    }, hasPointer: function (t) {
                        for (var e = t.pointerId, n = t.scope, i = 0; i < n.interactions.list.length; i++) {
                            var r = n.interactions.list[i];
                            if (zn(r, e)) return r
                        }
                        return null
                    }, idle: function (t) {
                        for (var e = t.pointerType, n = t.scope, i = 0; i < n.interactions.list.length; i++) {
                            var r = n.interactions.list[i];
                            if (1 === r.pointers.length) {
                                var o = r.interactable;
                                if (o && (!o.options.gesture || !o.options.gesture.enabled)) continue
                            } else if (r.pointers.length >= 2) continue;
                            if (!r.interacting() && e === r.pointerType) return r
                        }
                        return null
                    }
                };

                function zn(t, e) {
                    return t.pointers.some((function (t) {
                        return t.id === e
                    }))
                }

                var kn = Dn;
                On.default = kn;
                var Nn = {};

                function Bn(t) {
                    return (Bn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                        return typeof t
                    } : function (t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    })(t)
                }

                function Fn(t, e) {
                    return function (t) {
                        if (Array.isArray(t)) return t
                    }(t) || function (t, e) {
                        if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) {
                            var n = [], i = !0, r = !1, o = void 0;
                            try {
                                for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); i = !0) ;
                            } catch (t) {
                                r = !0, o = t
                            } finally {
                                try {
                                    i || null == a.return || a.return()
                                } finally {
                                    if (r) throw o
                                }
                            }
                            return n
                        }
                    }(t, e) || function (t, e) {
                        if (t) {
                            if ("string" == typeof t) return Un(t, e);
                            var n = Object.prototype.toString.call(t).slice(8, -1);
                            return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Un(t, e) : void 0
                        }
                    }(t, e) || function () {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function Un(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var n = 0, i = Array(e); n < e; n++) i[n] = t[n];
                    return i
                }

                function Hn(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }

                function Vn(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                }

                function Gn(t, e) {
                    return (Gn = Object.setPrototypeOf || function (t, e) {
                        return t.__proto__ = e, t
                    })(t, e)
                }

                function Wn(t, e) {
                    return !e || "object" !== Bn(e) && "function" != typeof e ? function (t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t) : e
                }

                function jn(t) {
                    return (jn = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    })(t)
                }

                Object.defineProperty(Nn, "__esModule", {value: !0}), Nn.default = void 0;
                var qn = ["pointerDown", "pointerMove", "pointerUp", "updatePointer", "removePointer", "windowBlur"];

                function Xn(t, e) {
                    return function (n) {
                        var i = e.interactions.list, r = U.getPointerType(n), o = Fn(U.getEventTargets(n), 2), s = o[0],
                            a = o[1], l = [];
                        if (/^touch/.test(n.type)) {
                            e.prevTouchTime = e.now();
                            for (var c = 0; c < n.changedTouches.length; c++) {
                                var u = n.changedTouches[c], h = {
                                    pointer: u,
                                    pointerId: U.getPointerId(u),
                                    pointerType: r,
                                    eventType: n.type,
                                    eventTarget: s,
                                    curEventTarget: a,
                                    scope: e
                                }, d = Yn(h);
                                l.push([h.pointer, h.eventTarget, h.curEventTarget, d])
                            }
                        } else {
                            var p = !1;
                            if (!x.default.supportsPointerEvent && /mouse/.test(n.type)) {
                                for (var f = 0; f < i.length && !p; f++) p = "mouse" !== i[f].pointerType && i[f].pointerIsDown;
                                p = p || e.now() - e.prevTouchTime < 500 || 0 === n.timeStamp
                            }
                            if (!p) {
                                var m = {
                                    pointer: n,
                                    pointerId: U.getPointerId(n),
                                    pointerType: r,
                                    eventType: n.type,
                                    curEventTarget: a,
                                    eventTarget: s,
                                    scope: e
                                }, g = Yn(m);
                                l.push([m.pointer, m.eventTarget, m.curEventTarget, g])
                            }
                        }
                        for (var v = 0; v < l.length; v++) {
                            var y = Fn(l[v], 4), _ = y[0], b = y[1], w = y[2];
                            y[3][t](_, n, b, w)
                        }
                    }
                }

                function Yn(t) {
                    var e = t.pointerType, n = t.scope, i = {interaction: On.default.search(t), searchDetails: t};
                    return n.fire("interactions:find", i), i.interaction || n.interactions.new({pointerType: e})
                }

                function Jn(t, e) {
                    var n = t.doc, i = t.scope, r = t.options, o = i.interactions.docEvents, s = i.events, a = s[e];
                    for (var l in i.browser.isIOS && !r.events && (r.events = {passive: !1}), s.delegatedEvents) a(n, l, s.delegateListener), a(n, l, s.delegateUseCapture, !0);
                    for (var c = r && r.events, u = 0; u < o.length; u++) {
                        var h = o[u];
                        a(n, h.type, h.listener, c)
                    }
                }

                var Zn = {
                    id: "core/interactions", install: function (t) {
                        for (var e = {}, n = 0; n < qn.length; n++) {
                            var i = qn[n];
                            e[i] = Xn(i, t)
                        }
                        var r, o = x.default.pEventTypes;

                        function s() {
                            for (var e = 0; e < t.interactions.list.length; e++) {
                                var n = t.interactions.list[e];
                                if (n.pointerIsDown && "touch" === n.pointerType && !n._interacting) for (var i = function () {
                                    var e = n.pointers[r];
                                    t.documents.some((function (t) {
                                        var n = t.doc;
                                        return (0, w.nodeContains)(n, e.downTarget)
                                    })) || n.removePointer(e.pointer, e.event)
                                }, r = 0; r < n.pointers.length; r++) i()
                            }
                        }

                        (r = m.default.PointerEvent ? [{type: o.down, listener: s}, {
                            type: o.down,
                            listener: e.pointerDown
                        }, {type: o.move, listener: e.pointerMove}, {
                            type: o.up,
                            listener: e.pointerUp
                        }, {type: o.cancel, listener: e.pointerUp}] : [{
                            type: "mousedown",
                            listener: e.pointerDown
                        }, {type: "mousemove", listener: e.pointerMove}, {
                            type: "mouseup",
                            listener: e.pointerUp
                        }, {type: "touchstart", listener: s}, {
                            type: "touchstart",
                            listener: e.pointerDown
                        }, {type: "touchmove", listener: e.pointerMove}, {
                            type: "touchend",
                            listener: e.pointerUp
                        }, {type: "touchcancel", listener: e.pointerUp}]).push({
                            type: "blur", listener: function (e) {
                                for (var n = 0; n < t.interactions.list.length; n++) t.interactions.list[n].documentBlur(e)
                            }
                        }), t.prevTouchTime = 0, t.Interaction = function (e) {
                            !function (t, e) {
                                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                                t.prototype = Object.create(e && e.prototype, {
                                    constructor: {
                                        value: t,
                                        writable: !0,
                                        configurable: !0
                                    }
                                }), e && Gn(t, e)
                            }(s, e);
                            var n, i, r, o = (i = s, r = function () {
                                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                                if (Reflect.construct.sham) return !1;
                                if ("function" == typeof Proxy) return !0;
                                try {
                                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
                                    }))), !0
                                } catch (t) {
                                    return !1
                                }
                            }(), function () {
                                var t, e = jn(i);
                                if (r) {
                                    var n = jn(this).constructor;
                                    t = Reflect.construct(e, arguments, n)
                                } else t = e.apply(this, arguments);
                                return Wn(this, t)
                            });

                            function s() {
                                return Hn(this, s), o.apply(this, arguments)
                            }

                            return (n = [{
                                key: "pointerMoveTolerance", get: function () {
                                    return t.interactions.pointerMoveTolerance
                                }, set: function (e) {
                                    t.interactions.pointerMoveTolerance = e
                                }
                            }, {
                                key: "_now", value: function () {
                                    return t.now()
                                }
                            }]) && Vn(s.prototype, n), s
                        }(Ve.default), t.interactions = {
                            list: [], new: function (e) {
                                e.scopeFire = function (e, n) {
                                    return t.fire(e, n)
                                };
                                var n = new t.Interaction(e);
                                return t.interactions.list.push(n), n
                            }, listeners: e, docEvents: r, pointerMoveTolerance: 1
                        }, t.usePlugin(ae.default)
                    }, listeners: {
                        "scope:add-document": function (t) {
                            return Jn(t, "add")
                        }, "scope:remove-document": function (t) {
                            return Jn(t, "remove")
                        }, "interactable:unset": function (t, e) {
                            for (var n = t.interactable, i = e.interactions.list.length - 1; i >= 0; i--) {
                                var r = e.interactions.list[i];
                                r.interactable === n && (r.stop(), e.fire("interactions:destroy", {interaction: r}), r.destroy(), e.interactions.list.length > 2 && e.interactions.list.splice(i, 1))
                            }
                        }
                    }, onDocSignal: Jn, doOnInteractions: Xn, methodNames: qn
                };
                Nn.default = Zn;
                var Qn = {};

                function Kn(t) {
                    return (Kn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                        return typeof t
                    } : function (t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    })(t)
                }

                function $n(t, e, n) {
                    return ($n = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
                        var i = function (t, e) {
                            for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = ni(t));) ;
                            return t
                        }(t, e);
                        if (i) {
                            var r = Object.getOwnPropertyDescriptor(i, e);
                            return r.get ? r.get.call(n) : r.value
                        }
                    })(t, e, n || t)
                }

                function ti(t, e) {
                    return (ti = Object.setPrototypeOf || function (t, e) {
                        return t.__proto__ = e, t
                    })(t, e)
                }

                function ei(t, e) {
                    return !e || "object" !== Kn(e) && "function" != typeof e ? function (t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t) : e
                }

                function ni(t) {
                    return (ni = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    })(t)
                }

                function ii(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }

                function ri(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                }

                function oi(t, e, n) {
                    return e && ri(t.prototype, e), n && ri(t, n), t
                }

                function si(t, e, n) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }

                Object.defineProperty(Qn, "__esModule", {value: !0}), Qn.initScope = li, Qn.Scope = void 0;
                var ai = function () {
                    function t() {
                        var e = this;
                        ii(this, t), si(this, "id", "__interact_scope_".concat(Math.floor(100 * Math.random()))), si(this, "isInitialized", !1), si(this, "listenerMaps", []), si(this, "browser", x.default), si(this, "defaults", (0, ge.default)(Pe.defaults)), si(this, "Eventable", un.Eventable), si(this, "actions", {
                            map: {},
                            phases: {start: !0, move: !0, end: !0},
                            methodDict: {},
                            phaselessTypes: {}
                        }), si(this, "interactStatic", (0, gn.createInteractStatic)(this)), si(this, "InteractEvent", Le.InteractEvent), si(this, "Interactable", void 0), si(this, "interactables", new bn.InteractableSet(this)), si(this, "_win", void 0), si(this, "document", void 0), si(this, "window", void 0), si(this, "documents", []), si(this, "_plugins", {
                            list: [],
                            map: {}
                        }), si(this, "onWindowUnload", (function (t) {
                            return e.removeDocument(t.target)
                        }));
                        var n = this;
                        this.Interactable = function (t) {
                            !function (t, e) {
                                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                                t.prototype = Object.create(e && e.prototype, {
                                    constructor: {
                                        value: t,
                                        writable: !0,
                                        configurable: !0
                                    }
                                }), e && ti(t, e)
                            }(o, t);
                            var e, i, r = (e = o, i = function () {
                                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                                if (Reflect.construct.sham) return !1;
                                if ("function" == typeof Proxy) return !0;
                                try {
                                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
                                    }))), !0
                                } catch (t) {
                                    return !1
                                }
                            }(), function () {
                                var t, n = ni(e);
                                if (i) {
                                    var r = ni(this).constructor;
                                    t = Reflect.construct(n, arguments, r)
                                } else t = n.apply(this, arguments);
                                return ei(this, t)
                            });

                            function o() {
                                return ii(this, o), r.apply(this, arguments)
                            }

                            return oi(o, [{
                                key: "_defaults", get: function () {
                                    return n.defaults
                                }
                            }, {
                                key: "set", value: function (t) {
                                    return $n(ni(o.prototype), "set", this).call(this, t), n.fire("interactable:set", {
                                        options: t,
                                        interactable: this
                                    }), this
                                }
                            }, {
                                key: "unset", value: function () {
                                    $n(ni(o.prototype), "unset", this).call(this), n.interactables.list.splice(n.interactables.list.indexOf(this), 1), n.fire("interactable:unset", {interactable: this})
                                }
                            }]), o
                        }(vn.Interactable)
                    }

                    return oi(t, [{
                        key: "addListeners", value: function (t, e) {
                            this.listenerMaps.push({id: e, map: t})
                        }
                    }, {
                        key: "fire", value: function (t, e) {
                            for (var n = 0; n < this.listenerMaps.length; n++) {
                                var i = this.listenerMaps[n].map[t];
                                if (i && !1 === i(e, this, t)) return !1
                            }
                        }
                    }, {
                        key: "init", value: function (t) {
                            return this.isInitialized ? this : li(this, t)
                        }
                    }, {
                        key: "pluginIsInstalled", value: function (t) {
                            return this._plugins.map[t.id] || -1 !== this._plugins.list.indexOf(t)
                        }
                    }, {
                        key: "usePlugin", value: function (t, e) {
                            if (!this.isInitialized) return this;
                            if (this.pluginIsInstalled(t)) return this;
                            if (t.id && (this._plugins.map[t.id] = t), this._plugins.list.push(t), t.install && t.install(this, e), t.listeners && t.before) {
                                for (var n = 0, i = this.listenerMaps.length, r = t.before.reduce((function (t, e) {
                                    return t[e] = !0, t[ci(e)] = !0, t
                                }), {}); n < i; n++) {
                                    var o = this.listenerMaps[n].id;
                                    if (r[o] || r[ci(o)]) break
                                }
                                this.listenerMaps.splice(n, 0, {id: t.id, map: t.listeners})
                            } else t.listeners && this.listenerMaps.push({id: t.id, map: t.listeners});
                            return this
                        }
                    }, {
                        key: "addDocument", value: function (t, n) {
                            if (-1 !== this.getDocIndex(t)) return !1;
                            var i = e.getWindow(t);
                            n = n ? (0, L.default)({}, n) : {}, this.documents.push({
                                doc: t,
                                options: n
                            }), this.events.documents.push(t), t !== this.document && this.events.add(i, "unload", this.onWindowUnload), this.fire("scope:add-document", {
                                doc: t,
                                window: i,
                                scope: this,
                                options: n
                            })
                        }
                    }, {
                        key: "removeDocument", value: function (t) {
                            var n = this.getDocIndex(t), i = e.getWindow(t), r = this.documents[n].options;
                            this.events.remove(i, "unload", this.onWindowUnload), this.documents.splice(n, 1), this.events.documents.splice(n, 1), this.fire("scope:remove-document", {
                                doc: t,
                                window: i,
                                scope: this,
                                options: r
                            })
                        }
                    }, {
                        key: "getDocIndex", value: function (t) {
                            for (var e = 0; e < this.documents.length; e++) if (this.documents[e].doc === t) return e;
                            return -1
                        }
                    }, {
                        key: "getDocOptions", value: function (t) {
                            var e = this.getDocIndex(t);
                            return -1 === e ? null : this.documents[e].options
                        }
                    }, {
                        key: "now", value: function () {
                            return (this.window.Date || Date).now()
                        }
                    }]), t
                }();

                function li(t, n) {
                    return t.isInitialized = !0, o.default.window(n) && e.init(n), m.default.init(n), x.default.init(n), Lt.default.init(n), t.window = n, t.document = n.document, t.usePlugin(Nn.default), t.usePlugin(Tn.default), t
                }

                function ci(t) {
                    return t && t.replace(/\/.*$/, "")
                }

                Qn.Scope = ai;
                var ui = {};
                Object.defineProperty(ui, "__esModule", {value: !0}), ui.default = void 0;
                var hi = new Qn.Scope, di = hi.interactStatic;
                ui.default = di;
                var pi = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0;
                hi.init(pi);
                var fi = {};
                Object.defineProperty(fi, "__esModule", {value: !0}), fi.default = void 0, fi.default = function () {
                };
                var mi = {};
                Object.defineProperty(mi, "__esModule", {value: !0}), mi.default = void 0, mi.default = function () {
                };
                var gi = {};

                function vi(t, e) {
                    return function (t) {
                        if (Array.isArray(t)) return t
                    }(t) || function (t, e) {
                        if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) {
                            var n = [], i = !0, r = !1, o = void 0;
                            try {
                                for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); i = !0) ;
                            } catch (t) {
                                r = !0, o = t
                            } finally {
                                try {
                                    i || null == a.return || a.return()
                                } finally {
                                    if (r) throw o
                                }
                            }
                            return n
                        }
                    }(t, e) || function (t, e) {
                        if (t) {
                            if ("string" == typeof t) return yi(t, e);
                            var n = Object.prototype.toString.call(t).slice(8, -1);
                            return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? yi(t, e) : void 0
                        }
                    }(t, e) || function () {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function yi(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var n = 0, i = Array(e); n < e; n++) i[n] = t[n];
                    return i
                }

                Object.defineProperty(gi, "__esModule", {value: !0}), gi.default = void 0, gi.default = function (t) {
                    var e = [["x", "y"], ["left", "top"], ["right", "bottom"], ["width", "height"]].filter((function (e) {
                        var n = vi(e, 2), i = n[0], r = n[1];
                        return i in t || r in t
                    })), n = function (n, i) {
                        for (var r = t.range, o = t.limits, s = void 0 === o ? {
                            left: -1 / 0,
                            right: 1 / 0,
                            top: -1 / 0,
                            bottom: 1 / 0
                        } : o, a = t.offset, l = void 0 === a ? {x: 0, y: 0} : a, c = {
                            range: r,
                            grid: t,
                            x: null,
                            y: null
                        }, u = 0; u < e.length; u++) {
                            var h = vi(e[u], 2), d = h[0], p = h[1], f = Math.round((n - l.x) / t[d]),
                                m = Math.round((i - l.y) / t[p]);
                            c[d] = Math.max(s.left, Math.min(s.right, f * t[d] + l.x)), c[p] = Math.max(s.top, Math.min(s.bottom, m * t[p] + l.y))
                        }
                        return c
                    };
                    return n.grid = t, n.coordFields = e, n
                };
                var xi = {};
                Object.defineProperty(xi, "__esModule", {value: !0}), Object.defineProperty(xi, "edgeTarget", {
                    enumerable: !0,
                    get: function () {
                        return fi.default
                    }
                }), Object.defineProperty(xi, "elements", {
                    enumerable: !0, get: function () {
                        return mi.default
                    }
                }), Object.defineProperty(xi, "grid", {
                    enumerable: !0, get: function () {
                        return gi.default
                    }
                });
                var _i = {};
                Object.defineProperty(_i, "__esModule", {value: !0}), _i.default = void 0;
                var bi = {
                    id: "snappers", install: function (t) {
                        var e = t.interactStatic;
                        e.snappers = (0, L.default)(e.snappers || {}, xi), e.createSnapGrid = e.snappers.grid
                    }
                };
                _i.default = bi;
                var wi = {};

                function Si(t, e) {
                    var n = Object.keys(t);
                    if (Object.getOwnPropertySymbols) {
                        var i = Object.getOwnPropertySymbols(t);
                        e && (i = i.filter((function (e) {
                            return Object.getOwnPropertyDescriptor(t, e).enumerable
                        }))), n.push.apply(n, i)
                    }
                    return n
                }

                function Mi(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var n = null != arguments[e] ? arguments[e] : {};
                        e % 2 ? Si(Object(n), !0).forEach((function (e) {
                            Ti(t, e, n[e])
                        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Si(Object(n)).forEach((function (e) {
                            Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                        }))
                    }
                    return t
                }

                function Ti(t, e, n) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }

                Object.defineProperty(wi, "__esModule", {value: !0}), wi.aspectRatio = wi.default = void 0;
                var Ei = {
                    start: function (t) {
                        var e = t.state, n = t.rect, i = t.edges, r = t.pageCoords, o = e.options.ratio, s = e.options,
                            a = s.equalDelta, l = s.modifiers;
                        "preserve" === o && (o = n.width / n.height), e.startCoords = (0, L.default)({}, r), e.startRect = (0, L.default)({}, n), e.ratio = o, e.equalDelta = a;
                        var c = e.linkedEdges = {
                            top: i.top || i.left && !i.bottom,
                            left: i.left || i.top && !i.right,
                            bottom: i.bottom || i.right && !i.top,
                            right: i.right || i.bottom && !i.left
                        };
                        if (e.xIsPrimaryAxis = !(!i.left && !i.right), e.equalDelta) e.edgeSign = (c.left ? 1 : -1) * (c.top ? 1 : -1); else {
                            var u = e.xIsPrimaryAxis ? c.top : c.left;
                            e.edgeSign = u ? -1 : 1
                        }
                        if ((0, L.default)(t.edges, c), l && l.length) {
                            var h = new ve.default(t.interaction);
                            h.copyFrom(t.interaction.modification), h.prepareStates(l), e.subModification = h, h.startAll(Mi({}, t))
                        }
                    }, set: function (t) {
                        var e = t.state, n = t.rect, i = t.coords, r = (0, L.default)({}, i),
                            o = e.equalDelta ? Ai : Pi;
                        if (o(e, e.xIsPrimaryAxis, i, n), !e.subModification) return null;
                        var s = (0, L.default)({}, n);
                        (0, C.addEdges)(e.linkedEdges, s, {x: i.x - r.x, y: i.y - r.y});
                        var a = e.subModification.setAll(Mi(Mi({}, t), {}, {
                            rect: s,
                            edges: e.linkedEdges,
                            pageCoords: i,
                            prevCoords: i,
                            prevRect: s
                        })), l = a.delta;
                        return a.changed && (o(e, Math.abs(l.x) > Math.abs(l.y), a.coords, a.rect), (0, L.default)(i, a.coords)), a.eventProps
                    }, defaults: {ratio: "preserve", equalDelta: !1, modifiers: [], enabled: !1}
                };

                function Ai(t, e, n) {
                    var i = t.startCoords, r = t.edgeSign;
                    e ? n.y = i.y + (n.x - i.x) * r : n.x = i.x + (n.y - i.y) * r
                }

                function Pi(t, e, n, i) {
                    var r = t.startRect, o = t.startCoords, s = t.ratio, a = t.edgeSign;
                    if (e) {
                        var l = i.width / s;
                        n.y = o.y + (l - r.height) * a
                    } else {
                        var c = i.height * s;
                        n.x = o.x + (c - r.width) * a
                    }
                }

                wi.aspectRatio = Ei;
                var Li = (0, Te.makeModifier)(Ei, "aspectRatio");
                wi.default = Li;
                var Ci = {};
                Object.defineProperty(Ci, "__esModule", {value: !0}), Ci.default = void 0;
                var Ri = function () {
                };
                Ri._defaults = {};
                var Ii = Ri;
                Ci.default = Ii;
                var Oi = {};
                Object.defineProperty(Oi, "__esModule", {value: !0}), Object.defineProperty(Oi, "default", {
                    enumerable: !0,
                    get: function () {
                        return Ci.default
                    }
                });
                var Di = {};

                function zi(t, e, n) {
                    return o.default.func(t) ? C.resolveRectLike(t, e.interactable, e.element, [n.x, n.y, e]) : C.resolveRectLike(t, e.interactable, e.element)
                }

                Object.defineProperty(Di, "__esModule", {value: !0}), Di.getRestrictionRect = zi, Di.restrict = Di.default = void 0;
                var ki = {
                    start: function (t) {
                        var e = t.rect, n = t.startOffset, i = t.state, r = t.interaction, o = t.pageCoords,
                            s = i.options, a = s.elementRect,
                            l = (0, L.default)({left: 0, top: 0, right: 0, bottom: 0}, s.offset || {});
                        if (e && a) {
                            var c = zi(s.restriction, r, o);
                            if (c) {
                                var u = c.right - c.left - e.width, h = c.bottom - c.top - e.height;
                                u < 0 && (l.left += u, l.right += u), h < 0 && (l.top += h, l.bottom += h)
                            }
                            l.left += n.left - e.width * a.left, l.top += n.top - e.height * a.top, l.right += n.right - e.width * (1 - a.right), l.bottom += n.bottom - e.height * (1 - a.bottom)
                        }
                        i.offset = l
                    }, set: function (t) {
                        var e = t.coords, n = t.interaction, i = t.state, r = i.options, o = i.offset,
                            s = zi(r.restriction, n, e);
                        if (s) {
                            var a = C.xywhToTlbr(s);
                            e.x = Math.max(Math.min(a.right - o.right, e.x), a.left + o.left), e.y = Math.max(Math.min(a.bottom - o.bottom, e.y), a.top + o.top)
                        }
                    }, defaults: {restriction: null, elementRect: null, offset: null, endOnly: !1, enabled: !1}
                };
                Di.restrict = ki;
                var Ni = (0, Te.makeModifier)(ki, "restrict");
                Di.default = Ni;
                var Bi = {};
                Object.defineProperty(Bi, "__esModule", {value: !0}), Bi.restrictEdges = Bi.default = void 0;
                var Fi = {top: 1 / 0, left: 1 / 0, bottom: -1 / 0, right: -1 / 0},
                    Ui = {top: -1 / 0, left: -1 / 0, bottom: 1 / 0, right: 1 / 0};

                function Hi(t, e) {
                    for (var n = ["top", "left", "bottom", "right"], i = 0; i < n.length; i++) {
                        var r = n[i];
                        r in t || (t[r] = e[r])
                    }
                    return t
                }

                var Vi = {
                    noInner: Fi, noOuter: Ui, start: function (t) {
                        var e, n = t.interaction, i = t.startOffset, r = t.state, o = r.options;
                        if (o) {
                            var s = (0, Di.getRestrictionRect)(o.offset, n, n.coords.start.page);
                            e = C.rectToXY(s)
                        }
                        e = e || {x: 0, y: 0}, r.offset = {
                            top: e.y + i.top,
                            left: e.x + i.left,
                            bottom: e.y - i.bottom,
                            right: e.x - i.right
                        }
                    }, set: function (t) {
                        var e = t.coords, n = t.edges, i = t.interaction, r = t.state, o = r.offset, s = r.options;
                        if (n) {
                            var a = (0, L.default)({}, e), l = (0, Di.getRestrictionRect)(s.inner, i, a) || {},
                                c = (0, Di.getRestrictionRect)(s.outer, i, a) || {};
                            Hi(l, Fi), Hi(c, Ui), n.top ? e.y = Math.min(Math.max(c.top + o.top, a.y), l.top + o.top) : n.bottom && (e.y = Math.max(Math.min(c.bottom + o.bottom, a.y), l.bottom + o.bottom)), n.left ? e.x = Math.min(Math.max(c.left + o.left, a.x), l.left + o.left) : n.right && (e.x = Math.max(Math.min(c.right + o.right, a.x), l.right + o.right))
                        }
                    }, defaults: {inner: null, outer: null, offset: null, endOnly: !1, enabled: !1}
                };
                Bi.restrictEdges = Vi;
                var Gi = (0, Te.makeModifier)(Vi, "restrictEdges");
                Bi.default = Gi;
                var Wi = {};
                Object.defineProperty(Wi, "__esModule", {value: !0}), Wi.restrictRect = Wi.default = void 0;
                var ji = (0, L.default)({
                    get elementRect() {
                        return {top: 0, left: 0, bottom: 1, right: 1}
                    }, set elementRect(t) {
                    }
                }, Di.restrict.defaults), qi = {start: Di.restrict.start, set: Di.restrict.set, defaults: ji};
                Wi.restrictRect = qi;
                var Xi = (0, Te.makeModifier)(qi, "restrictRect");
                Wi.default = Xi;
                var Yi = {};
                Object.defineProperty(Yi, "__esModule", {value: !0}), Yi.restrictSize = Yi.default = void 0;
                var Ji = {width: -1 / 0, height: -1 / 0}, Zi = {width: 1 / 0, height: 1 / 0}, Qi = {
                    start: function (t) {
                        return Bi.restrictEdges.start(t)
                    }, set: function (t) {
                        var e = t.interaction, n = t.state, i = t.rect, r = t.edges, o = n.options;
                        if (r) {
                            var s = C.tlbrToXywh((0, Di.getRestrictionRect)(o.min, e, t.coords)) || Ji,
                                a = C.tlbrToXywh((0, Di.getRestrictionRect)(o.max, e, t.coords)) || Zi;
                            n.options = {
                                endOnly: o.endOnly,
                                inner: (0, L.default)({}, Bi.restrictEdges.noInner),
                                outer: (0, L.default)({}, Bi.restrictEdges.noOuter)
                            }, r.top ? (n.options.inner.top = i.bottom - s.height, n.options.outer.top = i.bottom - a.height) : r.bottom && (n.options.inner.bottom = i.top + s.height, n.options.outer.bottom = i.top + a.height), r.left ? (n.options.inner.left = i.right - s.width, n.options.outer.left = i.right - a.width) : r.right && (n.options.inner.right = i.left + s.width, n.options.outer.right = i.left + a.width), Bi.restrictEdges.set(t), n.options = o
                        }
                    }, defaults: {min: null, max: null, endOnly: !1, enabled: !1}
                };
                Yi.restrictSize = Qi;
                var Ki = (0, Te.makeModifier)(Qi, "restrictSize");
                Yi.default = Ki;
                var $i = {};
                Object.defineProperty($i, "__esModule", {value: !0}), Object.defineProperty($i, "default", {
                    enumerable: !0,
                    get: function () {
                        return Ci.default
                    }
                });
                var tr = {};
                Object.defineProperty(tr, "__esModule", {value: !0}), tr.snap = tr.default = void 0;
                var er = {
                    start: function (t) {
                        var e, n = t.interaction, i = t.interactable, r = t.element, o = t.rect, s = t.state,
                            a = t.startOffset, l = s.options, c = l.offsetWithOrigin ? function (t) {
                                var e = t.interaction.element;
                                return (0, C.rectToXY)((0, C.resolveRectLike)(t.state.options.origin, null, null, [e])) || (0, O.default)(t.interactable, e, t.interaction.prepared.name)
                            }(t) : {x: 0, y: 0};
                        if ("startCoords" === l.offset) e = {x: n.coords.start.page.x, y: n.coords.start.page.y}; else {
                            var u = (0, C.resolveRectLike)(l.offset, i, r, [n]);
                            (e = (0, C.rectToXY)(u) || {x: 0, y: 0}).x += c.x, e.y += c.y
                        }
                        var h = l.relativePoints;
                        s.offsets = o && h && h.length ? h.map((function (t, n) {
                            return {
                                index: n,
                                relativePoint: t,
                                x: a.left - o.width * t.x + e.x,
                                y: a.top - o.height * t.y + e.y
                            }
                        })) : [{index: 0, relativePoint: null, x: e.x, y: e.y}]
                    },
                    set: function (t) {
                        var e = t.interaction, n = t.coords, i = t.state, r = i.options, s = i.offsets,
                            a = (0, O.default)(e.interactable, e.element, e.prepared.name), l = (0, L.default)({}, n),
                            c = [];
                        r.offsetWithOrigin || (l.x -= a.x, l.y -= a.y);
                        for (var u = 0; u < s.length; u++) for (var h = s[u], d = l.x - h.x, p = l.y - h.y, f = 0, m = r.targets.length; f < m; f++) {
                            var g, v = r.targets[f];
                            (g = o.default.func(v) ? v(d, p, e._proxy, h, f) : v) && c.push({
                                x: (o.default.number(g.x) ? g.x : d) + h.x,
                                y: (o.default.number(g.y) ? g.y : p) + h.y,
                                range: o.default.number(g.range) ? g.range : r.range,
                                source: v,
                                index: f,
                                offset: h
                            })
                        }
                        for (var y = {
                            target: null,
                            inRange: !1,
                            distance: 0,
                            range: 0,
                            delta: {x: 0, y: 0}
                        }, x = 0; x < c.length; x++) {
                            var _ = c[x], b = _.range, w = _.x - l.x, S = _.y - l.y, M = (0, k.default)(w, S),
                                T = M <= b;
                            b === 1 / 0 && y.inRange && y.range !== 1 / 0 && (T = !1), y.target && !(T ? y.inRange && b !== 1 / 0 ? M / b < y.distance / y.range : b === 1 / 0 && y.range !== 1 / 0 || M < y.distance : !y.inRange && M < y.distance) || (y.target = _, y.distance = M, y.range = b, y.inRange = T, y.delta.x = w, y.delta.y = S)
                        }
                        return y.inRange && (n.x = y.target.x, n.y = y.target.y), i.closest = y, y
                    },
                    defaults: {
                        range: 1 / 0,
                        targets: null,
                        offset: null,
                        offsetWithOrigin: !0,
                        origin: null,
                        relativePoints: null,
                        endOnly: !1,
                        enabled: !1
                    }
                };
                tr.snap = er;
                var nr = (0, Te.makeModifier)(er, "snap");
                tr.default = nr;
                var ir = {};

                function rr(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var n = 0, i = Array(e); n < e; n++) i[n] = t[n];
                    return i
                }

                Object.defineProperty(ir, "__esModule", {value: !0}), ir.snapSize = ir.default = void 0;
                var or = {
                    start: function (t) {
                        var e = t.state, n = t.edges, i = e.options;
                        if (!n) return null;
                        t.state = {
                            options: {
                                targets: null,
                                relativePoints: [{x: n.left ? 0 : 1, y: n.top ? 0 : 1}],
                                offset: i.offset || "self",
                                origin: {x: 0, y: 0},
                                range: i.range
                            }
                        }, e.targetFields = e.targetFields || [["width", "height"], ["x", "y"]], tr.snap.start(t), e.offsets = t.state.offsets, t.state = e
                    }, set: function (t) {
                        var e, n, i = t.interaction, r = t.state, s = t.coords, a = r.options, l = r.offsets,
                            c = {x: s.x - l[0].x, y: s.y - l[0].y};
                        r.options = (0, L.default)({}, a), r.options.targets = [];
                        for (var u = 0; u < (a.targets || []).length; u++) {
                            var h = (a.targets || [])[u], d = void 0;
                            if (d = o.default.func(h) ? h(c.x, c.y, i) : h) {
                                for (var p = 0; p < r.targetFields.length; p++) {
                                    var f = (n = 2, function (t) {
                                        if (Array.isArray(t)) return t
                                    }(e = r.targetFields[p]) || function (t, e) {
                                        if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) {
                                            var n = [], i = !0, r = !1, o = void 0;
                                            try {
                                                for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); i = !0) ;
                                            } catch (t) {
                                                r = !0, o = t
                                            } finally {
                                                try {
                                                    i || null == a.return || a.return()
                                                } finally {
                                                    if (r) throw o
                                                }
                                            }
                                            return n
                                        }
                                    }(e, n) || function (t, e) {
                                        if (t) {
                                            if ("string" == typeof t) return rr(t, e);
                                            var n = Object.prototype.toString.call(t).slice(8, -1);
                                            return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? rr(t, e) : void 0
                                        }
                                    }(e, n) || function () {
                                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                    }()), m = f[0], g = f[1];
                                    if (m in d || g in d) {
                                        d.x = d[m], d.y = d[g];
                                        break
                                    }
                                }
                                r.options.targets.push(d)
                            }
                        }
                        var v = tr.snap.set(t);
                        return r.options = a, v
                    }, defaults: {range: 1 / 0, targets: null, offset: null, endOnly: !1, enabled: !1}
                };
                ir.snapSize = or;
                var sr = (0, Te.makeModifier)(or, "snapSize");
                ir.default = sr;
                var ar = {};
                Object.defineProperty(ar, "__esModule", {value: !0}), ar.snapEdges = ar.default = void 0;
                var lr = {
                    start: function (t) {
                        var e = t.edges;
                        return e ? (t.state.targetFields = t.state.targetFields || [[e.left ? "left" : "right", e.top ? "top" : "bottom"]], ir.snapSize.start(t)) : null
                    },
                    set: ir.snapSize.set,
                    defaults: (0, L.default)((0, ge.default)(ir.snapSize.defaults), {
                        targets: null,
                        range: null,
                        offset: {x: 0, y: 0}
                    })
                };
                ar.snapEdges = lr;
                var cr = (0, Te.makeModifier)(lr, "snapEdges");
                ar.default = cr;
                var ur = {};
                Object.defineProperty(ur, "__esModule", {value: !0}), Object.defineProperty(ur, "default", {
                    enumerable: !0,
                    get: function () {
                        return Ci.default
                    }
                });
                var hr = {};
                Object.defineProperty(hr, "__esModule", {value: !0}), Object.defineProperty(hr, "default", {
                    enumerable: !0,
                    get: function () {
                        return Ci.default
                    }
                });
                var dr = {};
                Object.defineProperty(dr, "__esModule", {value: !0}), dr.default = void 0;
                var pr = {
                    aspectRatio: wi.default,
                    restrictEdges: Bi.default,
                    restrict: Di.default,
                    restrictRect: Wi.default,
                    restrictSize: Yi.default,
                    snapEdges: ar.default,
                    snap: tr.default,
                    snapSize: ir.default,
                    spring: ur.default,
                    avoid: Oi.default,
                    transform: hr.default,
                    rubberband: $i.default
                };
                dr.default = pr;
                var fr = {};
                Object.defineProperty(fr, "__esModule", {value: !0}), fr.default = void 0;
                var mr = {
                    id: "modifiers", install: function (t) {
                        var e = t.interactStatic;
                        for (var n in t.usePlugin(Te.default), t.usePlugin(_i.default), e.modifiers = dr.default, dr.default) {
                            var i = dr.default[n], r = i._defaults, o = i._methods;
                            r._methods = o, t.defaults.perAction[n] = r
                        }
                    }
                };
                fr.default = mr;
                var gr = {};

                function vr(t) {
                    return (vr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                        return typeof t
                    } : function (t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    })(t)
                }

                function yr(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                }

                function xr(t, e) {
                    return (xr = Object.setPrototypeOf || function (t, e) {
                        return t.__proto__ = e, t
                    })(t, e)
                }

                function _r(t, e) {
                    return !e || "object" !== vr(e) && "function" != typeof e ? br(t) : e
                }

                function br(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function wr(t) {
                    return (wr = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    })(t)
                }

                function Sr(t, e, n) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }

                Object.defineProperty(gr, "__esModule", {value: !0}), gr.PointerEvent = gr.default = void 0;
                var Mr = function (t) {
                    !function (t, e) {
                        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                        t.prototype = Object.create(e && e.prototype, {
                            constructor: {
                                value: t,
                                writable: !0,
                                configurable: !0
                            }
                        }), e && xr(t, e)
                    }(o, t);
                    var e, n, i, r = (n = o, i = function () {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
                            }))), !0
                        } catch (t) {
                            return !1
                        }
                    }(), function () {
                        var t, e = wr(n);
                        if (i) {
                            var r = wr(this).constructor;
                            t = Reflect.construct(e, arguments, r)
                        } else t = e.apply(this, arguments);
                        return _r(this, t)
                    });

                    function o(t, e, n, i, s, a) {
                        var l;
                        if (function (t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, o), Sr(br(l = r.call(this, s)), "type", void 0), Sr(br(l), "originalEvent", void 0), Sr(br(l), "pointerId", void 0), Sr(br(l), "pointerType", void 0), Sr(br(l), "double", void 0), Sr(br(l), "pageX", void 0), Sr(br(l), "pageY", void 0), Sr(br(l), "clientX", void 0), Sr(br(l), "clientY", void 0), Sr(br(l), "dt", void 0), Sr(br(l), "eventable", void 0), U.pointerExtend(br(l), n), n !== e && U.pointerExtend(br(l), e), l.timeStamp = a, l.originalEvent = n, l.type = t, l.pointerId = U.getPointerId(e), l.pointerType = U.getPointerType(e), l.target = i, l.currentTarget = null, "tap" === t) {
                            var c = s.getPointerIndex(e);
                            l.dt = l.timeStamp - s.pointers[c].downTime;
                            var u = l.timeStamp - s.tapTime;
                            l.double = !!(s.prevTap && "doubletap" !== s.prevTap.type && s.prevTap.target === l.target && u < 500)
                        } else "doubletap" === t && (l.dt = e.timeStamp - s.tapTime);
                        return l
                    }

                    return (e = [{
                        key: "_subtractOrigin", value: function (t) {
                            var e = t.x, n = t.y;
                            return this.pageX -= e, this.pageY -= n, this.clientX -= e, this.clientY -= n, this
                        }
                    }, {
                        key: "_addOrigin", value: function (t) {
                            var e = t.x, n = t.y;
                            return this.pageX += e, this.pageY += n, this.clientX += e, this.clientY += n, this
                        }
                    }, {
                        key: "preventDefault", value: function () {
                            this.originalEvent.preventDefault()
                        }
                    }]) && yr(o.prototype, e), o
                }(X.BaseEvent);
                gr.PointerEvent = gr.default = Mr;
                var Tr = {};
                Object.defineProperty(Tr, "__esModule", {value: !0}), Tr.default = void 0;
                var Er = {
                    id: "pointer-events/base",
                    before: ["inertia", "modifiers", "auto-start", "actions"],
                    install: function (t) {
                        t.pointerEvents = Er, t.defaults.actions.pointerEvents = Er.defaults, (0, L.default)(t.actions.phaselessTypes, Er.types)
                    },
                    listeners: {
                        "interactions:new": function (t) {
                            var e = t.interaction;
                            e.prevTap = null, e.tapTime = 0
                        }, "interactions:update-pointer": function (t) {
                            var e = t.down, n = t.pointerInfo;
                            !e && n.hold || (n.hold = {duration: 1 / 0, timeout: null})
                        }, "interactions:move": function (t, e) {
                            var n = t.interaction, i = t.pointer, r = t.event, o = t.eventTarget;
                            t.duplicate || n.pointerIsDown && !n.pointerWasMoved || (n.pointerIsDown && Lr(t), Ar({
                                interaction: n,
                                pointer: i,
                                event: r,
                                eventTarget: o,
                                type: "move"
                            }, e))
                        }, "interactions:down": function (t, e) {
                            !function (t, e) {
                                for (var n = t.interaction, i = t.pointer, r = t.event, o = t.eventTarget, s = t.pointerIndex, a = n.pointers[s].hold, l = w.getPath(o), c = {
                                    interaction: n,
                                    pointer: i,
                                    event: r,
                                    eventTarget: o,
                                    type: "hold",
                                    targets: [],
                                    path: l,
                                    node: null
                                }, u = 0; u < l.length; u++) {
                                    var h = l[u];
                                    c.node = h, e.fire("pointerEvents:collect-targets", c)
                                }
                                if (c.targets.length) {
                                    for (var d = 1 / 0, p = 0; p < c.targets.length; p++) {
                                        var f = c.targets[p].eventable.options.holdDuration;
                                        f < d && (d = f)
                                    }
                                    a.duration = d, a.timeout = setTimeout((function () {
                                        Ar({interaction: n, eventTarget: o, pointer: i, event: r, type: "hold"}, e)
                                    }), d)
                                }
                            }(t, e), Ar(t, e)
                        }, "interactions:up": function (t, e) {
                            Lr(t), Ar(t, e), function (t, e) {
                                var n = t.interaction, i = t.pointer, r = t.event, o = t.eventTarget;
                                n.pointerWasMoved || Ar({
                                    interaction: n,
                                    eventTarget: o,
                                    pointer: i,
                                    event: r,
                                    type: "tap"
                                }, e)
                            }(t, e)
                        }, "interactions:cancel": function (t, e) {
                            Lr(t), Ar(t, e)
                        }
                    },
                    PointerEvent: gr.PointerEvent,
                    fire: Ar,
                    collectEventTargets: Pr,
                    defaults: {holdDuration: 600, ignoreFrom: null, allowFrom: null, origin: {x: 0, y: 0}},
                    types: {down: !0, move: !0, up: !0, cancel: !0, tap: !0, doubletap: !0, hold: !0}
                };

                function Ar(t, e) {
                    var n = t.interaction, i = t.pointer, r = t.event, o = t.eventTarget, s = t.type, a = t.targets,
                        l = void 0 === a ? Pr(t, e) : a, c = new gr.PointerEvent(s, i, r, o, n, e.now());
                    e.fire("pointerEvents:new", {pointerEvent: c});
                    for (var u = {
                        interaction: n,
                        pointer: i,
                        event: r,
                        eventTarget: o,
                        targets: l,
                        type: s,
                        pointerEvent: c
                    }, h = 0; h < l.length; h++) {
                        var d = l[h];
                        for (var p in d.props || {}) c[p] = d.props[p];
                        var f = (0, O.default)(d.eventable, d.node);
                        if (c._subtractOrigin(f), c.eventable = d.eventable, c.currentTarget = d.node, d.eventable.fire(c), c._addOrigin(f), c.immediatePropagationStopped || c.propagationStopped && h + 1 < l.length && l[h + 1].node !== c.currentTarget) break
                    }
                    if (e.fire("pointerEvents:fired", u), "tap" === s) {
                        var m = c.double ? Ar({
                            interaction: n,
                            pointer: i,
                            event: r,
                            eventTarget: o,
                            type: "doubletap"
                        }, e) : c;
                        n.prevTap = m, n.tapTime = m.timeStamp
                    }
                    return c
                }

                function Pr(t, e) {
                    var n = t.interaction, i = t.pointer, r = t.event, o = t.eventTarget, s = t.type,
                        a = n.getPointerIndex(i), l = n.pointers[a];
                    if ("tap" === s && (n.pointerWasMoved || !l || l.downTarget !== o)) return [];
                    for (var c = w.getPath(o), u = {
                        interaction: n,
                        pointer: i,
                        event: r,
                        eventTarget: o,
                        type: s,
                        path: c,
                        targets: [],
                        node: null
                    }, h = 0; h < c.length; h++) {
                        var d = c[h];
                        u.node = d, e.fire("pointerEvents:collect-targets", u)
                    }
                    return "hold" === s && (u.targets = u.targets.filter((function (t) {
                        var e;
                        return t.eventable.options.holdDuration === (null == (e = n.pointers[a]) ? void 0 : e.hold.duration)
                    }))), u.targets
                }

                function Lr(t) {
                    var e = t.interaction, n = t.pointerIndex, i = e.pointers[n].hold;
                    i && i.timeout && (clearTimeout(i.timeout), i.timeout = null)
                }

                var Cr = Er;
                Tr.default = Cr;
                var Rr = {};

                function Ir(t) {
                    var e = t.interaction;
                    e.holdIntervalHandle && (clearInterval(e.holdIntervalHandle), e.holdIntervalHandle = null)
                }

                Object.defineProperty(Rr, "__esModule", {value: !0}), Rr.default = void 0;
                var Or = {
                    id: "pointer-events/holdRepeat", install: function (t) {
                        t.usePlugin(Tr.default);
                        var e = t.pointerEvents;
                        e.defaults.holdRepeatInterval = 0, e.types.holdrepeat = t.actions.phaselessTypes.holdrepeat = !0
                    }, listeners: ["move", "up", "cancel", "endall"].reduce((function (t, e) {
                        return t["pointerEvents:".concat(e)] = Ir, t
                    }), {
                        "pointerEvents:new": function (t) {
                            var e = t.pointerEvent;
                            "hold" === e.type && (e.count = (e.count || 0) + 1)
                        }, "pointerEvents:fired": function (t, e) {
                            var n = t.interaction, i = t.pointerEvent, r = t.eventTarget, o = t.targets;
                            if ("hold" === i.type && o.length) {
                                var s = o[0].eventable.options.holdRepeatInterval;
                                s <= 0 || (n.holdIntervalHandle = setTimeout((function () {
                                    e.pointerEvents.fire({
                                        interaction: n,
                                        eventTarget: r,
                                        type: "hold",
                                        pointer: i,
                                        event: i
                                    }, e)
                                }), s))
                            }
                        }
                    })
                };
                Rr.default = Or;
                var Dr = {};

                function zr(t) {
                    return (0, L.default)(this.events.options, t), this
                }

                Object.defineProperty(Dr, "__esModule", {value: !0}), Dr.default = void 0;
                var kr = {
                    id: "pointer-events/interactableTargets", install: function (t) {
                        var e = t.Interactable;
                        e.prototype.pointerEvents = zr;
                        var n = e.prototype._backCompatOption;
                        e.prototype._backCompatOption = function (t, e) {
                            var i = n.call(this, t, e);
                            return i === this && (this.events.options[t] = e), i
                        }
                    }, listeners: {
                        "pointerEvents:collect-targets": function (t, e) {
                            var n = t.targets, i = t.node, r = t.type, o = t.eventTarget;
                            e.interactables.forEachMatch(i, (function (t) {
                                var e = t.events, s = e.options;
                                e.types[r] && e.types[r].length && t.testIgnoreAllow(s, i, o) && n.push({
                                    node: i,
                                    eventable: e,
                                    props: {interactable: t}
                                })
                            }))
                        }, "interactable:new": function (t) {
                            var e = t.interactable;
                            e.events.getRect = function (t) {
                                return e.getRect(t)
                            }
                        }, "interactable:set": function (t, e) {
                            var n = t.interactable, i = t.options;
                            (0, L.default)(n.events.options, e.pointerEvents.defaults), (0, L.default)(n.events.options, i.pointerEvents || {})
                        }
                    }
                };
                Dr.default = kr;
                var Nr = {};
                Object.defineProperty(Nr, "__esModule", {value: !0}), Nr.default = void 0;
                var Br = {
                    id: "pointer-events", install: function (t) {
                        t.usePlugin(Tr), t.usePlugin(Rr.default), t.usePlugin(Dr.default)
                    }
                };
                Nr.default = Br;
                var Fr = {};

                function Ur(t) {
                    var e = t.Interactable;
                    t.actions.phases.reflow = !0, e.prototype.reflow = function (e) {
                        return function (t, e, n) {
                            for (var i = o.default.string(t.target) ? Q.from(t._context.querySelectorAll(t.target)) : [t.target], r = n.window.Promise, s = r ? [] : null, a = function () {
                                var o = i[l], a = t.getRect(o);
                                if (!a) return "break";
                                var c = Q.find(n.interactions.list, (function (n) {
                                    return n.interacting() && n.interactable === t && n.element === o && n.prepared.name === e.name
                                })), u = void 0;
                                if (c) c.move(), s && (u = c._reflowPromise || new r((function (t) {
                                    c._reflowResolve = t
                                }))); else {
                                    var h = (0, C.tlbrToXywh)(a),
                                        d = {page: {x: h.x, y: h.y}, client: {x: h.x, y: h.y}, timeStamp: n.now()},
                                        p = U.coordsToEvent(d);
                                    u = function (t, e, n, i, r) {
                                        var o = t.interactions.new({pointerType: "reflow"}),
                                            s = {interaction: o, event: r, pointer: r, eventTarget: n, phase: "reflow"};
                                        o.interactable = e, o.element = n, o.prevEvent = r, o.updatePointer(r, r, n, !0), U.setZeroCoords(o.coords.delta), (0, Ft.copyAction)(o.prepared, i), o._doPhase(s);
                                        var a = t.window.Promise, l = a ? new a((function (t) {
                                            o._reflowResolve = t
                                        })) : void 0;
                                        return o._reflowPromise = l, o.start(i, e, n), o._interacting ? (o.move(s), o.end(r)) : (o.stop(), o._reflowResolve()), o.removePointer(r, r), l
                                    }(n, t, o, e, p)
                                }
                                s && s.push(u)
                            }, l = 0; l < i.length && "break" !== a(); l++) ;
                            return s && r.all(s).then((function () {
                                return t
                            }))
                        }(this, e, t)
                    }
                }

                Object.defineProperty(Fr, "__esModule", {value: !0}), Fr.install = Ur, Fr.default = void 0;
                var Hr = {
                    id: "reflow", install: Ur, listeners: {
                        "interactions:stop": function (t, e) {
                            var n = t.interaction;
                            "reflow" === n.pointerType && (n._reflowResolve && n._reflowResolve(), Q.remove(e.interactions.list, n))
                        }
                    }
                };
                Fr.default = Hr;
                var Vr = {exports: {}};

                function Gr(t) {
                    return (Gr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                        return typeof t
                    } : function (t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    })(t)
                }

                Object.defineProperty(Vr.exports, "__esModule", {value: !0}), Vr.exports.default = void 0, ui.default.use(ae.default), ui.default.use(Ye.default), ui.default.use(Nr.default), ui.default.use(en.default), ui.default.use(fr.default), ui.default.use(oe.default), ui.default.use(At.default), ui.default.use(Dt.default), ui.default.use(Fr.default);
                var Wr = ui.default;
                if (Vr.exports.default = Wr, "object" === Gr(Vr) && Vr) try {
                    Vr.exports = ui.default
                } catch (t) {
                }
                ui.default.default = ui.default, Vr = Vr.exports;
                var jr = {exports: {}};

                function qr(t) {
                    return (qr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                        return typeof t
                    } : function (t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    })(t)
                }

                Object.defineProperty(jr.exports, "__esModule", {value: !0}), jr.exports.default = void 0;
                var Xr = Vr.default;
                if (jr.exports.default = Xr, "object" === qr(jr) && jr) try {
                    jr.exports = Vr.default
                } catch (t) {
                }
                return Vr.default.default = Vr.default, jr.exports
            }()
        }, 773: (t, e, n) => {
            var i = n(362).Symbol;
            t.exports = i
        }, 111: t => {
            t.exports = function (t, e) {
                for (var n = -1, i = null == t ? 0 : t.length; ++n < i && !1 !== e(t[n], n, t);) ;
                return t
            }
        }, 83: (t, e, n) => {
            var i = n(94), r = n(246), o = n(670), s = n(343), a = n(782), l = n(589),
                c = Object.prototype.hasOwnProperty;
            t.exports = function (t, e) {
                var n = o(t), u = !n && r(t), h = !n && !u && s(t), d = !n && !u && !h && l(t), p = n || u || h || d,
                    f = p ? i(t.length, String) : [], m = f.length;
                for (var g in t) !e && !c.call(t, g) || p && ("length" == g || h && ("offset" == g || "parent" == g) || d && ("buffer" == g || "byteLength" == g || "byteOffset" == g) || a(g, m)) || f.push(g);
                return f
            }
        }, 806: (t, e, n) => {
            var i = n(645), r = n(978)(i);
            t.exports = r
        }, 79: (t, e, n) => {
            var i = n(924)();
            t.exports = i
        }, 645: (t, e, n) => {
            var i = n(79), r = n(225);
            t.exports = function (t, e) {
                return t && i(t, e, r)
            }
        }, 185: (t, e, n) => {
            var i = n(773), r = n(888), o = n(299), s = i ? i.toStringTag : void 0;
            t.exports = function (t) {
                return null == t ? void 0 === t ? "[object Undefined]" : "[object Null]" : s && s in Object(t) ? r(t) : o(t)
            }
        }, 75: (t, e, n) => {
            var i = n(185), r = n(939);
            t.exports = function (t) {
                return r(t) && "[object Arguments]" == i(t)
            }
        }, 638: (t, e, n) => {
            var i = n(185), r = n(100), o = n(939), s = {};
            s["[object Float32Array]"] = s["[object Float64Array]"] = s["[object Int8Array]"] = s["[object Int16Array]"] = s["[object Int32Array]"] = s["[object Uint8Array]"] = s["[object Uint8ClampedArray]"] = s["[object Uint16Array]"] = s["[object Uint32Array]"] = !0, s["[object Arguments]"] = s["[object Array]"] = s["[object ArrayBuffer]"] = s["[object Boolean]"] = s["[object DataView]"] = s["[object Date]"] = s["[object Error]"] = s["[object Function]"] = s["[object Map]"] = s["[object Number]"] = s["[object Object]"] = s["[object RegExp]"] = s["[object Set]"] = s["[object String]"] = s["[object WeakMap]"] = !1, t.exports = function (t) {
                return o(t) && r(t.length) && !!s[i(t)]
            }
        }, 521: (t, e, n) => {
            var i = n(803), r = n(865), o = Object.prototype.hasOwnProperty;
            t.exports = function (t) {
                if (!i(t)) return r(t);
                var e = [];
                for (var n in Object(t)) o.call(t, n) && "constructor" != n && e.push(n);
                return e
            }
        }, 94: t => {
            t.exports = function (t, e) {
                for (var n = -1, i = Array(t); ++n < t;) i[n] = e(n);
                return i
            }
        }, 81: t => {
            t.exports = function (t) {
                return function (e) {
                    return t(e)
                }
            }
        }, 183: (t, e, n) => {
            var i = n(559);
            t.exports = function (t) {
                return "function" == typeof t ? t : i
            }
        }, 978: (t, e, n) => {
            var i = n(175);
            t.exports = function (t, e) {
                return function (n, r) {
                    if (null == n) return n;
                    if (!i(n)) return t(n, r);
                    for (var o = n.length, s = e ? o : -1, a = Object(n); (e ? s-- : ++s < o) && !1 !== r(a[s], s, a);) ;
                    return n
                }
            }
        }, 924: t => {
            t.exports = function (t) {
                return function (e, n, i) {
                    for (var r = -1, o = Object(e), s = i(e), a = s.length; a--;) {
                        var l = s[t ? a : ++r];
                        if (!1 === n(o[l], l, o)) break
                    }
                    return e
                }
            }
        }, 556: (t, e, n) => {
            var i = "object" == typeof n.g && n.g && n.g.Object === Object && n.g;
            t.exports = i
        }, 888: (t, e, n) => {
            var i = n(773), r = Object.prototype, o = r.hasOwnProperty, s = r.toString, a = i ? i.toStringTag : void 0;
            t.exports = function (t) {
                var e = o.call(t, a), n = t[a];
                try {
                    t[a] = void 0;
                    var i = !0
                } catch (t) {
                }
                var r = s.call(t);
                return i && (e ? t[a] = n : delete t[a]), r
            }
        }, 782: t => {
            var e = /^(?:0|[1-9]\d*)$/;
            t.exports = function (t, n) {
                var i = typeof t;
                return !!(n = null == n ? 9007199254740991 : n) && ("number" == i || "symbol" != i && e.test(t)) && t > -1 && t % 1 == 0 && t < n
            }
        }, 803: t => {
            var e = Object.prototype;
            t.exports = function (t) {
                var n = t && t.constructor;
                return t === ("function" == typeof n && n.prototype || e)
            }
        }, 865: (t, e, n) => {
            var i = n(290)(Object.keys, Object);
            t.exports = i
        }, 985: (t, e, n) => {
            t = n.nmd(t);
            var i = n(556), r = e && !e.nodeType && e, o = r && t && !t.nodeType && t,
                s = o && o.exports === r && i.process, a = function () {
                    try {
                        var t = o && o.require && o.require("util").types;
                        return t || s && s.binding && s.binding("util")
                    } catch (t) {
                    }
                }();
            t.exports = a
        }, 299: t => {
            var e = Object.prototype.toString;
            t.exports = function (t) {
                return e.call(t)
            }
        }, 290: t => {
            t.exports = function (t, e) {
                return function (n) {
                    return t(e(n))
                }
            }
        }, 362: (t, e, n) => {
            var i = n(556), r = "object" == typeof self && self && self.Object === Object && self,
                o = i || r || Function("return this")();
            t.exports = o
        }, 270: (t, e, n) => {
            t.exports = n(982)
        }, 982: (t, e, n) => {
            var i = n(111), r = n(806), o = n(183), s = n(670);
            t.exports = function (t, e) {
                return (s(t) ? i : r)(t, o(e))
            }
        }, 559: t => {
            t.exports = function (t) {
                return t
            }
        }, 246: (t, e, n) => {
            var i = n(75), r = n(939), o = Object.prototype, s = o.hasOwnProperty, a = o.propertyIsEnumerable,
                l = i(function () {
                    return arguments
                }()) ? i : function (t) {
                    return r(t) && s.call(t, "callee") && !a.call(t, "callee")
                };
            t.exports = l
        }, 670: t => {
            var e = Array.isArray;
            t.exports = e
        }, 175: (t, e, n) => {
            var i = n(626), r = n(100);
            t.exports = function (t) {
                return null != t && r(t.length) && !i(t)
            }
        }, 343: (t, e, n) => {
            t = n.nmd(t);
            var i = n(362), r = n(444), o = e && !e.nodeType && e, s = o && t && !t.nodeType && t,
                a = s && s.exports === o ? i.Buffer : void 0, l = (a ? a.isBuffer : void 0) || r;
            t.exports = l
        }, 626: (t, e, n) => {
            var i = n(185), r = n(71);
            t.exports = function (t) {
                if (!r(t)) return !1;
                var e = i(t);
                return "[object Function]" == e || "[object GeneratorFunction]" == e || "[object AsyncFunction]" == e || "[object Proxy]" == e
            }
        }, 100: t => {
            t.exports = function (t) {
                return "number" == typeof t && t > -1 && t % 1 == 0 && t <= 9007199254740991
            }
        }, 71: t => {
            t.exports = function (t) {
                var e = typeof t;
                return null != t && ("object" == e || "function" == e)
            }
        }, 939: t => {
            t.exports = function (t) {
                return null != t && "object" == typeof t
            }
        }, 589: (t, e, n) => {
            var i = n(638), r = n(81), o = n(985), s = o && o.isTypedArray, a = s ? r(s) : i;
            t.exports = a
        }, 225: (t, e, n) => {
            var i = n(83), r = n(521), o = n(175);
            t.exports = function (t) {
                return o(t) ? i(t) : r(t)
            }
        }, 444: t => {
            t.exports = function () {
                return !1
            }
        }, 714: function (t, e, n) {
            var i;
            i = function () {
                return function (t) {
                    var e = {};

                    function n(i) {
                        if (e[i]) return e[i].exports;
                        var r = e[i] = {i, l: !1, exports: {}};
                        return t[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports
                    }

                    return n.m = t, n.c = e, n.d = function (t, e, i) {
                        n.o(t, e) || Object.defineProperty(t, e, {enumerable: !0, get: i})
                    }, n.r = function (t) {
                        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(t, "__esModule", {value: !0})
                    }, n.t = function (t, e) {
                        if (1 & e && (t = n(t)), 8 & e) return t;
                        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
                        var i = Object.create(null);
                        if (n.r(i), Object.defineProperty(i, "default", {
                            enumerable: !0,
                            value: t
                        }), 2 & e && "string" != typeof t) for (var r in t) n.d(i, r, function (e) {
                            return t[e]
                        }.bind(null, r));
                        return i
                    }, n.n = function (t) {
                        var e = t && t.__esModule ? function () {
                            return t.default
                        } : function () {
                            return t
                        };
                        return n.d(e, "a", e), e
                    }, n.o = function (t, e) {
                        return Object.prototype.hasOwnProperty.call(t, e)
                    }, n.p = "", n(n.s = 21)
                }([function (t, e) {
                    var i = {};
                    t.exports = i, function () {
                        i._nextId = 0, i._seed = 0, i._nowStartTime = +new Date, i._warnedOnce = {}, i._decomp = null, i.extend = function (t, e) {
                            var n, r;
                            "boolean" == typeof e ? (n = 2, r = e) : (n = 1, r = !0);
                            for (var o = n; o < arguments.length; o++) {
                                var s = arguments[o];
                                if (s) for (var a in s) r && s[a] && s[a].constructor === Object ? t[a] && t[a].constructor !== Object ? t[a] = s[a] : (t[a] = t[a] || {}, i.extend(t[a], r, s[a])) : t[a] = s[a]
                            }
                            return t
                        }, i.clone = function (t, e) {
                            return i.extend({}, e, t)
                        }, i.keys = function (t) {
                            if (Object.keys) return Object.keys(t);
                            var e = [];
                            for (var n in t) e.push(n);
                            return e
                        }, i.values = function (t) {
                            var e = [];
                            if (Object.keys) {
                                for (var n = Object.keys(t), i = 0; i < n.length; i++) e.push(t[n[i]]);
                                return e
                            }
                            for (var r in t) e.push(t[r]);
                            return e
                        }, i.get = function (t, e, n, i) {
                            e = e.split(".").slice(n, i);
                            for (var r = 0; r < e.length; r += 1) t = t[e[r]];
                            return t
                        }, i.set = function (t, e, n, r, o) {
                            var s = e.split(".").slice(r, o);
                            return i.get(t, e, 0, -1)[s[s.length - 1]] = n, n
                        }, i.shuffle = function (t) {
                            for (var e = t.length - 1; e > 0; e--) {
                                var n = Math.floor(i.random() * (e + 1)), r = t[e];
                                t[e] = t[n], t[n] = r
                            }
                            return t
                        }, i.choose = function (t) {
                            return t[Math.floor(i.random() * t.length)]
                        }, i.isElement = function (t) {
                            return "undefined" != typeof HTMLElement ? t instanceof HTMLElement : !!(t && t.nodeType && t.nodeName)
                        }, i.isArray = function (t) {
                            return "[object Array]" === Object.prototype.toString.call(t)
                        }, i.isFunction = function (t) {
                            return "function" == typeof t
                        }, i.isPlainObject = function (t) {
                            return "object" == typeof t && t.constructor === Object
                        }, i.isString = function (t) {
                            return "[object String]" === toString.call(t)
                        }, i.clamp = function (t, e, n) {
                            return t < e ? e : t > n ? n : t
                        }, i.sign = function (t) {
                            return t < 0 ? -1 : 1
                        }, i.now = function () {
                            if ("undefined" != typeof window && window.performance) {
                                if (window.performance.now) return window.performance.now();
                                if (window.performance.webkitNow) return window.performance.webkitNow()
                            }
                            return Date.now ? Date.now() : new Date - i._nowStartTime
                        }, i.random = function (e, n) {
                            return n = void 0 !== n ? n : 1, (e = void 0 !== e ? e : 0) + t() * (n - e)
                        };
                        var t = function () {
                            return i._seed = (9301 * i._seed + 49297) % 233280, i._seed / 233280
                        };
                        i.colorToNumber = function (t) {
                            return 3 == (t = t.replace("#", "")).length && (t = t.charAt(0) + t.charAt(0) + t.charAt(1) + t.charAt(1) + t.charAt(2) + t.charAt(2)), parseInt(t, 16)
                        }, i.logLevel = 1, i.log = function () {
                            console && i.logLevel > 0 && i.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                        }, i.info = function () {
                            console && i.logLevel > 0 && i.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                        }, i.warn = function () {
                            console && i.logLevel > 0 && i.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)))
                        }, i.warnOnce = function () {
                            var t = Array.prototype.slice.call(arguments).join(" ");
                            i._warnedOnce[t] || (i.warn(t), i._warnedOnce[t] = !0)
                        }, i.deprecated = function (t, e, n) {
                            t[e] = i.chain((function () {
                                i.warnOnce("ð deprecated ð", n)
                            }), t[e])
                        }, i.nextId = function () {
                            return i._nextId++
                        }, i.indexOf = function (t, e) {
                            if (t.indexOf) return t.indexOf(e);
                            for (var n = 0; n < t.length; n++) if (t[n] === e) return n;
                            return -1
                        }, i.map = function (t, e) {
                            if (t.map) return t.map(e);
                            for (var n = [], i = 0; i < t.length; i += 1) n.push(e(t[i]));
                            return n
                        }, i.topologicalSort = function (t) {
                            var e = [], n = [], r = [];
                            for (var o in t) n[o] || r[o] || i._topologicalSort(o, n, r, t, e);
                            return e
                        }, i._topologicalSort = function (t, e, n, r, o) {
                            var s = r[t] || [];
                            n[t] = !0;
                            for (var a = 0; a < s.length; a += 1) {
                                var l = s[a];
                                n[l] || e[l] || i._topologicalSort(l, e, n, r, o)
                            }
                            n[t] = !1, e[t] = !0, o.push(t)
                        }, i.chain = function () {
                            for (var t = [], e = 0; e < arguments.length; e += 1) {
                                var n = arguments[e];
                                n._chained ? t.push.apply(t, n._chained) : t.push(n)
                            }
                            var i = function () {
                                for (var e, n = new Array(arguments.length), i = 0, r = arguments.length; i < r; i++) n[i] = arguments[i];
                                for (i = 0; i < t.length; i += 1) {
                                    var o = t[i].apply(e, n);
                                    void 0 !== o && (e = o)
                                }
                                return e
                            };
                            return i._chained = t, i
                        }, i.chainPathBefore = function (t, e, n) {
                            return i.set(t, e, i.chain(n, i.get(t, e)))
                        }, i.chainPathAfter = function (t, e, n) {
                            return i.set(t, e, i.chain(i.get(t, e), n))
                        }, i.setDecomp = function (t) {
                            i._decomp = t
                        }, i.getDecomp = function () {
                            var t = i._decomp;
                            try {
                                t || "undefined" == typeof window || (t = window.decomp), t || void 0 === n.g || (t = n.g.decomp)
                            } catch (e) {
                                t = null
                            }
                            return t
                        }
                    }()
                }, function (t, e) {
                    var n = {};
                    t.exports = n, n.create = function (t) {
                        var e = {min: {x: 0, y: 0}, max: {x: 0, y: 0}};
                        return t && n.update(e, t), e
                    }, n.update = function (t, e, n) {
                        t.min.x = 1 / 0, t.max.x = -1 / 0, t.min.y = 1 / 0, t.max.y = -1 / 0;
                        for (var i = 0; i < e.length; i++) {
                            var r = e[i];
                            r.x > t.max.x && (t.max.x = r.x), r.x < t.min.x && (t.min.x = r.x), r.y > t.max.y && (t.max.y = r.y), r.y < t.min.y && (t.min.y = r.y)
                        }
                        n && (n.x > 0 ? t.max.x += n.x : t.min.x += n.x, n.y > 0 ? t.max.y += n.y : t.min.y += n.y)
                    }, n.contains = function (t, e) {
                        return e.x >= t.min.x && e.x <= t.max.x && e.y >= t.min.y && e.y <= t.max.y
                    }, n.overlaps = function (t, e) {
                        return t.min.x <= e.max.x && t.max.x >= e.min.x && t.max.y >= e.min.y && t.min.y <= e.max.y
                    }, n.translate = function (t, e) {
                        t.min.x += e.x, t.max.x += e.x, t.min.y += e.y, t.max.y += e.y
                    }, n.shift = function (t, e) {
                        var n = t.max.x - t.min.x, i = t.max.y - t.min.y;
                        t.min.x = e.x, t.max.x = e.x + n, t.min.y = e.y, t.max.y = e.y + i
                    }
                }, function (t, e) {
                    var n = {};
                    t.exports = n, n.create = function (t, e) {
                        return {x: t || 0, y: e || 0}
                    }, n.clone = function (t) {
                        return {x: t.x, y: t.y}
                    }, n.magnitude = function (t) {
                        return Math.sqrt(t.x * t.x + t.y * t.y)
                    }, n.magnitudeSquared = function (t) {
                        return t.x * t.x + t.y * t.y
                    }, n.rotate = function (t, e, n) {
                        var i = Math.cos(e), r = Math.sin(e);
                        n || (n = {});
                        var o = t.x * i - t.y * r;
                        return n.y = t.x * r + t.y * i, n.x = o, n
                    }, n.rotateAbout = function (t, e, n, i) {
                        var r = Math.cos(e), o = Math.sin(e);
                        i || (i = {});
                        var s = n.x + ((t.x - n.x) * r - (t.y - n.y) * o);
                        return i.y = n.y + ((t.x - n.x) * o + (t.y - n.y) * r), i.x = s, i
                    }, n.normalise = function (t) {
                        var e = n.magnitude(t);
                        return 0 === e ? {x: 0, y: 0} : {x: t.x / e, y: t.y / e}
                    }, n.dot = function (t, e) {
                        return t.x * e.x + t.y * e.y
                    }, n.cross = function (t, e) {
                        return t.x * e.y - t.y * e.x
                    }, n.cross3 = function (t, e, n) {
                        return (e.x - t.x) * (n.y - t.y) - (e.y - t.y) * (n.x - t.x)
                    }, n.add = function (t, e, n) {
                        return n || (n = {}), n.x = t.x + e.x, n.y = t.y + e.y, n
                    }, n.sub = function (t, e, n) {
                        return n || (n = {}), n.x = t.x - e.x, n.y = t.y - e.y, n
                    }, n.mult = function (t, e) {
                        return {x: t.x * e, y: t.y * e}
                    }, n.div = function (t, e) {
                        return {x: t.x / e, y: t.y / e}
                    }, n.perp = function (t, e) {
                        return {x: (e = !0 === e ? -1 : 1) * -t.y, y: e * t.x}
                    }, n.neg = function (t) {
                        return {x: -t.x, y: -t.y}
                    }, n.angle = function (t, e) {
                        return Math.atan2(e.y - t.y, e.x - t.x)
                    }, n._temp = [n.create(), n.create(), n.create(), n.create(), n.create(), n.create()]
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(2), o = n(0);
                    i.create = function (t, e) {
                        for (var n = [], i = 0; i < t.length; i++) {
                            var r = t[i], o = {x: r.x, y: r.y, index: i, body: e, isInternal: !1};
                            n.push(o)
                        }
                        return n
                    }, i.fromPath = function (t, e) {
                        var n = [];
                        return t.replace(/L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/gi, (function (t, e, i) {
                            n.push({x: parseFloat(e), y: parseFloat(i)})
                        })), i.create(n, e)
                    }, i.centre = function (t) {
                        for (var e, n, o, s = i.area(t, !0), a = {
                            x: 0,
                            y: 0
                        }, l = 0; l < t.length; l++) o = (l + 1) % t.length, e = r.cross(t[l], t[o]), n = r.mult(r.add(t[l], t[o]), e), a = r.add(a, n);
                        return r.div(a, 6 * s)
                    }, i.mean = function (t) {
                        for (var e = {x: 0, y: 0}, n = 0; n < t.length; n++) e.x += t[n].x, e.y += t[n].y;
                        return r.div(e, t.length)
                    }, i.area = function (t, e) {
                        for (var n = 0, i = t.length - 1, r = 0; r < t.length; r++) n += (t[i].x - t[r].x) * (t[i].y + t[r].y), i = r;
                        return e ? n / 2 : Math.abs(n) / 2
                    }, i.inertia = function (t, e) {
                        for (var n, i, o = 0, s = 0, a = t, l = 0; l < a.length; l++) i = (l + 1) % a.length, o += (n = Math.abs(r.cross(a[i], a[l]))) * (r.dot(a[i], a[i]) + r.dot(a[i], a[l]) + r.dot(a[l], a[l])), s += n;
                        return e / 6 * (o / s)
                    }, i.translate = function (t, e, n) {
                        n = void 0 !== n ? n : 1;
                        var i, r = t.length, o = e.x * n, s = e.y * n;
                        for (i = 0; i < r; i++) t[i].x += o, t[i].y += s;
                        return t
                    }, i.rotate = function (t, e, n) {
                        if (0 !== e) {
                            var i, r, o, s, a = Math.cos(e), l = Math.sin(e), c = n.x, u = n.y, h = t.length;
                            for (s = 0; s < h; s++) r = (i = t[s]).x - c, o = i.y - u, i.x = c + (r * a - o * l), i.y = u + (r * l + o * a);
                            return t
                        }
                    }, i.contains = function (t, e) {
                        for (var n, i = e.x, r = e.y, o = t.length, s = t[o - 1], a = 0; a < o; a++) {
                            if (n = t[a], (i - s.x) * (n.y - s.y) + (r - s.y) * (s.x - n.x) > 0) return !1;
                            s = n
                        }
                        return !0
                    }, i.scale = function (t, e, n, o) {
                        if (1 === e && 1 === n) return t;
                        var s, a;
                        o = o || i.centre(t);
                        for (var l = 0; l < t.length; l++) s = t[l], a = r.sub(s, o), t[l].x = o.x + a.x * e, t[l].y = o.y + a.y * n;
                        return t
                    }, i.chamfer = function (t, e, n, i, s) {
                        e = "number" == typeof e ? [e] : e || [8], n = void 0 !== n ? n : -1, i = i || 2, s = s || 14;
                        for (var a = [], l = 0; l < t.length; l++) {
                            var c = t[l - 1 >= 0 ? l - 1 : t.length - 1], u = t[l], h = t[(l + 1) % t.length],
                                d = e[l < e.length ? l : e.length - 1];
                            if (0 !== d) {
                                var p = r.normalise({x: u.y - c.y, y: c.x - u.x}),
                                    f = r.normalise({x: h.y - u.y, y: u.x - h.x}), m = Math.sqrt(2 * Math.pow(d, 2)),
                                    g = r.mult(o.clone(p), d), v = r.normalise(r.mult(r.add(p, f), .5)),
                                    y = r.sub(u, r.mult(v, m)), x = n;
                                -1 === n && (x = 1.75 * Math.pow(d, .32)), (x = o.clamp(x, i, s)) % 2 == 1 && (x += 1);
                                for (var _ = Math.acos(r.dot(p, f)) / x, b = 0; b < x; b++) a.push(r.add(r.rotate(g, _ * b), y))
                            } else a.push(u)
                        }
                        return a
                    }, i.clockwiseSort = function (t) {
                        var e = i.mean(t);
                        return t.sort((function (t, n) {
                            return r.angle(e, t) - r.angle(e, n)
                        })), t
                    }, i.isConvex = function (t) {
                        var e, n, i, r, o = 0, s = t.length;
                        if (s < 3) return null;
                        for (e = 0; e < s; e++) if (i = (e + 2) % s, r = (t[n = (e + 1) % s].x - t[e].x) * (t[i].y - t[n].y), (r -= (t[n].y - t[e].y) * (t[i].x - t[n].x)) < 0 ? o |= 1 : r > 0 && (o |= 2), 3 === o) return !1;
                        return 0 !== o || null
                    }, i.hull = function (t) {
                        var e, n, i = [], o = [];
                        for ((t = t.slice(0)).sort((function (t, e) {
                            var n = t.x - e.x;
                            return 0 !== n ? n : t.y - e.y
                        })), n = 0; n < t.length; n += 1) {
                            for (e = t[n]; o.length >= 2 && r.cross3(o[o.length - 2], o[o.length - 1], e) <= 0;) o.pop();
                            o.push(e)
                        }
                        for (n = t.length - 1; n >= 0; n -= 1) {
                            for (e = t[n]; i.length >= 2 && r.cross3(i[i.length - 2], i[i.length - 1], e) <= 0;) i.pop();
                            i.push(e)
                        }
                        return i.pop(), o.pop(), i.concat(o)
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(0);
                    i.on = function (t, e, n) {
                        for (var i, r = e.split(" "), o = 0; o < r.length; o++) i = r[o], t.events = t.events || {}, t.events[i] = t.events[i] || [], t.events[i].push(n);
                        return n
                    }, i.off = function (t, e, n) {
                        if (e) {
                            "function" == typeof e && (n = e, e = r.keys(t.events).join(" "));
                            for (var i = e.split(" "), o = 0; o < i.length; o++) {
                                var s = t.events[i[o]], a = [];
                                if (n && s) for (var l = 0; l < s.length; l++) s[l] !== n && a.push(s[l]);
                                t.events[i[o]] = a
                            }
                        } else t.events = {}
                    }, i.trigger = function (t, e, n) {
                        var i, o, s, a, l = t.events;
                        if (l && r.keys(l).length > 0) {
                            n || (n = {}), i = e.split(" ");
                            for (var c = 0; c < i.length; c++) if (s = l[o = i[c]]) {
                                (a = r.clone(n, !1)).name = o, a.source = t;
                                for (var u = 0; u < s.length; u++) s[u].apply(t, [a])
                            }
                        }
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(4), o = n(0), s = n(1), a = n(6);
                    i.create = function (t) {
                        return o.extend({
                            id: o.nextId(),
                            type: "composite",
                            parent: null,
                            isModified: !1,
                            bodies: [],
                            constraints: [],
                            composites: [],
                            label: "Composite",
                            plugin: {},
                            cache: {allBodies: null, allConstraints: null, allComposites: null}
                        }, t)
                    }, i.setModified = function (t, e, n, r) {
                        if (t.isModified = e, e && t.cache && (t.cache.allBodies = null, t.cache.allConstraints = null, t.cache.allComposites = null), n && t.parent && i.setModified(t.parent, e, n, r), r) for (var o = 0; o < t.composites.length; o++) {
                            var s = t.composites[o];
                            i.setModified(s, e, n, r)
                        }
                    }, i.add = function (t, e) {
                        var n = [].concat(e);
                        r.trigger(t, "beforeAdd", {object: e});
                        for (var s = 0; s < n.length; s++) {
                            var a = n[s];
                            switch (a.type) {
                                case"body":
                                    if (a.parent !== a) {
                                        o.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
                                        break
                                    }
                                    i.addBody(t, a);
                                    break;
                                case"constraint":
                                    i.addConstraint(t, a);
                                    break;
                                case"composite":
                                    i.addComposite(t, a);
                                    break;
                                case"mouseConstraint":
                                    i.addConstraint(t, a.constraint)
                            }
                        }
                        return r.trigger(t, "afterAdd", {object: e}), t
                    }, i.remove = function (t, e, n) {
                        var o = [].concat(e);
                        r.trigger(t, "beforeRemove", {object: e});
                        for (var s = 0; s < o.length; s++) {
                            var a = o[s];
                            switch (a.type) {
                                case"body":
                                    i.removeBody(t, a, n);
                                    break;
                                case"constraint":
                                    i.removeConstraint(t, a, n);
                                    break;
                                case"composite":
                                    i.removeComposite(t, a, n);
                                    break;
                                case"mouseConstraint":
                                    i.removeConstraint(t, a.constraint)
                            }
                        }
                        return r.trigger(t, "afterRemove", {object: e}), t
                    }, i.addComposite = function (t, e) {
                        return t.composites.push(e), e.parent = t, i.setModified(t, !0, !0, !1), t
                    }, i.removeComposite = function (t, e, n) {
                        var r = o.indexOf(t.composites, e);
                        if (-1 !== r && i.removeCompositeAt(t, r), n) for (var s = 0; s < t.composites.length; s++) i.removeComposite(t.composites[s], e, !0);
                        return t
                    }, i.removeCompositeAt = function (t, e) {
                        return t.composites.splice(e, 1), i.setModified(t, !0, !0, !1), t
                    }, i.addBody = function (t, e) {
                        return t.bodies.push(e), i.setModified(t, !0, !0, !1), t
                    }, i.removeBody = function (t, e, n) {
                        var r = o.indexOf(t.bodies, e);
                        if (-1 !== r && i.removeBodyAt(t, r), n) for (var s = 0; s < t.composites.length; s++) i.removeBody(t.composites[s], e, !0);
                        return t
                    }, i.removeBodyAt = function (t, e) {
                        return t.bodies.splice(e, 1), i.setModified(t, !0, !0, !1), t
                    }, i.addConstraint = function (t, e) {
                        return t.constraints.push(e), i.setModified(t, !0, !0, !1), t
                    }, i.removeConstraint = function (t, e, n) {
                        var r = o.indexOf(t.constraints, e);
                        if (-1 !== r && i.removeConstraintAt(t, r), n) for (var s = 0; s < t.composites.length; s++) i.removeConstraint(t.composites[s], e, !0);
                        return t
                    }, i.removeConstraintAt = function (t, e) {
                        return t.constraints.splice(e, 1), i.setModified(t, !0, !0, !1), t
                    }, i.clear = function (t, e, n) {
                        if (n) for (var r = 0; r < t.composites.length; r++) i.clear(t.composites[r], e, !0);
                        return e ? t.bodies = t.bodies.filter((function (t) {
                            return t.isStatic
                        })) : t.bodies.length = 0, t.constraints.length = 0, t.composites.length = 0, i.setModified(t, !0, !0, !1), t
                    }, i.allBodies = function (t) {
                        if (t.cache && t.cache.allBodies) return t.cache.allBodies;
                        for (var e = [].concat(t.bodies), n = 0; n < t.composites.length; n++) e = e.concat(i.allBodies(t.composites[n]));
                        return t.cache && (t.cache.allBodies = e), e
                    }, i.allConstraints = function (t) {
                        if (t.cache && t.cache.allConstraints) return t.cache.allConstraints;
                        for (var e = [].concat(t.constraints), n = 0; n < t.composites.length; n++) e = e.concat(i.allConstraints(t.composites[n]));
                        return t.cache && (t.cache.allConstraints = e), e
                    }, i.allComposites = function (t) {
                        if (t.cache && t.cache.allComposites) return t.cache.allComposites;
                        for (var e = [].concat(t.composites), n = 0; n < t.composites.length; n++) e = e.concat(i.allComposites(t.composites[n]));
                        return t.cache && (t.cache.allComposites = e), e
                    }, i.get = function (t, e, n) {
                        var r, o;
                        switch (n) {
                            case"body":
                                r = i.allBodies(t);
                                break;
                            case"constraint":
                                r = i.allConstraints(t);
                                break;
                            case"composite":
                                r = i.allComposites(t).concat(t)
                        }
                        return r ? 0 === (o = r.filter((function (t) {
                            return t.id.toString() === e.toString()
                        }))).length ? null : o[0] : null
                    }, i.move = function (t, e, n) {
                        return i.remove(t, e), i.add(n, e), t
                    }, i.rebase = function (t) {
                        for (var e = i.allBodies(t).concat(i.allConstraints(t)).concat(i.allComposites(t)), n = 0; n < e.length; n++) e[n].id = o.nextId();
                        return t
                    }, i.translate = function (t, e, n) {
                        for (var r = n ? i.allBodies(t) : t.bodies, o = 0; o < r.length; o++) a.translate(r[o], e);
                        return t
                    }, i.rotate = function (t, e, n, r) {
                        for (var o = Math.cos(e), s = Math.sin(e), l = r ? i.allBodies(t) : t.bodies, c = 0; c < l.length; c++) {
                            var u = l[c], h = u.position.x - n.x, d = u.position.y - n.y;
                            a.setPosition(u, {x: n.x + (h * o - d * s), y: n.y + (h * s + d * o)}), a.rotate(u, e)
                        }
                        return t
                    }, i.scale = function (t, e, n, r, o) {
                        for (var s = o ? i.allBodies(t) : t.bodies, l = 0; l < s.length; l++) {
                            var c = s[l], u = c.position.x - r.x, h = c.position.y - r.y;
                            a.setPosition(c, {x: r.x + u * e, y: r.y + h * n}), a.scale(c, e, n)
                        }
                        return t
                    }, i.bounds = function (t) {
                        for (var e = i.allBodies(t), n = [], r = 0; r < e.length; r += 1) {
                            var o = e[r];
                            n.push(o.bounds.min, o.bounds.max)
                        }
                        return s.create(n)
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(3), o = n(2), s = n(7), a = (n(16), n(0)), l = n(1), c = n(11);
                    !function () {
                        i._inertiaScale = 4, i._nextCollidingGroupId = 1, i._nextNonCollidingGroupId = -1, i._nextCategory = 1, i.create = function (e) {
                            var n = {
                                id: a.nextId(),
                                type: "body",
                                label: "Body",
                                parts: [],
                                plugin: {},
                                angle: 0,
                                vertices: r.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),
                                position: {x: 0, y: 0},
                                force: {x: 0, y: 0},
                                torque: 0,
                                positionImpulse: {x: 0, y: 0},
                                constraintImpulse: {x: 0, y: 0, angle: 0},
                                totalContacts: 0,
                                speed: 0,
                                angularSpeed: 0,
                                velocity: {x: 0, y: 0},
                                angularVelocity: 0,
                                isSensor: !1,
                                isStatic: !1,
                                isSleeping: !1,
                                motion: 0,
                                sleepThreshold: 60,
                                density: .001,
                                restitution: 0,
                                friction: .1,
                                frictionStatic: .5,
                                frictionAir: .01,
                                collisionFilter: {category: 1, mask: 4294967295, group: 0},
                                slop: .05,
                                timeScale: 1,
                                render: {
                                    visible: !0,
                                    opacity: 1,
                                    strokeStyle: null,
                                    fillStyle: null,
                                    lineWidth: null,
                                    sprite: {xScale: 1, yScale: 1, xOffset: 0, yOffset: 0}
                                },
                                events: null,
                                bounds: null,
                                chamfer: null,
                                circleRadius: 0,
                                positionPrev: null,
                                anglePrev: 0,
                                parent: null,
                                axes: null,
                                area: 0,
                                mass: 0,
                                inertia: 0,
                                _original: null
                            }, i = a.extend(n, e);
                            return t(i, e), i
                        }, i.nextGroup = function (t) {
                            return t ? i._nextNonCollidingGroupId-- : i._nextCollidingGroupId++
                        }, i.nextCategory = function () {
                            return i._nextCategory = i._nextCategory << 1, i._nextCategory
                        };
                        var t = function (t, e) {
                            e = e || {}, i.set(t, {
                                bounds: t.bounds || l.create(t.vertices),
                                positionPrev: t.positionPrev || o.clone(t.position),
                                anglePrev: t.anglePrev || t.angle,
                                vertices: t.vertices,
                                parts: t.parts || [t],
                                isStatic: t.isStatic,
                                isSleeping: t.isSleeping,
                                parent: t.parent || t
                            }), r.rotate(t.vertices, t.angle, t.position), c.rotate(t.axes, t.angle), l.update(t.bounds, t.vertices, t.velocity), i.set(t, {
                                axes: e.axes || t.axes,
                                area: e.area || t.area,
                                mass: e.mass || t.mass,
                                inertia: e.inertia || t.inertia
                            });
                            var n = t.isStatic ? "#14151f" : a.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"]),
                                s = t.isStatic ? "#555" : "#ccc", u = t.isStatic && null === t.render.fillStyle ? 1 : 0;
                            t.render.fillStyle = t.render.fillStyle || n, t.render.strokeStyle = t.render.strokeStyle || s, t.render.lineWidth = t.render.lineWidth || u, t.render.sprite.xOffset += -(t.bounds.min.x - t.position.x) / (t.bounds.max.x - t.bounds.min.x), t.render.sprite.yOffset += -(t.bounds.min.y - t.position.y) / (t.bounds.max.y - t.bounds.min.y)
                        };
                        i.set = function (t, e, n) {
                            var r;
                            for (r in "string" == typeof e && (r = e, (e = {})[r] = n), e) if (Object.prototype.hasOwnProperty.call(e, r)) switch (n = e[r], r) {
                                case"isStatic":
                                    i.setStatic(t, n);
                                    break;
                                case"isSleeping":
                                    s.set(t, n);
                                    break;
                                case"mass":
                                    i.setMass(t, n);
                                    break;
                                case"density":
                                    i.setDensity(t, n);
                                    break;
                                case"inertia":
                                    i.setInertia(t, n);
                                    break;
                                case"vertices":
                                    i.setVertices(t, n);
                                    break;
                                case"position":
                                    i.setPosition(t, n);
                                    break;
                                case"angle":
                                    i.setAngle(t, n);
                                    break;
                                case"velocity":
                                    i.setVelocity(t, n);
                                    break;
                                case"angularVelocity":
                                    i.setAngularVelocity(t, n);
                                    break;
                                case"parts":
                                    i.setParts(t, n);
                                    break;
                                case"centre":
                                    i.setCentre(t, n);
                                    break;
                                default:
                                    t[r] = n
                            }
                        }, i.setStatic = function (t, e) {
                            for (var n = 0; n < t.parts.length; n++) {
                                var i = t.parts[n];
                                i.isStatic = e, e ? (i._original = {
                                    restitution: i.restitution,
                                    friction: i.friction,
                                    mass: i.mass,
                                    inertia: i.inertia,
                                    density: i.density,
                                    inverseMass: i.inverseMass,
                                    inverseInertia: i.inverseInertia
                                }, i.restitution = 0, i.friction = 1, i.mass = i.inertia = i.density = 1 / 0, i.inverseMass = i.inverseInertia = 0, i.positionPrev.x = i.position.x, i.positionPrev.y = i.position.y, i.anglePrev = i.angle, i.angularVelocity = 0, i.speed = 0, i.angularSpeed = 0, i.motion = 0) : i._original && (i.restitution = i._original.restitution, i.friction = i._original.friction, i.mass = i._original.mass, i.inertia = i._original.inertia, i.density = i._original.density, i.inverseMass = i._original.inverseMass, i.inverseInertia = i._original.inverseInertia, i._original = null)
                            }
                        }, i.setMass = function (t, e) {
                            var n = t.inertia / (t.mass / 6);
                            t.inertia = n * (e / 6), t.inverseInertia = 1 / t.inertia, t.mass = e, t.inverseMass = 1 / t.mass, t.density = t.mass / t.area
                        }, i.setDensity = function (t, e) {
                            i.setMass(t, e * t.area), t.density = e
                        }, i.setInertia = function (t, e) {
                            t.inertia = e, t.inverseInertia = 1 / t.inertia
                        }, i.setVertices = function (t, e) {
                            e[0].body === t ? t.vertices = e : t.vertices = r.create(e, t), t.axes = c.fromVertices(t.vertices), t.area = r.area(t.vertices), i.setMass(t, t.density * t.area);
                            var n = r.centre(t.vertices);
                            r.translate(t.vertices, n, -1), i.setInertia(t, i._inertiaScale * r.inertia(t.vertices, t.mass)), r.translate(t.vertices, t.position), l.update(t.bounds, t.vertices, t.velocity)
                        }, i.setParts = function (t, e, n) {
                            var o;
                            for (e = e.slice(0), t.parts.length = 0, t.parts.push(t), t.parent = t, o = 0; o < e.length; o++) {
                                var s = e[o];
                                s !== t && (s.parent = t, t.parts.push(s))
                            }
                            if (1 !== t.parts.length) {
                                if (n = void 0 === n || n) {
                                    var a = [];
                                    for (o = 0; o < e.length; o++) a = a.concat(e[o].vertices);
                                    r.clockwiseSort(a);
                                    var l = r.hull(a), c = r.centre(l);
                                    i.setVertices(t, l), r.translate(t.vertices, c)
                                }
                                var u = i._totalProperties(t);
                                t.area = u.area, t.parent = t, t.position.x = u.centre.x, t.position.y = u.centre.y, t.positionPrev.x = u.centre.x, t.positionPrev.y = u.centre.y, i.setMass(t, u.mass), i.setInertia(t, u.inertia), i.setPosition(t, u.centre)
                            }
                        }, i.setCentre = function (t, e, n) {
                            n ? (t.positionPrev.x += e.x, t.positionPrev.y += e.y, t.position.x += e.x, t.position.y += e.y) : (t.positionPrev.x = e.x - (t.position.x - t.positionPrev.x), t.positionPrev.y = e.y - (t.position.y - t.positionPrev.y), t.position.x = e.x, t.position.y = e.y)
                        }, i.setPosition = function (t, e) {
                            var n = o.sub(e, t.position);
                            t.positionPrev.x += n.x, t.positionPrev.y += n.y;
                            for (var i = 0; i < t.parts.length; i++) {
                                var s = t.parts[i];
                                s.position.x += n.x, s.position.y += n.y, r.translate(s.vertices, n), l.update(s.bounds, s.vertices, t.velocity)
                            }
                        }, i.setAngle = function (t, e) {
                            var n = e - t.angle;
                            t.anglePrev += n;
                            for (var i = 0; i < t.parts.length; i++) {
                                var s = t.parts[i];
                                s.angle += n, r.rotate(s.vertices, n, t.position), c.rotate(s.axes, n), l.update(s.bounds, s.vertices, t.velocity), i > 0 && o.rotateAbout(s.position, n, t.position, s.position)
                            }
                        }, i.setVelocity = function (t, e) {
                            t.positionPrev.x = t.position.x - e.x, t.positionPrev.y = t.position.y - e.y, t.velocity.x = e.x, t.velocity.y = e.y, t.speed = o.magnitude(t.velocity)
                        }, i.setAngularVelocity = function (t, e) {
                            t.anglePrev = t.angle - e, t.angularVelocity = e, t.angularSpeed = Math.abs(t.angularVelocity)
                        }, i.translate = function (t, e) {
                            i.setPosition(t, o.add(t.position, e))
                        }, i.rotate = function (t, e, n) {
                            if (n) {
                                var r = Math.cos(e), o = Math.sin(e), s = t.position.x - n.x, a = t.position.y - n.y;
                                i.setPosition(t, {
                                    x: n.x + (s * r - a * o),
                                    y: n.y + (s * o + a * r)
                                }), i.setAngle(t, t.angle + e)
                            } else i.setAngle(t, t.angle + e)
                        }, i.scale = function (t, e, n, o) {
                            var s = 0, a = 0;
                            o = o || t.position;
                            for (var u = 0; u < t.parts.length; u++) {
                                var h = t.parts[u];
                                r.scale(h.vertices, e, n, o), h.axes = c.fromVertices(h.vertices), h.area = r.area(h.vertices), i.setMass(h, t.density * h.area), r.translate(h.vertices, {
                                    x: -h.position.x,
                                    y: -h.position.y
                                }), i.setInertia(h, i._inertiaScale * r.inertia(h.vertices, h.mass)), r.translate(h.vertices, {
                                    x: h.position.x,
                                    y: h.position.y
                                }), u > 0 && (s += h.area, a += h.inertia), h.position.x = o.x + (h.position.x - o.x) * e, h.position.y = o.y + (h.position.y - o.y) * n, l.update(h.bounds, h.vertices, t.velocity)
                            }
                            t.parts.length > 1 && (t.area = s, t.isStatic || (i.setMass(t, t.density * s), i.setInertia(t, a))), t.circleRadius && (e === n ? t.circleRadius *= e : t.circleRadius = null)
                        }, i.update = function (t, e, n, i) {
                            var s = Math.pow(e * n * t.timeScale, 2), a = 1 - t.frictionAir * n * t.timeScale,
                                u = t.position.x - t.positionPrev.x, h = t.position.y - t.positionPrev.y;
                            t.velocity.x = u * a * i + t.force.x / t.mass * s, t.velocity.y = h * a * i + t.force.y / t.mass * s, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.position.x += t.velocity.x, t.position.y += t.velocity.y, t.angularVelocity = (t.angle - t.anglePrev) * a * i + t.torque / t.inertia * s, t.anglePrev = t.angle, t.angle += t.angularVelocity, t.speed = o.magnitude(t.velocity), t.angularSpeed = Math.abs(t.angularVelocity);
                            for (var d = 0; d < t.parts.length; d++) {
                                var p = t.parts[d];
                                r.translate(p.vertices, t.velocity), d > 0 && (p.position.x += t.velocity.x, p.position.y += t.velocity.y), 0 !== t.angularVelocity && (r.rotate(p.vertices, t.angularVelocity, t.position), c.rotate(p.axes, t.angularVelocity), d > 0 && o.rotateAbout(p.position, t.angularVelocity, t.position, p.position)), l.update(p.bounds, p.vertices, t.velocity)
                            }
                        }, i.applyForce = function (t, e, n) {
                            t.force.x += n.x, t.force.y += n.y;
                            var i = e.x - t.position.x, r = e.y - t.position.y;
                            t.torque += i * n.y - r * n.x
                        }, i._totalProperties = function (t) {
                            for (var e = {
                                mass: 0,
                                area: 0,
                                inertia: 0,
                                centre: {x: 0, y: 0}
                            }, n = 1 === t.parts.length ? 0 : 1; n < t.parts.length; n++) {
                                var i = t.parts[n], r = i.mass !== 1 / 0 ? i.mass : 1;
                                e.mass += r, e.area += i.area, e.inertia += i.inertia, e.centre = o.add(e.centre, o.mult(i.position, r))
                            }
                            return e.centre = o.div(e.centre, e.mass), e
                        }
                    }()
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(4);
                    i._motionWakeThreshold = .18, i._motionSleepThreshold = .08, i._minBias = .9, i.update = function (t, e) {
                        for (var n = e * e * e, r = 0; r < t.length; r++) {
                            var o = t[r], s = o.speed * o.speed + o.angularSpeed * o.angularSpeed;
                            if (0 === o.force.x && 0 === o.force.y) {
                                var a = Math.min(o.motion, s), l = Math.max(o.motion, s);
                                o.motion = i._minBias * a + (1 - i._minBias) * l, o.sleepThreshold > 0 && o.motion < i._motionSleepThreshold * n ? (o.sleepCounter += 1, o.sleepCounter >= o.sleepThreshold && i.set(o, !0)) : o.sleepCounter > 0 && (o.sleepCounter -= 1)
                            } else i.set(o, !1)
                        }
                    }, i.afterCollisions = function (t, e) {
                        for (var n = e * e * e, r = 0; r < t.length; r++) {
                            var o = t[r];
                            if (o.isActive) {
                                var s = o.collision, a = s.bodyA.parent, l = s.bodyB.parent;
                                if (!(a.isSleeping && l.isSleeping || a.isStatic || l.isStatic) && (a.isSleeping || l.isSleeping)) {
                                    var c = a.isSleeping && !a.isStatic ? a : l, u = c === a ? l : a;
                                    !c.isStatic && u.motion > i._motionWakeThreshold * n && i.set(c, !1)
                                }
                            }
                        }
                    }, i.set = function (t, e) {
                        var n = t.isSleeping;
                        e ? (t.isSleeping = !0, t.sleepCounter = t.sleepThreshold, t.positionImpulse.x = 0, t.positionImpulse.y = 0, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.anglePrev = t.angle, t.speed = 0, t.angularSpeed = 0, t.motion = 0, n || r.trigger(t, "sleepStart")) : (t.isSleeping = !1, t.sleepCounter = 0, n && r.trigger(t, "sleepEnd"))
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r, o, s, a = n(3), l = n(9);
                    r = [], o = {overlap: 0, axis: null}, s = {overlap: 0, axis: null}, i.create = function (t, e) {
                        return {
                            pair: null,
                            collided: !1,
                            bodyA: t,
                            bodyB: e,
                            parentA: t.parent,
                            parentB: e.parent,
                            depth: 0,
                            normal: {x: 0, y: 0},
                            tangent: {x: 0, y: 0},
                            penetration: {x: 0, y: 0},
                            supports: []
                        }
                    }, i.collides = function (t, e, n) {
                        if (i._overlapAxes(o, t.vertices, e.vertices, t.axes), o.overlap <= 0) return null;
                        if (i._overlapAxes(s, e.vertices, t.vertices, e.axes), s.overlap <= 0) return null;
                        var r, c, u = n && n.table[l.id(t, e)];
                        u ? r = u.collision : ((r = i.create(t, e)).collided = !0, r.bodyA = t.id < e.id ? t : e, r.bodyB = t.id < e.id ? e : t, r.parentA = r.bodyA.parent, r.parentB = r.bodyB.parent), t = r.bodyA, e = r.bodyB, c = o.overlap < s.overlap ? o : s;
                        var h = r.normal, d = r.supports, p = c.axis, f = p.x, m = p.y;
                        f * (e.position.x - t.position.x) + m * (e.position.y - t.position.y) < 0 ? (h.x = f, h.y = m) : (h.x = -f, h.y = -m), r.tangent.x = -h.y, r.tangent.y = h.x, r.depth = c.overlap, r.penetration.x = h.x * r.depth, r.penetration.y = h.y * r.depth;
                        var g = i._findSupports(t, e, h, 1), v = 0;
                        if (a.contains(t.vertices, g[0]) && (d[v++] = g[0]), a.contains(t.vertices, g[1]) && (d[v++] = g[1]), v < 2) {
                            var y = i._findSupports(e, t, h, -1);
                            a.contains(e.vertices, y[0]) && (d[v++] = y[0]), v < 2 && a.contains(e.vertices, y[1]) && (d[v++] = y[1])
                        }
                        return 0 === v && (d[v++] = g[0]), d.length = v, r
                    }, i._overlapAxes = function (t, e, n, i) {
                        var r, o, s, a, l, c, u = e.length, h = n.length, d = e[0].x, p = e[0].y, f = n[0].x,
                            m = n[0].y, g = i.length, v = Number.MAX_VALUE, y = 0;
                        for (l = 0; l < g; l++) {
                            var x = i[l], _ = x.x, b = x.y, w = d * _ + p * b, S = f * _ + m * b, M = w, T = S;
                            for (c = 1; c < u; c += 1) (a = e[c].x * _ + e[c].y * b) > M ? M = a : a < w && (w = a);
                            for (c = 1; c < h; c += 1) (a = n[c].x * _ + n[c].y * b) > T ? T = a : a < S && (S = a);
                            if ((r = (o = M - S) < (s = T - w) ? o : s) < v && (v = r, y = l, r <= 0)) break
                        }
                        t.axis = i[y], t.overlap = v
                    }, i._projectToAxis = function (t, e, n) {
                        for (var i = e[0].x * n.x + e[0].y * n.y, r = i, o = 1; o < e.length; o += 1) {
                            var s = e[o].x * n.x + e[o].y * n.y;
                            s > r ? r = s : s < i && (i = s)
                        }
                        t.min = i, t.max = r
                    }, i._findSupports = function (t, e, n, i) {
                        var o, s, a, l, c, u = e.vertices, h = u.length, d = t.position.x, p = t.position.y,
                            f = n.x * i, m = n.y * i, g = Number.MAX_VALUE;
                        for (c = 0; c < h; c += 1) (l = f * (d - (s = u[c]).x) + m * (p - s.y)) < g && (g = l, o = s);
                        return g = f * (d - (a = u[(h + o.index - 1) % h]).x) + m * (p - a.y), f * (d - (s = u[(o.index + 1) % h]).x) + m * (p - s.y) < g ? (r[0] = o, r[1] = s, r) : (r[0] = o, r[1] = a, r)
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(17);
                    i.create = function (t, e) {
                        var n = t.bodyA, r = t.bodyB, o = {
                            id: i.id(n, r),
                            bodyA: n,
                            bodyB: r,
                            collision: t,
                            contacts: [],
                            activeContacts: [],
                            separation: 0,
                            isActive: !0,
                            confirmedActive: !0,
                            isSensor: n.isSensor || r.isSensor,
                            timeCreated: e,
                            timeUpdated: e,
                            inverseMass: 0,
                            friction: 0,
                            frictionStatic: 0,
                            restitution: 0,
                            slop: 0
                        };
                        return i.update(o, t, e), o
                    }, i.update = function (t, e, n) {
                        var i = t.contacts, o = e.supports, s = t.activeContacts, a = e.parentA, l = e.parentB,
                            c = a.vertices.length;
                        t.isActive = !0, t.timeUpdated = n, t.collision = e, t.separation = e.depth, t.inverseMass = a.inverseMass + l.inverseMass, t.friction = a.friction < l.friction ? a.friction : l.friction, t.frictionStatic = a.frictionStatic > l.frictionStatic ? a.frictionStatic : l.frictionStatic, t.restitution = a.restitution > l.restitution ? a.restitution : l.restitution, t.slop = a.slop > l.slop ? a.slop : l.slop, e.pair = t, s.length = 0;
                        for (var u = 0; u < o.length; u++) {
                            var h = o[u], d = h.body === a ? h.index : c + h.index, p = i[d];
                            p ? s.push(p) : s.push(i[d] = r.create(h))
                        }
                    }, i.setActive = function (t, e, n) {
                        e ? (t.isActive = !0, t.timeUpdated = n) : (t.isActive = !1, t.activeContacts.length = 0)
                    }, i.id = function (t, e) {
                        return t.id < e.id ? "A" + t.id + "B" + e.id : "A" + e.id + "B" + t.id
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(3), o = n(2), s = n(7), a = n(1), l = n(11), c = n(0);
                    i._warming = .4, i._torqueDampen = 1, i._minLength = 1e-6, i.create = function (t) {
                        var e = t;
                        e.bodyA && !e.pointA && (e.pointA = {x: 0, y: 0}), e.bodyB && !e.pointB && (e.pointB = {
                            x: 0,
                            y: 0
                        });
                        var n = e.bodyA ? o.add(e.bodyA.position, e.pointA) : e.pointA,
                            i = e.bodyB ? o.add(e.bodyB.position, e.pointB) : e.pointB, r = o.magnitude(o.sub(n, i));
                        e.length = void 0 !== e.length ? e.length : r, e.id = e.id || c.nextId(), e.label = e.label || "Constraint", e.type = "constraint", e.stiffness = e.stiffness || (e.length > 0 ? 1 : .7), e.damping = e.damping || 0, e.angularStiffness = e.angularStiffness || 0, e.angleA = e.bodyA ? e.bodyA.angle : e.angleA, e.angleB = e.bodyB ? e.bodyB.angle : e.angleB, e.plugin = {};
                        var s = {visible: !0, lineWidth: 2, strokeStyle: "#ffffff", type: "line", anchors: !0};
                        return 0 === e.length && e.stiffness > .1 ? (s.type = "pin", s.anchors = !1) : e.stiffness < .9 && (s.type = "spring"), e.render = c.extend(s, e.render), e
                    }, i.preSolveAll = function (t) {
                        for (var e = 0; e < t.length; e += 1) {
                            var n = t[e], i = n.constraintImpulse;
                            n.isStatic || 0 === i.x && 0 === i.y && 0 === i.angle || (n.position.x += i.x, n.position.y += i.y, n.angle += i.angle)
                        }
                    }, i.solveAll = function (t, e) {
                        for (var n = 0; n < t.length; n += 1) {
                            var r = t[n], o = !r.bodyA || r.bodyA && r.bodyA.isStatic,
                                s = !r.bodyB || r.bodyB && r.bodyB.isStatic;
                            (o || s) && i.solve(t[n], e)
                        }
                        for (n = 0; n < t.length; n += 1) o = !(r = t[n]).bodyA || r.bodyA && r.bodyA.isStatic, s = !r.bodyB || r.bodyB && r.bodyB.isStatic, o || s || i.solve(t[n], e)
                    }, i.solve = function (t, e) {
                        var n = t.bodyA, r = t.bodyB, s = t.pointA, a = t.pointB;
                        if (n || r) {
                            n && !n.isStatic && (o.rotate(s, n.angle - t.angleA, s), t.angleA = n.angle), r && !r.isStatic && (o.rotate(a, r.angle - t.angleB, a), t.angleB = r.angle);
                            var l = s, c = a;
                            if (n && (l = o.add(n.position, s)), r && (c = o.add(r.position, a)), l && c) {
                                var u = o.sub(l, c), h = o.magnitude(u);
                                h < i._minLength && (h = i._minLength);
                                var d, p, f, m, g, v = (h - t.length) / h,
                                    y = t.stiffness < 1 ? t.stiffness * e : t.stiffness, x = o.mult(u, v * y),
                                    _ = (n ? n.inverseMass : 0) + (r ? r.inverseMass : 0),
                                    b = _ + ((n ? n.inverseInertia : 0) + (r ? r.inverseInertia : 0));
                                if (t.damping) {
                                    var w = o.create();
                                    f = o.div(u, h), g = o.sub(r && o.sub(r.position, r.positionPrev) || w, n && o.sub(n.position, n.positionPrev) || w), m = o.dot(f, g)
                                }
                                n && !n.isStatic && (p = n.inverseMass / _, n.constraintImpulse.x -= x.x * p, n.constraintImpulse.y -= x.y * p, n.position.x -= x.x * p, n.position.y -= x.y * p, t.damping && (n.positionPrev.x -= t.damping * f.x * m * p, n.positionPrev.y -= t.damping * f.y * m * p), d = o.cross(s, x) / b * i._torqueDampen * n.inverseInertia * (1 - t.angularStiffness), n.constraintImpulse.angle -= d, n.angle -= d), r && !r.isStatic && (p = r.inverseMass / _, r.constraintImpulse.x += x.x * p, r.constraintImpulse.y += x.y * p, r.position.x += x.x * p, r.position.y += x.y * p, t.damping && (r.positionPrev.x += t.damping * f.x * m * p, r.positionPrev.y += t.damping * f.y * m * p), d = o.cross(a, x) / b * i._torqueDampen * r.inverseInertia * (1 - t.angularStiffness), r.constraintImpulse.angle += d, r.angle += d)
                            }
                        }
                    }, i.postSolveAll = function (t) {
                        for (var e = 0; e < t.length; e++) {
                            var n = t[e], c = n.constraintImpulse;
                            if (!(n.isStatic || 0 === c.x && 0 === c.y && 0 === c.angle)) {
                                s.set(n, !1);
                                for (var u = 0; u < n.parts.length; u++) {
                                    var h = n.parts[u];
                                    r.translate(h.vertices, c), u > 0 && (h.position.x += c.x, h.position.y += c.y), 0 !== c.angle && (r.rotate(h.vertices, c.angle, n.position), l.rotate(h.axes, c.angle), u > 0 && o.rotateAbout(h.position, c.angle, n.position, h.position)), a.update(h.bounds, h.vertices, n.velocity)
                                }
                                c.angle *= i._warming, c.x *= i._warming, c.y *= i._warming
                            }
                        }
                    }, i.pointAWorld = function (t) {
                        return {
                            x: (t.bodyA ? t.bodyA.position.x : 0) + t.pointA.x,
                            y: (t.bodyA ? t.bodyA.position.y : 0) + t.pointA.y
                        }
                    }, i.pointBWorld = function (t) {
                        return {
                            x: (t.bodyB ? t.bodyB.position.x : 0) + t.pointB.x,
                            y: (t.bodyB ? t.bodyB.position.y : 0) + t.pointB.y
                        }
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(2), o = n(0);
                    i.fromVertices = function (t) {
                        for (var e = {}, n = 0; n < t.length; n++) {
                            var i = (n + 1) % t.length, s = r.normalise({x: t[i].y - t[n].y, y: t[n].x - t[i].x}),
                                a = 0 === s.y ? 1 / 0 : s.x / s.y;
                            e[a = a.toFixed(3).toString()] = s
                        }
                        return o.values(e)
                    }, i.rotate = function (t, e) {
                        if (0 !== e) for (var n = Math.cos(e), i = Math.sin(e), r = 0; r < t.length; r++) {
                            var o, s = t[r];
                            o = s.x * n - s.y * i, s.y = s.x * i + s.y * n, s.x = o
                        }
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(3), o = n(0), s = n(6), a = n(1), l = n(2);
                    i.rectangle = function (t, e, n, i, a) {
                        a = a || {};
                        var l = {
                            label: "Rectangle Body",
                            position: {x: t, y: e},
                            vertices: r.fromPath("L 0 0 L " + n + " 0 L " + n + " " + i + " L 0 " + i)
                        };
                        if (a.chamfer) {
                            var c = a.chamfer;
                            l.vertices = r.chamfer(l.vertices, c.radius, c.quality, c.qualityMin, c.qualityMax), delete a.chamfer
                        }
                        return s.create(o.extend({}, l, a))
                    }, i.trapezoid = function (t, e, n, i, a, l) {
                        l = l || {};
                        var c, u = n * (a *= .5), h = u + (1 - 2 * a) * n, d = h + u;
                        c = a < .5 ? "L 0 0 L " + u + " " + -i + " L " + h + " " + -i + " L " + d + " 0" : "L 0 0 L " + h + " " + -i + " L " + d + " 0";
                        var p = {label: "Trapezoid Body", position: {x: t, y: e}, vertices: r.fromPath(c)};
                        if (l.chamfer) {
                            var f = l.chamfer;
                            p.vertices = r.chamfer(p.vertices, f.radius, f.quality, f.qualityMin, f.qualityMax), delete l.chamfer
                        }
                        return s.create(o.extend({}, p, l))
                    }, i.circle = function (t, e, n, r, s) {
                        r = r || {};
                        var a = {label: "Circle Body", circleRadius: n};
                        s = s || 25;
                        var l = Math.ceil(Math.max(10, Math.min(s, n)));
                        return l % 2 == 1 && (l += 1), i.polygon(t, e, l, n, o.extend({}, a, r))
                    }, i.polygon = function (t, e, n, a, l) {
                        if (l = l || {}, n < 3) return i.circle(t, e, a, l);
                        for (var c = 2 * Math.PI / n, u = "", h = .5 * c, d = 0; d < n; d += 1) {
                            var p = h + d * c, f = Math.cos(p) * a, m = Math.sin(p) * a;
                            u += "L " + f.toFixed(3) + " " + m.toFixed(3) + " "
                        }
                        var g = {label: "Polygon Body", position: {x: t, y: e}, vertices: r.fromPath(u)};
                        if (l.chamfer) {
                            var v = l.chamfer;
                            g.vertices = r.chamfer(g.vertices, v.radius, v.quality, v.qualityMin, v.qualityMax), delete l.chamfer
                        }
                        return s.create(o.extend({}, g, l))
                    }, i.fromVertices = function (t, e, n, i, c, u, h, d) {
                        var p, f, m, g, v, y, x, _, b, w, S = o.getDecomp();
                        for (p = Boolean(S && S.quickDecomp), i = i || {}, m = [], c = void 0 !== c && c, u = void 0 !== u ? u : .01, h = void 0 !== h ? h : 10, d = void 0 !== d ? d : .01, o.isArray(n[0]) || (n = [n]), b = 0; b < n.length; b += 1) if (v = n[b], !(g = r.isConvex(v)) && !p && o.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."), g || !p) v = g ? r.clockwiseSort(v) : r.hull(v), m.push({
                            position: {
                                x: t,
                                y: e
                            }, vertices: v
                        }); else {
                            var M = v.map((function (t) {
                                return [t.x, t.y]
                            }));
                            S.makeCCW(M), !1 !== u && S.removeCollinearPoints(M, u), !1 !== d && S.removeDuplicatePoints && S.removeDuplicatePoints(M, d);
                            var T = S.quickDecomp(M);
                            for (y = 0; y < T.length; y++) {
                                var E = T[y].map((function (t) {
                                    return {x: t[0], y: t[1]}
                                }));
                                h > 0 && r.area(E) < h || m.push({position: r.centre(E), vertices: E})
                            }
                        }
                        for (y = 0; y < m.length; y++) m[y] = s.create(o.extend(m[y], i));
                        if (c) for (y = 0; y < m.length; y++) {
                            var A = m[y];
                            for (x = y + 1; x < m.length; x++) {
                                var P = m[x];
                                if (a.overlaps(A.bounds, P.bounds)) {
                                    var L = A.vertices, C = P.vertices;
                                    for (_ = 0; _ < A.vertices.length; _++) for (w = 0; w < P.vertices.length; w++) {
                                        var R = l.magnitudeSquared(l.sub(L[(_ + 1) % L.length], C[w])),
                                            I = l.magnitudeSquared(l.sub(L[_], C[(w + 1) % C.length]));
                                        R < 5 && I < 5 && (L[_].isInternal = !0, C[w].isInternal = !0)
                                    }
                                }
                            }
                        }
                        return m.length > 1 ? (f = s.create(o.extend({parts: m.slice(0)}, i)), s.setPosition(f, {
                            x: t,
                            y: e
                        }), f) : m[0]
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(0);
                    i.create = function (t) {
                        var e = {};
                        return t || r.log("Mouse.create: element was undefined, defaulting to document.body", "warn"), e.element = t || document.body, e.absolute = {
                            x: 0,
                            y: 0
                        }, e.position = {x: 0, y: 0}, e.mousedownPosition = {x: 0, y: 0}, e.mouseupPosition = {
                            x: 0,
                            y: 0
                        }, e.offset = {x: 0, y: 0}, e.scale = {
                            x: 1,
                            y: 1
                        }, e.wheelDelta = 0, e.button = -1, e.pixelRatio = parseInt(e.element.getAttribute("data-pixel-ratio"), 10) || 1, e.sourceEvents = {
                            mousemove: null,
                            mousedown: null,
                            mouseup: null,
                            mousewheel: null
                        }, e.mousemove = function (t) {
                            var n = i._getRelativeMousePosition(t, e.element, e.pixelRatio);
                            t.changedTouches && (e.button = 0, t.preventDefault()), e.absolute.x = n.x, e.absolute.y = n.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y, e.sourceEvents.mousemove = t
                        }, e.mousedown = function (t) {
                            var n = i._getRelativeMousePosition(t, e.element, e.pixelRatio);
                            t.changedTouches ? (e.button = 0, t.preventDefault()) : e.button = t.button, e.absolute.x = n.x, e.absolute.y = n.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y, e.mousedownPosition.x = e.position.x, e.mousedownPosition.y = e.position.y, e.sourceEvents.mousedown = t
                        }, e.mouseup = function (t) {
                            var n = i._getRelativeMousePosition(t, e.element, e.pixelRatio);
                            t.changedTouches && t.preventDefault(), e.button = -1, e.absolute.x = n.x, e.absolute.y = n.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y, e.mouseupPosition.x = e.position.x, e.mouseupPosition.y = e.position.y, e.sourceEvents.mouseup = t
                        }, e.mousewheel = function (t) {
                            e.wheelDelta = Math.max(-1, Math.min(1, t.wheelDelta || -t.detail)), t.preventDefault()
                        }, i.setElement(e, e.element), e
                    }, i.setElement = function (t, e) {
                        t.element = e, e.addEventListener("mousemove", t.mousemove), e.addEventListener("mousedown", t.mousedown), e.addEventListener("mouseup", t.mouseup), e.addEventListener("mousewheel", t.mousewheel), e.addEventListener("DOMMouseScroll", t.mousewheel), e.addEventListener("touchmove", t.mousemove), e.addEventListener("touchstart", t.mousedown), e.addEventListener("touchend", t.mouseup)
                    }, i.clearSourceEvents = function (t) {
                        t.sourceEvents.mousemove = null, t.sourceEvents.mousedown = null, t.sourceEvents.mouseup = null, t.sourceEvents.mousewheel = null, t.wheelDelta = 0
                    }, i.setOffset = function (t, e) {
                        t.offset.x = e.x, t.offset.y = e.y, t.position.x = t.absolute.x * t.scale.x + t.offset.x, t.position.y = t.absolute.y * t.scale.y + t.offset.y
                    }, i.setScale = function (t, e) {
                        t.scale.x = e.x, t.scale.y = e.y, t.position.x = t.absolute.x * t.scale.x + t.offset.x, t.position.y = t.absolute.y * t.scale.y + t.offset.y
                    }, i._getRelativeMousePosition = function (t, e, n) {
                        var i, r, o = e.getBoundingClientRect(),
                            s = document.documentElement || document.body.parentNode || document.body,
                            a = void 0 !== window.pageXOffset ? window.pageXOffset : s.scrollLeft,
                            l = void 0 !== window.pageYOffset ? window.pageYOffset : s.scrollTop, c = t.changedTouches;
                        return c ? (i = c[0].pageX - o.left - a, r = c[0].pageY - o.top - l) : (i = t.pageX - o.left - a, r = t.pageY - o.top - l), {
                            x: i / (e.clientWidth / (e.width || e.clientWidth) * n),
                            y: r / (e.clientHeight / (e.height || e.clientHeight) * n)
                        }
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(0), o = n(8);
                    i.create = function (t) {
                        return r.extend({bodies: [], pairs: null}, t)
                    }, i.setBodies = function (t, e) {
                        t.bodies = e.slice(0)
                    }, i.clear = function (t) {
                        t.bodies = []
                    }, i.collisions = function (t) {
                        var e, n, r = [], s = t.pairs, a = t.bodies, l = a.length, c = i.canCollide, u = o.collides;
                        for (a.sort(i._compareBoundsX), e = 0; e < l; e++) {
                            var h = a[e], d = h.bounds, p = h.bounds.max.x, f = h.bounds.max.y, m = h.bounds.min.y,
                                g = h.isStatic || h.isSleeping, v = h.parts.length, y = 1 === v;
                            for (n = e + 1; n < l; n++) {
                                var x = a[n];
                                if ((A = x.bounds).min.x > p) break;
                                if (!(f < A.min.y || m > A.max.y) && (!g || !x.isStatic && !x.isSleeping) && c(h.collisionFilter, x.collisionFilter)) {
                                    var _ = x.parts.length;
                                    if (y && 1 === _) (T = u(h, x, s)) && r.push(T); else for (var b = _ > 1 ? 1 : 0, w = v > 1 ? 1 : 0; w < v; w++) for (var S = h.parts[w], M = (d = S.bounds, b); M < _; M++) {
                                        var T, E = x.parts[M], A = E.bounds;
                                        d.min.x > A.max.x || d.max.x < A.min.x || d.max.y < A.min.y || d.min.y > A.max.y || (T = u(S, E, s)) && r.push(T)
                                    }
                                }
                            }
                        }
                        return r
                    }, i.canCollide = function (t, e) {
                        return t.group === e.group && 0 !== t.group ? t.group > 0 : 0 != (t.mask & e.category) && 0 != (e.mask & t.category)
                    }, i._compareBoundsX = function (t, e) {
                        return t.bounds.min.x - e.bounds.min.x
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(0);
                    i._registry = {}, i.register = function (t) {
                        if (i.isPlugin(t) || r.warn("Plugin.register:", i.toString(t), "does not implement all required fields."), t.name in i._registry) {
                            var e = i._registry[t.name], n = i.versionParse(t.version).number,
                                o = i.versionParse(e.version).number;
                            n > o ? (r.warn("Plugin.register:", i.toString(e), "was upgraded to", i.toString(t)), i._registry[t.name] = t) : n < o ? r.warn("Plugin.register:", i.toString(e), "can not be downgraded to", i.toString(t)) : t !== e && r.warn("Plugin.register:", i.toString(t), "is already registered to different plugin object")
                        } else i._registry[t.name] = t;
                        return t
                    }, i.resolve = function (t) {
                        return i._registry[i.dependencyParse(t).name]
                    }, i.toString = function (t) {
                        return "string" == typeof t ? t : (t.name || "anonymous") + "@" + (t.version || t.range || "0.0.0")
                    }, i.isPlugin = function (t) {
                        return t && t.name && t.version && t.install
                    }, i.isUsed = function (t, e) {
                        return t.used.indexOf(e) > -1
                    }, i.isFor = function (t, e) {
                        var n = t.for && i.dependencyParse(t.for);
                        return !t.for || e.name === n.name && i.versionSatisfies(e.version, n.range)
                    }, i.use = function (t, e) {
                        if (t.uses = (t.uses || []).concat(e || []), 0 !== t.uses.length) {
                            for (var n = i.dependencies(t), o = r.topologicalSort(n), s = [], a = 0; a < o.length; a += 1) if (o[a] !== t.name) {
                                var l = i.resolve(o[a]);
                                l ? i.isUsed(t, l.name) || (i.isFor(l, t) || (r.warn("Plugin.use:", i.toString(l), "is for", l.for, "but installed on", i.toString(t) + "."), l._warned = !0), l.install ? l.install(t) : (r.warn("Plugin.use:", i.toString(l), "does not specify an install function."), l._warned = !0), l._warned ? (s.push("ð¶ " + i.toString(l)), delete l._warned) : s.push("â " + i.toString(l)), t.used.push(l.name)) : s.push("â " + o[a])
                            }
                            s.length > 0 && r.info(s.join("  "))
                        } else r.warn("Plugin.use:", i.toString(t), "does not specify any dependencies to install.")
                    }, i.dependencies = function (t, e) {
                        var n = i.dependencyParse(t), o = n.name;
                        if (!(o in (e = e || {}))) {
                            t = i.resolve(t) || t, e[o] = r.map(t.uses || [], (function (e) {
                                i.isPlugin(e) && i.register(e);
                                var o = i.dependencyParse(e), s = i.resolve(e);
                                return s && !i.versionSatisfies(s.version, o.range) ? (r.warn("Plugin.dependencies:", i.toString(s), "does not satisfy", i.toString(o), "used by", i.toString(n) + "."), s._warned = !0, t._warned = !0) : s || (r.warn("Plugin.dependencies:", i.toString(e), "used by", i.toString(n), "could not be resolved."), t._warned = !0), o.name
                            }));
                            for (var s = 0; s < e[o].length; s += 1) i.dependencies(e[o][s], e);
                            return e
                        }
                    }, i.dependencyParse = function (t) {
                        return r.isString(t) ? (/^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/.test(t) || r.warn("Plugin.dependencyParse:", t, "is not a valid dependency string."), {
                            name: t.split("@")[0],
                            range: t.split("@")[1] || "*"
                        }) : {name: t.name, range: t.range || t.version}
                    }, i.versionParse = function (t) {
                        var e = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/;
                        e.test(t) || r.warn("Plugin.versionParse:", t, "is not a valid version or range.");
                        var n = e.exec(t), i = Number(n[4]), o = Number(n[5]), s = Number(n[6]);
                        return {
                            isRange: Boolean(n[1] || n[2]),
                            version: n[3],
                            range: t,
                            operator: n[1] || n[2] || "",
                            major: i,
                            minor: o,
                            patch: s,
                            parts: [i, o, s],
                            prerelease: n[7],
                            number: 1e8 * i + 1e4 * o + s
                        }
                    }, i.versionSatisfies = function (t, e) {
                        e = e || "*";
                        var n = i.versionParse(e), r = i.versionParse(t);
                        if (n.isRange) {
                            if ("*" === n.operator || "*" === t) return !0;
                            if (">" === n.operator) return r.number > n.number;
                            if (">=" === n.operator) return r.number >= n.number;
                            if ("~" === n.operator) return r.major === n.major && r.minor === n.minor && r.patch >= n.patch;
                            if ("^" === n.operator) return n.major > 0 ? r.major === n.major && r.number >= n.number : n.minor > 0 ? r.minor === n.minor && r.patch >= n.patch : r.patch === n.patch
                        }
                        return t === e || "*" === t
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(0), o = n(5), s = n(1), a = n(4), l = n(2), c = n(13);
                    !function () {
                        var t, e;
                        "undefined" != typeof window && (t = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (t) {
                            window.setTimeout((function () {
                                t(r.now())
                            }), 1e3 / 60)
                        }, e = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), i._goodFps = 30, i._goodDelta = 1e3 / 60, i.create = function (t) {
                            var e = {
                                controller: i,
                                engine: null,
                                element: null,
                                canvas: null,
                                mouse: null,
                                frameRequestId: null,
                                timing: {
                                    historySize: 60,
                                    delta: 0,
                                    deltaHistory: [],
                                    lastTime: 0,
                                    lastTimestamp: 0,
                                    lastElapsed: 0,
                                    timestampElapsed: 0,
                                    timestampElapsedHistory: [],
                                    engineDeltaHistory: [],
                                    engineElapsedHistory: [],
                                    elapsedHistory: []
                                },
                                options: {
                                    width: 800,
                                    height: 600,
                                    pixelRatio: 1,
                                    background: "#14151f",
                                    wireframeBackground: "#14151f",
                                    hasBounds: !!t.bounds,
                                    enabled: !0,
                                    wireframes: !0,
                                    showSleeping: !0,
                                    showDebug: !1,
                                    showStats: !1,
                                    showPerformance: !1,
                                    showBounds: !1,
                                    showVelocity: !1,
                                    showCollisions: !1,
                                    showSeparations: !1,
                                    showAxes: !1,
                                    showPositions: !1,
                                    showAngleIndicator: !1,
                                    showIds: !1,
                                    showVertexNumbers: !1,
                                    showConvexHulls: !1,
                                    showInternalEdges: !1,
                                    showMousePosition: !1
                                }
                            }, n = r.extend(e, t);
                            return n.canvas && (n.canvas.width = n.options.width || n.canvas.width, n.canvas.height = n.options.height || n.canvas.height), n.mouse = t.mouse, n.engine = t.engine, n.canvas = n.canvas || h(n.options.width, n.options.height), n.context = n.canvas.getContext("2d"), n.textures = {}, n.bounds = n.bounds || {
                                min: {
                                    x: 0,
                                    y: 0
                                }, max: {x: n.canvas.width, y: n.canvas.height}
                            }, n.options.showBroadphase = !1, 1 !== n.options.pixelRatio && i.setPixelRatio(n, n.options.pixelRatio), r.isElement(n.element) ? n.element.appendChild(n.canvas) : n.canvas.parentNode || r.log("Render.create: options.element was undefined, render.canvas was created but not appended", "warn"), n
                        }, i.run = function (e) {
                            !function r(o) {
                                e.frameRequestId = t(r), n(e, o), i.world(e, o), (e.options.showStats || e.options.showDebug) && i.stats(e, e.context, o), (e.options.showPerformance || e.options.showDebug) && i.performance(e, e.context, o)
                            }()
                        }, i.stop = function (t) {
                            e(t.frameRequestId)
                        }, i.setPixelRatio = function (t, e) {
                            var n = t.options, i = t.canvas;
                            "auto" === e && (e = d(i)), n.pixelRatio = e, i.setAttribute("data-pixel-ratio", e), i.width = n.width * e, i.height = n.height * e, i.style.width = n.width + "px", i.style.height = n.height + "px"
                        }, i.lookAt = function (t, e, n, i) {
                            i = void 0 === i || i, e = r.isArray(e) ? e : [e], n = n || {x: 0, y: 0};
                            for (var o = {
                                min: {x: 1 / 0, y: 1 / 0},
                                max: {x: -1 / 0, y: -1 / 0}
                            }, s = 0; s < e.length; s += 1) {
                                var a = e[s], l = a.bounds ? a.bounds.min : a.min || a.position || a,
                                    u = a.bounds ? a.bounds.max : a.max || a.position || a;
                                l && u && (l.x < o.min.x && (o.min.x = l.x), u.x > o.max.x && (o.max.x = u.x), l.y < o.min.y && (o.min.y = l.y), u.y > o.max.y && (o.max.y = u.y))
                            }
                            var h = o.max.x - o.min.x + 2 * n.x, d = o.max.y - o.min.y + 2 * n.y, p = t.canvas.height,
                                f = t.canvas.width / p, m = h / d, g = 1, v = 1;
                            m > f ? v = m / f : g = f / m, t.options.hasBounds = !0, t.bounds.min.x = o.min.x, t.bounds.max.x = o.min.x + h * g, t.bounds.min.y = o.min.y, t.bounds.max.y = o.min.y + d * v, i && (t.bounds.min.x += .5 * h - h * g * .5, t.bounds.max.x += .5 * h - h * g * .5, t.bounds.min.y += .5 * d - d * v * .5, t.bounds.max.y += .5 * d - d * v * .5), t.bounds.min.x -= n.x, t.bounds.max.x -= n.x, t.bounds.min.y -= n.y, t.bounds.max.y -= n.y, t.mouse && (c.setScale(t.mouse, {
                                x: (t.bounds.max.x - t.bounds.min.x) / t.canvas.width,
                                y: (t.bounds.max.y - t.bounds.min.y) / t.canvas.height
                            }), c.setOffset(t.mouse, t.bounds.min))
                        }, i.startViewTransform = function (t) {
                            var e = t.bounds.max.x - t.bounds.min.x, n = t.bounds.max.y - t.bounds.min.y,
                                i = e / t.options.width, r = n / t.options.height;
                            t.context.setTransform(t.options.pixelRatio / i, 0, 0, t.options.pixelRatio / r, 0, 0), t.context.translate(-t.bounds.min.x, -t.bounds.min.y)
                        }, i.endViewTransform = function (t) {
                            t.context.setTransform(t.options.pixelRatio, 0, 0, t.options.pixelRatio, 0, 0)
                        }, i.world = function (t, e) {
                            var n, u = r.now(), h = t.engine, d = h.world, p = t.canvas, m = t.context, g = t.options,
                                v = t.timing, y = o.allBodies(d), x = o.allConstraints(d),
                                _ = g.wireframes ? g.wireframeBackground : g.background, b = [], w = [],
                                S = {timestamp: h.timing.timestamp};
                            if (a.trigger(t, "beforeRender", S), t.currentBackground !== _ && f(t, _), m.globalCompositeOperation = "source-in", m.fillStyle = "transparent", m.fillRect(0, 0, p.width, p.height), m.globalCompositeOperation = "source-over", g.hasBounds) {
                                for (n = 0; n < y.length; n++) {
                                    var M = y[n];
                                    s.overlaps(M.bounds, t.bounds) && b.push(M)
                                }
                                for (n = 0; n < x.length; n++) {
                                    var T = x[n], E = T.bodyA, A = T.bodyB, P = T.pointA, L = T.pointB;
                                    E && (P = l.add(E.position, T.pointA)), A && (L = l.add(A.position, T.pointB)), P && L && (s.contains(t.bounds, P) || s.contains(t.bounds, L)) && w.push(T)
                                }
                                i.startViewTransform(t), t.mouse && (c.setScale(t.mouse, {
                                    x: (t.bounds.max.x - t.bounds.min.x) / t.options.width,
                                    y: (t.bounds.max.y - t.bounds.min.y) / t.options.height
                                }), c.setOffset(t.mouse, t.bounds.min))
                            } else w = x, b = y, 1 !== t.options.pixelRatio && t.context.setTransform(t.options.pixelRatio, 0, 0, t.options.pixelRatio, 0, 0);
                            !g.wireframes || h.enableSleeping && g.showSleeping ? i.bodies(t, b, m) : (g.showConvexHulls && i.bodyConvexHulls(t, b, m), i.bodyWireframes(t, b, m)), g.showBounds && i.bodyBounds(t, b, m), (g.showAxes || g.showAngleIndicator) && i.bodyAxes(t, b, m), g.showPositions && i.bodyPositions(t, b, m), g.showVelocity && i.bodyVelocity(t, b, m), g.showIds && i.bodyIds(t, b, m), g.showSeparations && i.separations(t, h.pairs.list, m), g.showCollisions && i.collisions(t, h.pairs.list, m), g.showVertexNumbers && i.vertexNumbers(t, b, m), g.showMousePosition && i.mousePosition(t, t.mouse, m), i.constraints(w, m), g.hasBounds && i.endViewTransform(t), a.trigger(t, "afterRender", S), v.lastElapsed = r.now() - u
                        }, i.stats = function (t, e, n) {
                            for (var i = t.engine, r = i.world, s = o.allBodies(r), a = 0, l = 0, c = 0; c < s.length; c += 1) a += s[c].parts.length;
                            var u = {
                                Part: a,
                                Body: s.length,
                                Cons: o.allConstraints(r).length,
                                Comp: o.allComposites(r).length,
                                Pair: i.pairs.list.length
                            };
                            for (var h in e.fillStyle = "#0e0f19", e.fillRect(l, 0, 302.5, 44), e.font = "12px Arial", e.textBaseline = "top", e.textAlign = "right", u) {
                                var d = u[h];
                                e.fillStyle = "#aaa", e.fillText(h, l + 55, 8), e.fillStyle = "#eee", e.fillText(d, l + 55, 26), l += 55
                            }
                        }, i.performance = function (t, e) {
                            var n = t.engine, r = t.timing, o = r.deltaHistory, s = r.elapsedHistory,
                                a = r.timestampElapsedHistory, l = r.engineDeltaHistory, c = r.engineElapsedHistory,
                                h = n.timing.lastDelta, d = u(o), p = u(s), f = u(l), m = u(c), g = u(a) / d || 0,
                                v = 1e3 / d || 0, y = 60;
                            e.fillStyle = "#0e0f19", e.fillRect(0, 50, 370, 34), i.status(e, 10, 69, y, 4, o.length, Math.round(v) + " fps", v / i._goodFps, (function (t) {
                                return o[t] / d - 1
                            })), i.status(e, 82, 69, y, 4, l.length, h.toFixed(2) + " dt", i._goodDelta / h, (function (t) {
                                return l[t] / f - 1
                            })), i.status(e, 154, 69, y, 4, c.length, m.toFixed(2) + " ut", 1 - m / i._goodFps, (function (t) {
                                return c[t] / m - 1
                            })), i.status(e, 226, 69, y, 4, s.length, p.toFixed(2) + " rt", 1 - p / i._goodFps, (function (t) {
                                return s[t] / p - 1
                            })), i.status(e, 298, 69, y, 4, a.length, g.toFixed(2) + " x", g * g * g, (function (t) {
                                return (a[t] / o[t] / g || 0) - 1
                            }))
                        }, i.status = function (t, e, n, i, o, s, a, l, c) {
                            t.strokeStyle = "#888", t.fillStyle = "#444", t.lineWidth = 1, t.fillRect(e, n + 7, i, 1), t.beginPath(), t.moveTo(e, n + 7 - o * r.clamp(.4 * c(0), -2, 2));
                            for (var u = 0; u < i; u += 1) t.lineTo(e + u, n + 7 - (u < s ? o * r.clamp(.4 * c(u), -2, 2) : 0));
                            t.stroke(), t.fillStyle = "hsl(" + r.clamp(25 + 95 * l, 0, 120) + ",100%,60%)", t.fillRect(e, n - 7, 4, 4), t.font = "12px Arial", t.textBaseline = "middle", t.textAlign = "right", t.fillStyle = "#eee", t.fillText(a, e + i, n - 5)
                        }, i.constraints = function (t, e) {
                            for (var n = e, i = 0; i < t.length; i++) {
                                var o = t[i];
                                if (o.render.visible && o.pointA && o.pointB) {
                                    var s, a, c = o.bodyA, u = o.bodyB;
                                    if (s = c ? l.add(c.position, o.pointA) : o.pointA, "pin" === o.render.type) n.beginPath(), n.arc(s.x, s.y, 3, 0, 2 * Math.PI), n.closePath(); else {
                                        if (a = u ? l.add(u.position, o.pointB) : o.pointB, n.beginPath(), n.moveTo(s.x, s.y), "spring" === o.render.type) for (var h, d = l.sub(a, s), p = l.perp(l.normalise(d)), f = Math.ceil(r.clamp(o.length / 5, 12, 20)), m = 1; m < f; m += 1) h = m % 2 == 0 ? 1 : -1, n.lineTo(s.x + d.x * (m / f) + p.x * h * 4, s.y + d.y * (m / f) + p.y * h * 4);
                                        n.lineTo(a.x, a.y)
                                    }
                                    o.render.lineWidth && (n.lineWidth = o.render.lineWidth, n.strokeStyle = o.render.strokeStyle, n.stroke()), o.render.anchors && (n.fillStyle = o.render.strokeStyle, n.beginPath(), n.arc(s.x, s.y, 3, 0, 2 * Math.PI), n.arc(a.x, a.y, 3, 0, 2 * Math.PI), n.closePath(), n.fill())
                                }
                            }
                        }, i.bodies = function (t, e, n) {
                            var i, r, o, s, a = n, l = (t.engine, t.options), c = l.showInternalEdges || !l.wireframes;
                            for (o = 0; o < e.length; o++) if ((i = e[o]).render.visible) for (s = i.parts.length > 1 ? 1 : 0; s < i.parts.length; s++) if ((r = i.parts[s]).render.visible) {
                                if (l.showSleeping && i.isSleeping ? a.globalAlpha = .5 * r.render.opacity : 1 !== r.render.opacity && (a.globalAlpha = r.render.opacity), r.render.sprite && r.render.sprite.texture && !l.wireframes) {
                                    var u = r.render.sprite, h = p(t, u.texture);
                                    a.translate(r.position.x, r.position.y), a.rotate(r.angle), a.drawImage(h, h.width * -u.xOffset * u.xScale, h.height * -u.yOffset * u.yScale, h.width * u.xScale, h.height * u.yScale), a.rotate(-r.angle), a.translate(-r.position.x, -r.position.y)
                                } else {
                                    if (r.circleRadius) a.beginPath(), a.arc(r.position.x, r.position.y, r.circleRadius, 0, 2 * Math.PI); else {
                                        a.beginPath(), a.moveTo(r.vertices[0].x, r.vertices[0].y);
                                        for (var d = 1; d < r.vertices.length; d++) !r.vertices[d - 1].isInternal || c ? a.lineTo(r.vertices[d].x, r.vertices[d].y) : a.moveTo(r.vertices[d].x, r.vertices[d].y), r.vertices[d].isInternal && !c && a.moveTo(r.vertices[(d + 1) % r.vertices.length].x, r.vertices[(d + 1) % r.vertices.length].y);
                                        a.lineTo(r.vertices[0].x, r.vertices[0].y), a.closePath()
                                    }
                                    l.wireframes ? (a.lineWidth = 1, a.strokeStyle = "#bbb", a.stroke()) : (a.fillStyle = r.render.fillStyle, r.render.lineWidth && (a.lineWidth = r.render.lineWidth, a.strokeStyle = r.render.strokeStyle, a.stroke()), a.fill())
                                }
                                a.globalAlpha = 1
                            }
                        }, i.bodyWireframes = function (t, e, n) {
                            var i, r, o, s, a, l = n, c = t.options.showInternalEdges;
                            for (l.beginPath(), o = 0; o < e.length; o++) if ((i = e[o]).render.visible) for (a = i.parts.length > 1 ? 1 : 0; a < i.parts.length; a++) {
                                for (r = i.parts[a], l.moveTo(r.vertices[0].x, r.vertices[0].y), s = 1; s < r.vertices.length; s++) !r.vertices[s - 1].isInternal || c ? l.lineTo(r.vertices[s].x, r.vertices[s].y) : l.moveTo(r.vertices[s].x, r.vertices[s].y), r.vertices[s].isInternal && !c && l.moveTo(r.vertices[(s + 1) % r.vertices.length].x, r.vertices[(s + 1) % r.vertices.length].y);
                                l.lineTo(r.vertices[0].x, r.vertices[0].y)
                            }
                            l.lineWidth = 1, l.strokeStyle = "#bbb", l.stroke()
                        }, i.bodyConvexHulls = function (t, e, n) {
                            var i, r, o, s = n;
                            for (s.beginPath(), r = 0; r < e.length; r++) if ((i = e[r]).render.visible && 1 !== i.parts.length) {
                                for (s.moveTo(i.vertices[0].x, i.vertices[0].y), o = 1; o < i.vertices.length; o++) s.lineTo(i.vertices[o].x, i.vertices[o].y);
                                s.lineTo(i.vertices[0].x, i.vertices[0].y)
                            }
                            s.lineWidth = 1, s.strokeStyle = "rgba(255,255,255,0.2)", s.stroke()
                        }, i.vertexNumbers = function (t, e, n) {
                            var i, r, o, s = n;
                            for (i = 0; i < e.length; i++) {
                                var a = e[i].parts;
                                for (o = a.length > 1 ? 1 : 0; o < a.length; o++) {
                                    var l = a[o];
                                    for (r = 0; r < l.vertices.length; r++) s.fillStyle = "rgba(255,255,255,0.2)", s.fillText(i + "_" + r, l.position.x + .8 * (l.vertices[r].x - l.position.x), l.position.y + .8 * (l.vertices[r].y - l.position.y))
                                }
                            }
                        }, i.mousePosition = function (t, e, n) {
                            var i = n;
                            i.fillStyle = "rgba(255,255,255,0.8)", i.fillText(e.position.x + "  " + e.position.y, e.position.x + 5, e.position.y - 5)
                        }, i.bodyBounds = function (t, e, n) {
                            var i = n, r = (t.engine, t.options);
                            i.beginPath();
                            for (var o = 0; o < e.length; o++) if (e[o].render.visible) for (var s = e[o].parts, a = s.length > 1 ? 1 : 0; a < s.length; a++) {
                                var l = s[a];
                                i.rect(l.bounds.min.x, l.bounds.min.y, l.bounds.max.x - l.bounds.min.x, l.bounds.max.y - l.bounds.min.y)
                            }
                            r.wireframes ? i.strokeStyle = "rgba(255,255,255,0.08)" : i.strokeStyle = "rgba(0,0,0,0.1)", i.lineWidth = 1, i.stroke()
                        }, i.bodyAxes = function (t, e, n) {
                            var i, r, o, s, a = n, l = (t.engine, t.options);
                            for (a.beginPath(), r = 0; r < e.length; r++) {
                                var c = e[r], u = c.parts;
                                if (c.render.visible) if (l.showAxes) for (o = u.length > 1 ? 1 : 0; o < u.length; o++) for (i = u[o], s = 0; s < i.axes.length; s++) {
                                    var h = i.axes[s];
                                    a.moveTo(i.position.x, i.position.y), a.lineTo(i.position.x + 20 * h.x, i.position.y + 20 * h.y)
                                } else for (o = u.length > 1 ? 1 : 0; o < u.length; o++) for (i = u[o], s = 0; s < i.axes.length; s++) a.moveTo(i.position.x, i.position.y), a.lineTo((i.vertices[0].x + i.vertices[i.vertices.length - 1].x) / 2, (i.vertices[0].y + i.vertices[i.vertices.length - 1].y) / 2)
                            }
                            l.wireframes ? (a.strokeStyle = "indianred", a.lineWidth = 1) : (a.strokeStyle = "rgba(255, 255, 255, 0.4)", a.globalCompositeOperation = "overlay", a.lineWidth = 2), a.stroke(), a.globalCompositeOperation = "source-over"
                        }, i.bodyPositions = function (t, e, n) {
                            var i, r, o, s, a = n, l = (t.engine, t.options);
                            for (a.beginPath(), o = 0; o < e.length; o++) if ((i = e[o]).render.visible) for (s = 0; s < i.parts.length; s++) r = i.parts[s], a.arc(r.position.x, r.position.y, 3, 0, 2 * Math.PI, !1), a.closePath();
                            for (l.wireframes ? a.fillStyle = "indianred" : a.fillStyle = "rgba(0,0,0,0.5)", a.fill(), a.beginPath(), o = 0; o < e.length; o++) (i = e[o]).render.visible && (a.arc(i.positionPrev.x, i.positionPrev.y, 2, 0, 2 * Math.PI, !1), a.closePath());
                            a.fillStyle = "rgba(255,165,0,0.8)", a.fill()
                        }, i.bodyVelocity = function (t, e, n) {
                            var i = n;
                            i.beginPath();
                            for (var r = 0; r < e.length; r++) {
                                var o = e[r];
                                o.render.visible && (i.moveTo(o.position.x, o.position.y), i.lineTo(o.position.x + 2 * (o.position.x - o.positionPrev.x), o.position.y + 2 * (o.position.y - o.positionPrev.y)))
                            }
                            i.lineWidth = 3, i.strokeStyle = "cornflowerblue", i.stroke()
                        }, i.bodyIds = function (t, e, n) {
                            var i, r, o = n;
                            for (i = 0; i < e.length; i++) if (e[i].render.visible) {
                                var s = e[i].parts;
                                for (r = s.length > 1 ? 1 : 0; r < s.length; r++) {
                                    var a = s[r];
                                    o.font = "12px Arial", o.fillStyle = "rgba(255,255,255,0.5)", o.fillText(a.id, a.position.x + 10, a.position.y - 10)
                                }
                            }
                        }, i.collisions = function (t, e, n) {
                            var i, r, o, s, a = n, l = t.options;
                            for (a.beginPath(), o = 0; o < e.length; o++) if ((i = e[o]).isActive) for (r = i.collision, s = 0; s < i.activeContacts.length; s++) {
                                var c = i.activeContacts[s].vertex;
                                a.rect(c.x - 1.5, c.y - 1.5, 3.5, 3.5)
                            }
                            for (l.wireframes ? a.fillStyle = "rgba(255,255,255,0.7)" : a.fillStyle = "orange", a.fill(), a.beginPath(), o = 0; o < e.length; o++) if ((i = e[o]).isActive && (r = i.collision, i.activeContacts.length > 0)) {
                                var u = i.activeContacts[0].vertex.x, h = i.activeContacts[0].vertex.y;
                                2 === i.activeContacts.length && (u = (i.activeContacts[0].vertex.x + i.activeContacts[1].vertex.x) / 2, h = (i.activeContacts[0].vertex.y + i.activeContacts[1].vertex.y) / 2), r.bodyB === r.supports[0].body || !0 === r.bodyA.isStatic ? a.moveTo(u - 8 * r.normal.x, h - 8 * r.normal.y) : a.moveTo(u + 8 * r.normal.x, h + 8 * r.normal.y), a.lineTo(u, h)
                            }
                            l.wireframes ? a.strokeStyle = "rgba(255,165,0,0.7)" : a.strokeStyle = "orange", a.lineWidth = 1, a.stroke()
                        }, i.separations = function (t, e, n) {
                            var i, r, o, s, a, l = n, c = t.options;
                            for (l.beginPath(), a = 0; a < e.length; a++) if ((i = e[a]).isActive) {
                                o = (r = i.collision).bodyA;
                                var u = 1;
                                (s = r.bodyB).isStatic || o.isStatic || (u = .5), s.isStatic && (u = 0), l.moveTo(s.position.x, s.position.y), l.lineTo(s.position.x - r.penetration.x * u, s.position.y - r.penetration.y * u), u = 1, s.isStatic || o.isStatic || (u = .5), o.isStatic && (u = 0), l.moveTo(o.position.x, o.position.y), l.lineTo(o.position.x + r.penetration.x * u, o.position.y + r.penetration.y * u)
                            }
                            c.wireframes ? l.strokeStyle = "rgba(255,165,0,0.5)" : l.strokeStyle = "orange", l.stroke()
                        }, i.inspector = function (t, e) {
                            t.engine;
                            var n, i = t.selected, r = t.render, o = r.options;
                            if (o.hasBounds) {
                                var s = r.bounds.max.x - r.bounds.min.x, a = r.bounds.max.y - r.bounds.min.y,
                                    l = s / r.options.width, c = a / r.options.height;
                                e.scale(1 / l, 1 / c), e.translate(-r.bounds.min.x, -r.bounds.min.y)
                            }
                            for (var u = 0; u < i.length; u++) {
                                var h = i[u].data;
                                switch (e.translate(.5, .5), e.lineWidth = 1, e.strokeStyle = "rgba(255,165,0,0.9)", e.setLineDash([1, 2]), h.type) {
                                    case"body":
                                        n = h.bounds, e.beginPath(), e.rect(Math.floor(n.min.x - 3), Math.floor(n.min.y - 3), Math.floor(n.max.x - n.min.x + 6), Math.floor(n.max.y - n.min.y + 6)), e.closePath(), e.stroke();
                                        break;
                                    case"constraint":
                                        var d = h.pointA;
                                        h.bodyA && (d = h.pointB), e.beginPath(), e.arc(d.x, d.y, 10, 0, 2 * Math.PI), e.closePath(), e.stroke()
                                }
                                e.setLineDash([]), e.translate(-.5, -.5)
                            }
                            null !== t.selectStart && (e.translate(.5, .5), e.lineWidth = 1, e.strokeStyle = "rgba(255,165,0,0.6)", e.fillStyle = "rgba(255,165,0,0.1)", n = t.selectBounds, e.beginPath(), e.rect(Math.floor(n.min.x), Math.floor(n.min.y), Math.floor(n.max.x - n.min.x), Math.floor(n.max.y - n.min.y)), e.closePath(), e.stroke(), e.fill(), e.translate(-.5, -.5)), o.hasBounds && e.setTransform(1, 0, 0, 1, 0, 0)
                        };
                        var n = function (t, e) {
                            var n = t.engine, r = t.timing, o = r.historySize, s = n.timing.timestamp;
                            r.delta = e - r.lastTime || i._goodDelta, r.lastTime = e, r.timestampElapsed = s - r.lastTimestamp || 0, r.lastTimestamp = s, r.deltaHistory.unshift(r.delta), r.deltaHistory.length = Math.min(r.deltaHistory.length, o), r.engineDeltaHistory.unshift(n.timing.lastDelta), r.engineDeltaHistory.length = Math.min(r.engineDeltaHistory.length, o), r.timestampElapsedHistory.unshift(r.timestampElapsed), r.timestampElapsedHistory.length = Math.min(r.timestampElapsedHistory.length, o), r.engineElapsedHistory.unshift(n.timing.lastElapsed), r.engineElapsedHistory.length = Math.min(r.engineElapsedHistory.length, o), r.elapsedHistory.unshift(r.lastElapsed), r.elapsedHistory.length = Math.min(r.elapsedHistory.length, o)
                        }, u = function (t) {
                            for (var e = 0, n = 0; n < t.length; n += 1) e += t[n];
                            return e / t.length || 0
                        }, h = function (t, e) {
                            var n = document.createElement("canvas");
                            return n.width = t, n.height = e, n.oncontextmenu = function () {
                                return !1
                            }, n.onselectstart = function () {
                                return !1
                            }, n
                        }, d = function (t) {
                            var e = t.getContext("2d");
                            return (window.devicePixelRatio || 1) / (e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1)
                        }, p = function (t, e) {
                            var n = t.textures[e];
                            return n || ((n = t.textures[e] = new Image).src = e, n)
                        }, f = function (t, e) {
                            var n = e;
                            /(jpg|gif|png)$/.test(e) && (n = "url(" + e + ")"), t.canvas.style.background = n, t.canvas.style.backgroundSize = "contain", t.currentBackground = e
                        }
                    }()
                }, function (t, e) {
                    var n = {};
                    t.exports = n, n.create = function (t) {
                        return {vertex: t, normalImpulse: 0, tangentImpulse: 0}
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(7), o = n(19), s = n(14), a = n(20), l = n(4), c = n(5), u = n(10), h = n(0), d = n(6);
                    i.create = function (t) {
                        t = t || {};
                        var e = h.extend({
                            positionIterations: 6,
                            velocityIterations: 4,
                            constraintIterations: 2,
                            enableSleeping: !1,
                            events: [],
                            plugin: {},
                            gravity: {x: 0, y: 1, scale: .001},
                            timing: {timestamp: 0, timeScale: 1, lastDelta: 0, lastElapsed: 0}
                        }, t);
                        return e.world = t.world || c.create({label: "World"}), e.pairs = t.pairs || a.create(), e.detector = t.detector || s.create(), e.grid = {buckets: []}, e.world.gravity = e.gravity, e.broadphase = e.grid, e.metrics = {}, e
                    }, i.update = function (t, e, n) {
                        var d = h.now();
                        e = e || 1e3 / 60, n = n || 1;
                        var p, f = t.world, m = t.detector, g = t.pairs, v = t.timing, y = v.timestamp;
                        v.timestamp += e * v.timeScale, v.lastDelta = e * v.timeScale;
                        var x = {timestamp: v.timestamp};
                        l.trigger(t, "beforeUpdate", x);
                        var _ = c.allBodies(f), b = c.allConstraints(f);
                        for (f.isModified && s.setBodies(m, _), f.isModified && c.setModified(f, !1, !1, !0), t.enableSleeping && r.update(_, v.timeScale), i._bodiesApplyGravity(_, t.gravity), i._bodiesUpdate(_, e, v.timeScale, n, f.bounds), u.preSolveAll(_), p = 0; p < t.constraintIterations; p++) u.solveAll(b, v.timeScale);
                        u.postSolveAll(_), m.pairs = t.pairs;
                        var w = s.collisions(m);
                        for (a.update(g, w, y), t.enableSleeping && r.afterCollisions(g.list, v.timeScale), g.collisionStart.length > 0 && l.trigger(t, "collisionStart", {pairs: g.collisionStart}), o.preSolvePosition(g.list), p = 0; p < t.positionIterations; p++) o.solvePosition(g.list, v.timeScale);
                        for (o.postSolvePosition(_), u.preSolveAll(_), p = 0; p < t.constraintIterations; p++) u.solveAll(b, v.timeScale);
                        for (u.postSolveAll(_), o.preSolveVelocity(g.list), p = 0; p < t.velocityIterations; p++) o.solveVelocity(g.list, v.timeScale);
                        return g.collisionActive.length > 0 && l.trigger(t, "collisionActive", {pairs: g.collisionActive}), g.collisionEnd.length > 0 && l.trigger(t, "collisionEnd", {pairs: g.collisionEnd}), i._bodiesClearForces(_), l.trigger(t, "afterUpdate", x), t.timing.lastElapsed = h.now() - d, t
                    }, i.merge = function (t, e) {
                        if (h.extend(t, e), e.world) {
                            t.world = e.world, i.clear(t);
                            for (var n = c.allBodies(t.world), o = 0; o < n.length; o++) {
                                var s = n[o];
                                r.set(s, !1), s.id = h.nextId()
                            }
                        }
                    }, i.clear = function (t) {
                        a.clear(t.pairs), s.clear(t.detector)
                    }, i._bodiesClearForces = function (t) {
                        for (var e = 0; e < t.length; e++) {
                            var n = t[e];
                            n.force.x = 0, n.force.y = 0, n.torque = 0
                        }
                    }, i._bodiesApplyGravity = function (t, e) {
                        var n = void 0 !== e.scale ? e.scale : .001;
                        if ((0 !== e.x || 0 !== e.y) && 0 !== n) for (var i = 0; i < t.length; i++) {
                            var r = t[i];
                            r.isStatic || r.isSleeping || (r.force.y += r.mass * e.y * n, r.force.x += r.mass * e.x * n)
                        }
                    }, i._bodiesUpdate = function (t, e, n, i, r) {
                        for (var o = 0; o < t.length; o++) {
                            var s = t[o];
                            s.isStatic || s.isSleeping || d.update(s, e, n, i)
                        }
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(3), o = n(1);
                    i._restingThresh = 4, i._restingThreshTangent = 6, i._positionDampen = .9, i._positionWarming = .8, i._frictionNormalMultiplier = 5, i.preSolvePosition = function (t) {
                        var e, n, i, r = t.length;
                        for (e = 0; e < r; e++) (n = t[e]).isActive && (i = n.activeContacts.length, n.collision.parentA.totalContacts += i, n.collision.parentB.totalContacts += i)
                    }, i.solvePosition = function (t, e) {
                        var n, r, o, s, a, l, c, u, h = i._positionDampen, d = t.length;
                        for (n = 0; n < d; n++) (r = t[n]).isActive && !r.isSensor && (s = (o = r.collision).parentA, a = o.parentB, l = o.normal, r.separation = l.x * (a.positionImpulse.x + o.penetration.x - s.positionImpulse.x) + l.y * (a.positionImpulse.y + o.penetration.y - s.positionImpulse.y));
                        for (n = 0; n < d; n++) (r = t[n]).isActive && !r.isSensor && (s = (o = r.collision).parentA, a = o.parentB, l = o.normal, u = (r.separation - r.slop) * e, (s.isStatic || a.isStatic) && (u *= 2), s.isStatic || s.isSleeping || (c = h / s.totalContacts, s.positionImpulse.x += l.x * u * c, s.positionImpulse.y += l.y * u * c), a.isStatic || a.isSleeping || (c = h / a.totalContacts, a.positionImpulse.x -= l.x * u * c, a.positionImpulse.y -= l.y * u * c))
                    }, i.postSolvePosition = function (t) {
                        for (var e = i._positionWarming, n = t.length, s = r.translate, a = o.update, l = 0; l < n; l++) {
                            var c = t[l], u = c.positionImpulse, h = u.x, d = u.y, p = c.velocity;
                            if (c.totalContacts = 0, 0 !== h || 0 !== d) {
                                for (var f = 0; f < c.parts.length; f++) {
                                    var m = c.parts[f];
                                    s(m.vertices, u), a(m.bounds, m.vertices, p), m.position.x += h, m.position.y += d
                                }
                                c.positionPrev.x += h, c.positionPrev.y += d, h * p.x + d * p.y < 0 ? (u.x = 0, u.y = 0) : (u.x *= e, u.y *= e)
                            }
                        }
                    }, i.preSolveVelocity = function (t) {
                        var e, n, i = t.length;
                        for (e = 0; e < i; e++) {
                            var r = t[e];
                            if (r.isActive && !r.isSensor) {
                                var o = r.activeContacts, s = o.length, a = r.collision, l = a.parentA, c = a.parentB,
                                    u = a.normal, h = a.tangent;
                                for (n = 0; n < s; n++) {
                                    var d = o[n], p = d.vertex, f = d.normalImpulse, m = d.tangentImpulse;
                                    if (0 !== f || 0 !== m) {
                                        var g = u.x * f + h.x * m, v = u.y * f + h.y * m;
                                        l.isStatic || l.isSleeping || (l.positionPrev.x += g * l.inverseMass, l.positionPrev.y += v * l.inverseMass, l.anglePrev += l.inverseInertia * ((p.x - l.position.x) * v - (p.y - l.position.y) * g)), c.isStatic || c.isSleeping || (c.positionPrev.x -= g * c.inverseMass, c.positionPrev.y -= v * c.inverseMass, c.anglePrev -= c.inverseInertia * ((p.x - c.position.x) * v - (p.y - c.position.y) * g))
                                    }
                                }
                            }
                        }
                    }, i.solveVelocity = function (t, e) {
                        var n, r, o, s, a = e * e, l = i._restingThresh * a, c = i._frictionNormalMultiplier,
                            u = i._restingThreshTangent * a, h = Number.MAX_VALUE, d = t.length;
                        for (o = 0; o < d; o++) {
                            var p = t[o];
                            if (p.isActive && !p.isSensor) {
                                var f = p.collision, m = f.parentA, g = f.parentB, v = m.velocity, y = g.velocity,
                                    x = f.normal.x, _ = f.normal.y, b = f.tangent.x, w = f.tangent.y,
                                    S = p.activeContacts, M = S.length, T = 1 / M, E = m.inverseMass + g.inverseMass,
                                    A = p.friction * p.frictionStatic * c * a;
                                for (v.x = m.position.x - m.positionPrev.x, v.y = m.position.y - m.positionPrev.y, y.x = g.position.x - g.positionPrev.x, y.y = g.position.y - g.positionPrev.y, m.angularVelocity = m.angle - m.anglePrev, g.angularVelocity = g.angle - g.anglePrev, s = 0; s < M; s++) {
                                    var P = S[s], L = P.vertex, C = L.x - m.position.x, R = L.y - m.position.y,
                                        I = L.x - g.position.x, O = L.y - g.position.y, D = v.x - R * m.angularVelocity,
                                        z = v.y + C * m.angularVelocity, k = D - (y.x - O * g.angularVelocity),
                                        N = z - (y.y + I * g.angularVelocity), B = x * k + _ * N, F = b * k + w * N,
                                        U = p.separation + B, H = Math.min(U, 1), V = (H = U < 0 ? 0 : H) * A;
                                    F > V || -F > V ? (r = F > 0 ? F : -F, (n = p.friction * (F > 0 ? 1 : -1) * a) < -r ? n = -r : n > r && (n = r)) : (n = F, r = h);
                                    var G = C * _ - R * x, W = I * _ - O * x,
                                        j = T / (E + m.inverseInertia * G * G + g.inverseInertia * W * W),
                                        q = (1 + p.restitution) * B * j;
                                    if (n *= j, B * B > l && B < 0) P.normalImpulse = 0; else {
                                        var X = P.normalImpulse;
                                        P.normalImpulse += q, P.normalImpulse = Math.min(P.normalImpulse, 0), q = P.normalImpulse - X
                                    }
                                    if (F * F > u) P.tangentImpulse = 0; else {
                                        var Y = P.tangentImpulse;
                                        P.tangentImpulse += n, P.tangentImpulse < -r && (P.tangentImpulse = -r), P.tangentImpulse > r && (P.tangentImpulse = r), n = P.tangentImpulse - Y
                                    }
                                    var J = x * q + b * n, Z = _ * q + w * n;
                                    m.isStatic || m.isSleeping || (m.positionPrev.x += J * m.inverseMass, m.positionPrev.y += Z * m.inverseMass, m.anglePrev += (C * Z - R * J) * m.inverseInertia), g.isStatic || g.isSleeping || (g.positionPrev.x -= J * g.inverseMass, g.positionPrev.y -= Z * g.inverseMass, g.anglePrev -= (I * Z - O * J) * g.inverseInertia)
                                }
                            }
                        }
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(9), o = n(0);
                    i.create = function (t) {
                        return o.extend({
                            table: {},
                            list: [],
                            collisionStart: [],
                            collisionActive: [],
                            collisionEnd: []
                        }, t)
                    }, i.update = function (t, e, n) {
                        var i, o, s, a, l = t.list, c = l.length, u = t.table, h = e.length, d = t.collisionStart,
                            p = t.collisionEnd, f = t.collisionActive;
                        for (d.length = 0, p.length = 0, f.length = 0, a = 0; a < c; a++) l[a].confirmedActive = !1;
                        for (a = 0; a < h; a++) (s = (i = e[a]).pair) ? (s.isActive ? f.push(s) : d.push(s), r.update(s, i, n), s.confirmedActive = !0) : (u[(s = r.create(i, n)).id] = s, d.push(s), l.push(s));
                        var m = [];
                        for (c = l.length, a = 0; a < c; a++) (s = l[a]).confirmedActive || (r.setActive(s, !1, n), p.push(s), s.collision.bodyA.isSleeping || s.collision.bodyB.isSleeping || m.push(a));
                        for (a = 0; a < m.length; a++) s = l[o = m[a] - a], l.splice(o, 1), delete u[s.id]
                    }, i.clear = function (t) {
                        return t.table = {}, t.list.length = 0, t.collisionStart.length = 0, t.collisionActive.length = 0, t.collisionEnd.length = 0, t
                    }
                }, function (t, e, n) {
                    var i = t.exports = n(22);
                    i.Axes = n(11), i.Bodies = n(12), i.Body = n(6), i.Bounds = n(1), i.Collision = n(8), i.Common = n(0), i.Composite = n(5), i.Composites = n(23), i.Constraint = n(10), i.Contact = n(17), i.Detector = n(14), i.Engine = n(18), i.Events = n(4), i.Grid = n(24), i.Mouse = n(13), i.MouseConstraint = n(25), i.Pair = n(9), i.Pairs = n(20), i.Plugin = n(15), i.Query = n(26), i.Render = n(16), i.Resolver = n(19), i.Runner = n(27), i.SAT = n(28), i.Sleeping = n(7), i.Svg = n(29), i.Vector = n(2), i.Vertices = n(3), i.World = n(30), i.Engine.run = i.Runner.run, i.Common.deprecated(i.Engine, "run", "Engine.run â¤ use Matter.Runner.run(engine) instead")
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(15), o = n(0);
                    i.name = "matter-js", i.version = "0.18.0", i.uses = [], i.used = [], i.use = function () {
                        r.use(i, Array.prototype.slice.call(arguments))
                    }, i.before = function (t, e) {
                        return t = t.replace(/^Matter./, ""), o.chainPathBefore(i, t, e)
                    }, i.after = function (t, e) {
                        return t = t.replace(/^Matter./, ""), o.chainPathAfter(i, t, e)
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(5), o = n(10), s = n(0), a = n(6), l = n(12), c = s.deprecated;
                    i.stack = function (t, e, n, i, o, s, l) {
                        for (var c, u = r.create({label: "Stack"}), h = t, d = e, p = 0, f = 0; f < i; f++) {
                            for (var m = 0, g = 0; g < n; g++) {
                                var v = l(h, d, g, f, c, p);
                                if (v) {
                                    var y = v.bounds.max.y - v.bounds.min.y, x = v.bounds.max.x - v.bounds.min.x;
                                    y > m && (m = y), a.translate(v, {
                                        x: .5 * x,
                                        y: .5 * y
                                    }), h = v.bounds.max.x + o, r.addBody(u, v), c = v, p += 1
                                } else h += o
                            }
                            d += m + s, h = t
                        }
                        return u
                    }, i.chain = function (t, e, n, i, a, l) {
                        for (var c = t.bodies, u = 1; u < c.length; u++) {
                            var h = c[u - 1], d = c[u], p = h.bounds.max.y - h.bounds.min.y,
                                f = h.bounds.max.x - h.bounds.min.x, m = d.bounds.max.y - d.bounds.min.y, g = {
                                    bodyA: h,
                                    pointA: {x: f * e, y: p * n},
                                    bodyB: d,
                                    pointB: {x: (d.bounds.max.x - d.bounds.min.x) * i, y: m * a}
                                }, v = s.extend(g, l);
                            r.addConstraint(t, o.create(v))
                        }
                        return t.label += " Chain", t
                    }, i.mesh = function (t, e, n, i, a) {
                        var l, c, u, h, d, p = t.bodies;
                        for (l = 0; l < n; l++) {
                            for (c = 1; c < e; c++) u = p[c - 1 + l * e], h = p[c + l * e], r.addConstraint(t, o.create(s.extend({
                                bodyA: u,
                                bodyB: h
                            }, a)));
                            if (l > 0) for (c = 0; c < e; c++) u = p[c + (l - 1) * e], h = p[c + l * e], r.addConstraint(t, o.create(s.extend({
                                bodyA: u,
                                bodyB: h
                            }, a))), i && c > 0 && (d = p[c - 1 + (l - 1) * e], r.addConstraint(t, o.create(s.extend({
                                bodyA: d,
                                bodyB: h
                            }, a)))), i && c < e - 1 && (d = p[c + 1 + (l - 1) * e], r.addConstraint(t, o.create(s.extend({
                                bodyA: d,
                                bodyB: h
                            }, a))))
                        }
                        return t.label += " Mesh", t
                    }, i.pyramid = function (t, e, n, r, o, s, l) {
                        return i.stack(t, e, n, r, o, s, (function (e, i, s, c, u, h) {
                            var d = Math.min(r, Math.ceil(n / 2)), p = u ? u.bounds.max.x - u.bounds.min.x : 0;
                            if (!(c > d || s < (c = d - c) || s > n - 1 - c)) return 1 === h && a.translate(u, {
                                x: (s + (n % 2 == 1 ? 1 : -1)) * p,
                                y: 0
                            }), l(t + (u ? s * p : 0) + s * o, i, s, c, u, h)
                        }))
                    }, i.newtonsCradle = function (t, e, n, i, s) {
                        for (var a = r.create({label: "Newtons Cradle"}), c = 0; c < n; c++) {
                            var u = l.circle(t + c * (1.9 * i), e + s, i, {
                                inertia: 1 / 0,
                                restitution: 1,
                                friction: 0,
                                frictionAir: 1e-4,
                                slop: 1
                            }), h = o.create({pointA: {x: t + c * (1.9 * i), y: e}, bodyB: u});
                            r.addBody(a, u), r.addConstraint(a, h)
                        }
                        return a
                    }, c(i, "newtonsCradle", "Composites.newtonsCradle â¤ moved to newtonsCradle example"), i.car = function (t, e, n, i, s) {
                        var c = a.nextGroup(!0), u = .5 * -n + 20, h = .5 * n - 20, d = r.create({label: "Car"}),
                            p = l.rectangle(t, e, n, i, {
                                collisionFilter: {group: c},
                                chamfer: {radius: .5 * i},
                                density: 2e-4
                            }), f = l.circle(t + u, e + 0, s, {collisionFilter: {group: c}, friction: .8}),
                            m = l.circle(t + h, e + 0, s, {collisionFilter: {group: c}, friction: .8}),
                            g = o.create({bodyB: p, pointB: {x: u, y: 0}, bodyA: f, stiffness: 1, length: 0}),
                            v = o.create({bodyB: p, pointB: {x: h, y: 0}, bodyA: m, stiffness: 1, length: 0});
                        return r.addBody(d, p), r.addBody(d, f), r.addBody(d, m), r.addConstraint(d, g), r.addConstraint(d, v), d
                    }, c(i, "car", "Composites.car â¤ moved to car example"), i.softBody = function (t, e, n, r, o, a, c, u, h, d) {
                        h = s.extend({inertia: 1 / 0}, h), d = s.extend({
                            stiffness: .2,
                            render: {type: "line", anchors: !1}
                        }, d);
                        var p = i.stack(t, e, n, r, o, a, (function (t, e) {
                            return l.circle(t, e, u, h)
                        }));
                        return i.mesh(p, n, r, c, d), p.label = "Soft Body", p
                    }, c(i, "softBody", "Composites.softBody â¤ moved to softBody and cloth examples")
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(9), o = n(0), s = o.deprecated;
                    i.create = function (t) {
                        return o.extend({buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48}, t)
                    }, i.update = function (t, e, n, r) {
                        var o, s, a, l, c, u = n.world, h = t.buckets, d = !1;
                        for (o = 0; o < e.length; o++) {
                            var p = e[o];
                            if ((!p.isSleeping || r) && (!u.bounds || !(p.bounds.max.x < u.bounds.min.x || p.bounds.min.x > u.bounds.max.x || p.bounds.max.y < u.bounds.min.y || p.bounds.min.y > u.bounds.max.y))) {
                                var f = i._getRegion(t, p);
                                if (!p.region || f.id !== p.region.id || r) {
                                    p.region && !r || (p.region = f);
                                    var m = i._regionUnion(f, p.region);
                                    for (s = m.startCol; s <= m.endCol; s++) for (a = m.startRow; a <= m.endRow; a++) {
                                        l = h[c = i._getBucketId(s, a)];
                                        var g = s >= f.startCol && s <= f.endCol && a >= f.startRow && a <= f.endRow,
                                            v = s >= p.region.startCol && s <= p.region.endCol && a >= p.region.startRow && a <= p.region.endRow;
                                        !g && v && v && l && i._bucketRemoveBody(t, l, p), (p.region === f || g && !v || r) && (l || (l = i._createBucket(h, c)), i._bucketAddBody(t, l, p))
                                    }
                                    p.region = f, d = !0
                                }
                            }
                        }
                        d && (t.pairsList = i._createActivePairsList(t))
                    }, s(i, "update", "Grid.update â¤ replaced by Matter.Detector"), i.clear = function (t) {
                        t.buckets = {}, t.pairs = {}, t.pairsList = []
                    }, s(i, "clear", "Grid.clear â¤ replaced by Matter.Detector"), i._regionUnion = function (t, e) {
                        var n = Math.min(t.startCol, e.startCol), r = Math.max(t.endCol, e.endCol),
                            o = Math.min(t.startRow, e.startRow), s = Math.max(t.endRow, e.endRow);
                        return i._createRegion(n, r, o, s)
                    }, i._getRegion = function (t, e) {
                        var n = e.bounds, r = Math.floor(n.min.x / t.bucketWidth),
                            o = Math.floor(n.max.x / t.bucketWidth), s = Math.floor(n.min.y / t.bucketHeight),
                            a = Math.floor(n.max.y / t.bucketHeight);
                        return i._createRegion(r, o, s, a)
                    }, i._createRegion = function (t, e, n, i) {
                        return {id: t + "," + e + "," + n + "," + i, startCol: t, endCol: e, startRow: n, endRow: i}
                    }, i._getBucketId = function (t, e) {
                        return "C" + t + "R" + e
                    }, i._createBucket = function (t, e) {
                        return t[e] = []
                    }, i._bucketAddBody = function (t, e, n) {
                        var i, o = t.pairs, s = r.id, a = e.length;
                        for (i = 0; i < a; i++) {
                            var l = e[i];
                            if (!(n.id === l.id || n.isStatic && l.isStatic)) {
                                var c = s(n, l), u = o[c];
                                u ? u[2] += 1 : o[c] = [n, l, 1]
                            }
                        }
                        e.push(n)
                    }, i._bucketRemoveBody = function (t, e, n) {
                        var i, s = t.pairs, a = r.id;
                        e.splice(o.indexOf(e, n), 1);
                        var l = e.length;
                        for (i = 0; i < l; i++) {
                            var c = s[a(n, e[i])];
                            c && (c[2] -= 1)
                        }
                    }, i._createActivePairsList = function (t) {
                        var e, n, i = t.pairs, r = o.keys(i), s = r.length, a = [];
                        for (n = 0; n < s; n++) (e = i[r[n]])[2] > 0 ? a.push(e) : delete i[r[n]];
                        return a
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(3), o = n(7), s = n(13), a = n(4), l = n(14), c = n(10), u = n(5), h = n(0), d = n(1);
                    i.create = function (t, e) {
                        var n = (t ? t.mouse : null) || (e ? e.mouse : null);
                        n || (t && t.render && t.render.canvas ? n = s.create(t.render.canvas) : e && e.element ? n = s.create(e.element) : (n = s.create(), h.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected")));
                        var r = {
                            type: "mouseConstraint",
                            mouse: n,
                            element: null,
                            body: null,
                            constraint: c.create({
                                label: "Mouse Constraint",
                                pointA: n.position,
                                pointB: {x: 0, y: 0},
                                length: .01,
                                stiffness: .1,
                                angularStiffness: 1,
                                render: {strokeStyle: "#90EE90", lineWidth: 3}
                            }),
                            collisionFilter: {category: 1, mask: 4294967295, group: 0}
                        }, o = h.extend(r, e);
                        return a.on(t, "beforeUpdate", (function () {
                            var e = u.allBodies(t.world);
                            i.update(o, e), i._triggerEvents(o)
                        })), o
                    }, i.update = function (t, e) {
                        var n = t.mouse, i = t.constraint, s = t.body;
                        if (0 === n.button) {
                            if (i.bodyB) o.set(i.bodyB, !1), i.pointA = n.position; else for (var c = 0; c < e.length; c++) if (s = e[c], d.contains(s.bounds, n.position) && l.canCollide(s.collisionFilter, t.collisionFilter)) for (var u = s.parts.length > 1 ? 1 : 0; u < s.parts.length; u++) {
                                var h = s.parts[u];
                                if (r.contains(h.vertices, n.position)) {
                                    i.pointA = n.position, i.bodyB = t.body = s, i.pointB = {
                                        x: n.position.x - s.position.x,
                                        y: n.position.y - s.position.y
                                    }, i.angleB = s.angle, o.set(s, !1), a.trigger(t, "startdrag", {mouse: n, body: s});
                                    break
                                }
                            }
                        } else i.bodyB = t.body = null, i.pointB = null, s && a.trigger(t, "enddrag", {
                            mouse: n,
                            body: s
                        })
                    }, i._triggerEvents = function (t) {
                        var e = t.mouse, n = e.sourceEvents;
                        n.mousemove && a.trigger(t, "mousemove", {mouse: e}), n.mousedown && a.trigger(t, "mousedown", {mouse: e}), n.mouseup && a.trigger(t, "mouseup", {mouse: e}), s.clearSourceEvents(e)
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(2), o = n(8), s = n(1), a = n(12), l = n(3);
                    i.collides = function (t, e) {
                        for (var n = [], i = e.length, r = t.bounds, a = o.collides, l = s.overlaps, c = 0; c < i; c++) {
                            var u = e[c], h = u.parts.length, d = 1 === h ? 0 : 1;
                            if (l(u.bounds, r)) for (var p = d; p < h; p++) {
                                var f = u.parts[p];
                                if (l(f.bounds, r)) {
                                    var m = a(f, t);
                                    if (m) {
                                        n.push(m);
                                        break
                                    }
                                }
                            }
                        }
                        return n
                    }, i.ray = function (t, e, n, o) {
                        o = o || 1e-100;
                        for (var s = r.angle(e, n), l = r.magnitude(r.sub(e, n)), c = .5 * (n.x + e.x), u = .5 * (n.y + e.y), h = a.rectangle(c, u, l, o, {angle: s}), d = i.collides(h, t), p = 0; p < d.length; p += 1) {
                            var f = d[p];
                            f.body = f.bodyB = f.bodyA
                        }
                        return d
                    }, i.region = function (t, e, n) {
                        for (var i = [], r = 0; r < t.length; r++) {
                            var o = t[r], a = s.overlaps(o.bounds, e);
                            (a && !n || !a && n) && i.push(o)
                        }
                        return i
                    }, i.point = function (t, e) {
                        for (var n = [], i = 0; i < t.length; i++) {
                            var r = t[i];
                            if (s.contains(r.bounds, e)) for (var o = 1 === r.parts.length ? 0 : 1; o < r.parts.length; o++) {
                                var a = r.parts[o];
                                if (s.contains(a.bounds, e) && l.contains(a.vertices, e)) {
                                    n.push(r);
                                    break
                                }
                            }
                        }
                        return n
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r, o, s, a = n(4), l = n(18), c = n(0);
                    "undefined" != typeof window && (r = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame, o = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), r || (r = function (t) {
                        s = setTimeout((function () {
                            t(c.now())
                        }), 1e3 / 60)
                    }, o = function () {
                        clearTimeout(s)
                    }), i.create = function (t) {
                        var e = c.extend({
                            fps: 60,
                            correction: 1,
                            deltaSampleSize: 60,
                            counterTimestamp: 0,
                            frameCounter: 0,
                            deltaHistory: [],
                            timePrev: null,
                            timeScalePrev: 1,
                            frameRequestId: null,
                            isFixed: !1,
                            enabled: !0
                        }, t);
                        return e.delta = e.delta || 1e3 / e.fps, e.deltaMin = e.deltaMin || 1e3 / e.fps, e.deltaMax = e.deltaMax || 1e3 / (.5 * e.fps), e.fps = 1e3 / e.delta, e
                    }, i.run = function (t, e) {
                        return void 0 !== t.positionIterations && (e = t, t = i.create()), function n(o) {
                            t.frameRequestId = r(n), o && t.enabled && i.tick(t, e, o)
                        }(), t
                    }, i.tick = function (t, e, n) {
                        var i, r = e.timing, o = 1, s = {timestamp: r.timestamp};
                        a.trigger(t, "beforeTick", s), t.isFixed ? i = t.delta : (i = n - t.timePrev || t.delta, t.timePrev = n, t.deltaHistory.push(i), t.deltaHistory = t.deltaHistory.slice(-t.deltaSampleSize), o = (i = (i = (i = Math.min.apply(null, t.deltaHistory)) < t.deltaMin ? t.deltaMin : i) > t.deltaMax ? t.deltaMax : i) / t.delta, t.delta = i), 0 !== t.timeScalePrev && (o *= r.timeScale / t.timeScalePrev), 0 === r.timeScale && (o = 0), t.timeScalePrev = r.timeScale, t.correction = o, t.frameCounter += 1, n - t.counterTimestamp >= 1e3 && (t.fps = t.frameCounter * ((n - t.counterTimestamp) / 1e3), t.counterTimestamp = n, t.frameCounter = 0), a.trigger(t, "tick", s), a.trigger(t, "beforeUpdate", s), l.update(e, i, o), a.trigger(t, "afterUpdate", s), a.trigger(t, "afterTick", s)
                    }, i.stop = function (t) {
                        o(t.frameRequestId)
                    }, i.start = function (t, e) {
                        i.run(t, e)
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(8), o = n(0).deprecated;
                    i.collides = function (t, e) {
                        return r.collides(t, e)
                    }, o(i, "collides", "SAT.collides â¤ replaced by Collision.collides")
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i, n(1);
                    var r = n(0);
                    i.pathToVertices = function (t, e) {
                        "undefined" == typeof window || "SVGPathSeg" in window || r.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
                        var n, o, s, a, l, c, u, h, d, p, f, m = [], g = 0, v = 0, y = 0;
                        e = e || 15;
                        var x = function (t, e, n) {
                            var i = n % 2 == 1 && n > 1;
                            if (!d || t != d.x || e != d.y) {
                                d && i ? (p = d.x, f = d.y) : (p = 0, f = 0);
                                var r = {x: p + t, y: f + e};
                                !i && d || (d = r), m.push(r), v = p + t, y = f + e
                            }
                        }, _ = function (t) {
                            var e = t.pathSegTypeAsLetter.toUpperCase();
                            if ("Z" !== e) {
                                switch (e) {
                                    case"M":
                                    case"L":
                                    case"T":
                                    case"C":
                                    case"S":
                                    case"Q":
                                        v = t.x, y = t.y;
                                        break;
                                    case"H":
                                        v = t.x;
                                        break;
                                    case"V":
                                        y = t.y
                                }
                                x(v, y, t.pathSegType)
                            }
                        };
                        for (i._svgPathToAbsolute(t), s = t.getTotalLength(), c = [], n = 0; n < t.pathSegList.numberOfItems; n += 1) c.push(t.pathSegList.getItem(n));
                        for (u = c.concat(); g < s;) {
                            if ((l = c[t.getPathSegAtLength(g)]) != h) {
                                for (; u.length && u[0] != l;) _(u.shift());
                                h = l
                            }
                            switch (l.pathSegTypeAsLetter.toUpperCase()) {
                                case"C":
                                case"T":
                                case"S":
                                case"Q":
                                case"A":
                                    a = t.getPointAtLength(g), x(a.x, a.y, 0)
                            }
                            g += e
                        }
                        for (n = 0, o = u.length; n < o; ++n) _(u[n]);
                        return m
                    }, i._svgPathToAbsolute = function (t) {
                        for (var e, n, i, r, o, s, a = t.pathSegList, l = 0, c = 0, u = a.numberOfItems, h = 0; h < u; ++h) {
                            var d = a.getItem(h), p = d.pathSegTypeAsLetter;
                            if (/[MLHVCSQTA]/.test(p)) "x" in d && (l = d.x), "y" in d && (c = d.y); else switch ("x1" in d && (i = l + d.x1), "x2" in d && (o = l + d.x2), "y1" in d && (r = c + d.y1), "y2" in d && (s = c + d.y2), "x" in d && (l += d.x), "y" in d && (c += d.y), p) {
                                case"m":
                                    a.replaceItem(t.createSVGPathSegMovetoAbs(l, c), h);
                                    break;
                                case"l":
                                    a.replaceItem(t.createSVGPathSegLinetoAbs(l, c), h);
                                    break;
                                case"h":
                                    a.replaceItem(t.createSVGPathSegLinetoHorizontalAbs(l), h);
                                    break;
                                case"v":
                                    a.replaceItem(t.createSVGPathSegLinetoVerticalAbs(c), h);
                                    break;
                                case"c":
                                    a.replaceItem(t.createSVGPathSegCurvetoCubicAbs(l, c, i, r, o, s), h);
                                    break;
                                case"s":
                                    a.replaceItem(t.createSVGPathSegCurvetoCubicSmoothAbs(l, c, o, s), h);
                                    break;
                                case"q":
                                    a.replaceItem(t.createSVGPathSegCurvetoQuadraticAbs(l, c, i, r), h);
                                    break;
                                case"t":
                                    a.replaceItem(t.createSVGPathSegCurvetoQuadraticSmoothAbs(l, c), h);
                                    break;
                                case"a":
                                    a.replaceItem(t.createSVGPathSegArcAbs(l, c, d.r1, d.r2, d.angle, d.largeArcFlag, d.sweepFlag), h);
                                    break;
                                case"z":
                                case"Z":
                                    l = e, c = n
                            }
                            "M" != p && "m" != p || (e = l, n = c)
                        }
                    }
                }, function (t, e, n) {
                    var i = {};
                    t.exports = i;
                    var r = n(5);
                    n(0), i.create = r.create, i.add = r.add, i.remove = r.remove, i.clear = r.clear, i.addComposite = r.addComposite, i.addBody = r.addBody, i.addConstraint = r.addConstraint
                }])
            }, t.exports = i()
        }, 552: t => {
            t.exports = class {
                constructor(t) {
                    return this.result = new Object, this.result.originalText = t.innerText, this.result.splitted = this.split(t), this.result.words = this.result.splitted.querySelectorAll(".SplitTextJS-wrapper"), this.result.chars = this.result.splitted.querySelectorAll(".SplitTextJS-char"), this.result.spaces = this.result.splitted.querySelectorAll(".SplitTextJS-spacer"), this.result
                }

                createSpan(t) {
                    let e = document.createElement("span");
                    return e.style.display = "inline-block", e.className = t, e
                }

                split(t) {
                    let e = new Array;
                    const n = t.innerText.split(" ");
                    let i = n.length;
                    return n.map((t => {
                        const n = this.createSpan("SplitTextJS-wrapper");
                        if (t.split(/(?!^)/).map((t => {
                            let e = this.createSpan("SplitTextJS-char");
                            e.innerText = t, n.appendChild(e)
                        })), i--, e.push(n), i > 0) {
                            let t = this.createSpan("SplitTextJS-char SplitTextJS-spacer");
                            t.innerHTML = "&nbsp;", e.push(t)
                        }
                    })), t.innerHTML = "", e.forEach((e => {
                        t.appendChild(e)
                    })), t
                }
            }
        }
    }, e = {};

    function n(i) {
        var r = e[i];
        if (void 0 !== r) return r.exports;
        var o = e[i] = {id: i, loaded: !1, exports: {}};
        return t[i].call(o.exports, o, o.exports, n), o.loaded = !0, o.exports
    }

    n.n = t => {
        var e = t && t.__esModule ? () => t.default : () => t;
        return n.d(e, {a: e}), e
    }, n.d = (t, e) => {
        for (var i in e) n.o(e, i) && !n.o(t, i) && Object.defineProperty(t, i, {enumerable: !0, get: e[i]})
    }, n.g = function () {
        if ("object" == typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (t) {
            if ("object" == typeof window) return window
        }
    }(), n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), n.nmd = t => (t.paths = [], t.children || (t.children = []), t), (() => {
        "use strict";
        var t = n(590), e = n.n(t), i = n(270), r = n.n(i);

        class o extends (e()) {
            constructor({element: t, elements: e}) {
                super(), this.selector = t, this.selectorChildren = {...e}, this.create(), this.addEventListeners()
            }

            create() {
                this.selector instanceof window.HTMLElement ? this.element = this.selector : this.element = document.querySelector(this.selector), this.elements = {}, r()(this.selectorChildren, ((t, e) => {
                    t instanceof window.HTMLElement || t instanceof window.NodeList || Array.isArray(t) ? this.elements[e] = t : (this.elements[e] = document.querySelectorAll(t), 0 === this.elements[e].length ? this.elements[e] = null : 1 === this.elements[e].length && (this.elements[e] = document.querySelector(t)))
                }))
            }

            addEventListeners() {
            }

            removeEventListeners() {
            }
        }

        function s(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function a(t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
        }

        var l, c, u, h, d, p, f, m, g, v, y, x, _,
            b = {autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: {lineHeight: ""}},
            w = {duration: .5, overwrite: !1, delay: 0}, S = 1e8, M = 1e-8, T = 2 * Math.PI, E = T / 4, A = 0,
            P = Math.sqrt, L = Math.cos, C = Math.sin, R = function (t) {
                return "string" == typeof t
            }, I = function (t) {
                return "function" == typeof t
            }, O = function (t) {
                return "number" == typeof t
            }, D = function (t) {
                return void 0 === t
            }, z = function (t) {
                return "object" == typeof t
            }, k = function (t) {
                return !1 !== t
            }, N = function () {
                return "undefined" != typeof window
            }, B = function (t) {
                return I(t) || R(t)
            }, F = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () {
            }, U = Array.isArray, H = /(?:-?\.?\d|\.)+/gi, V = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
            G = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, W = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, j = /[+-]=-?[.\d]+/,
            q = /[^,'"\[\]\s]+/gi, X = /[\d.+\-=]+(?:e[-+]\d*)*/i, Y = {}, J = {}, Z = function (t) {
                return (J = wt(t, Y)) && un
            }, Q = function (t, e) {
                return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
            }, K = function (t, e) {
                return !e && console.warn(t)
            }, $ = function (t, e) {
                return t && (Y[t] = e) && J && (J[t] = e) || Y
            }, tt = function () {
                return 0
            }, et = {}, nt = [], it = {}, rt = {}, ot = {}, st = 30, at = [], lt = "", ct = function (t) {
                var e, n, i = t[0];
                if (z(i) || I(i) || (t = [t]), !(e = (i._gsap || {}).harness)) {
                    for (n = at.length; n-- && !at[n].targetTest(i);) ;
                    e = at[n]
                }
                for (n = t.length; n--;) t[n] && (t[n]._gsap || (t[n]._gsap = new De(t[n], e))) || t.splice(n, 1);
                return t
            }, ut = function (t) {
                return t._gsap || ct($t(t))[0]._gsap
            }, ht = function (t, e, n) {
                return (n = t[e]) && I(n) ? t[e]() : D(n) && t.getAttribute && t.getAttribute(e) || n
            }, dt = function (t, e) {
                return (t = t.split(",")).forEach(e) || t
            }, pt = function (t) {
                return Math.round(1e5 * t) / 1e5 || 0
            }, ft = function (t) {
                return Math.round(1e7 * t) / 1e7 || 0
            }, mt = function (t, e) {
                for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n;) ;
                return i < n
            }, gt = function () {
                var t, e, n = nt.length, i = nt.slice(0);
                for (it = {}, nt.length = 0, t = 0; t < n; t++) (e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
            }, vt = function (t, e, n, i) {
                nt.length && gt(), t.render(e, n, i), nt.length && gt()
            }, yt = function (t) {
                var e = parseFloat(t);
                return (e || 0 === e) && (t + "").match(q).length < 2 ? e : R(t) ? t.trim() : t
            }, xt = function (t) {
                return t
            }, _t = function (t, e) {
                for (var n in e) n in t || (t[n] = e[n]);
                return t
            }, bt = function (t, e) {
                for (var n in e) n in t || "duration" === n || "ease" === n || (t[n] = e[n])
            }, wt = function (t, e) {
                for (var n in e) t[n] = e[n];
                return t
            }, St = function t(e, n) {
                for (var i in n) "__proto__" !== i && "constructor" !== i && "prototype" !== i && (e[i] = z(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i]);
                return e
            }, Mt = function (t, e) {
                var n, i = {};
                for (n in t) n in e || (i[n] = t[n]);
                return i
            }, Tt = function (t) {
                var e = t.parent || c, n = t.keyframes ? bt : _t;
                if (k(t.inherit)) for (; e;) n(t, e.vars.defaults), e = e.parent || e._dp;
                return t
            }, Et = function (t, e, n, i) {
                void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                var r = e._prev, o = e._next;
                r ? r._next = o : t[n] === e && (t[n] = o), o ? o._prev = r : t[i] === e && (t[i] = r), e._next = e._prev = e.parent = null
            }, At = function (t, e) {
                t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t), t._act = 0
            }, Pt = function (t, e) {
                if (t && (!e || e._end > t._dur || e._start < 0)) for (var n = t; n;) n._dirty = 1, n = n.parent;
                return t
            }, Lt = function (t) {
                for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
                return t
            }, Ct = function t(e) {
                return !e || e._ts && t(e.parent)
            }, Rt = function (t) {
                return t._repeat ? It(t._tTime, t = t.duration() + t._rDelay) * t : 0
            }, It = function (t, e) {
                var n = Math.floor(t /= e);
                return t && n === t ? n - 1 : n
            }, Ot = function (t, e) {
                return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
            }, Dt = function (t) {
                return t._end = ft(t._start + (t._tDur / Math.abs(t._ts || t._rts || M) || 0))
            }, zt = function (t, e) {
                var n = t._dp;
                return n && n.smoothChildTiming && t._ts && (t._start = ft(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), Dt(t), n._dirty || Pt(n, t)), t
            }, kt = function (t, e) {
                var n;
                if ((e._time || e._initted && !e._dur) && (n = Ot(t.rawTime(), e), (!e._dur || Yt(0, e.totalDuration(), n) - e._tTime > M) && e.render(n, !0)), Pt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                    if (t._dur < t.duration()) for (n = t; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                    t._zTime = -1e-8
                }
            }, Nt = function (t, e, n, i) {
                return e.parent && At(e), e._start = ft((O(n) ? n : n || t !== c ? jt(t, n, e) : t._time) + e._delay), e._end = ft(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), function (t, e, n, i, r) {
                    void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                    var o, s = t[i];
                    if (r) for (o = e[r]; s && s[r] > o;) s = s._prev;
                    s ? (e._next = s._next, s._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[i] = e, e._prev = s, e.parent = e._dp = t
                }(t, e, "_first", "_last", t._sort ? "_start" : 0), Ht(e) || (t._recent = e), i || kt(t, e), t
            }, Bt = function (t, e) {
                return (Y.ScrollTrigger || Q("scrollTrigger", e)) && Y.ScrollTrigger.create(e, t)
            }, Ft = function (t, e, n, i) {
                return He(t, e), t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && f !== be.frame ? (nt.push(t), t._lazy = [e, i], 1) : void 0 : 1
            }, Ut = function t(e) {
                var n = e.parent;
                return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
            }, Ht = function (t) {
                var e = t.data;
                return "isFromStart" === e || "isStart" === e
            }, Vt = function (t, e, n, i) {
                var r = t._repeat, o = ft(e) || 0, s = t._tTime / t._tDur;
                return s && !i && (t._time *= o / t._dur), t._dur = o, t._tDur = r ? r < 0 ? 1e10 : ft(o * (r + 1) + t._rDelay * r) : o, s && !i ? zt(t, t._tTime = t._tDur * s) : t.parent && Dt(t), n || Pt(t.parent, t), t
            }, Gt = function (t) {
                return t instanceof ke ? Pt(t) : Vt(t, t._dur)
            }, Wt = {_start: 0, endTime: tt, totalDuration: tt}, jt = function t(e, n, i) {
                var r, o, s, a = e.labels, l = e._recent || Wt, c = e.duration() >= S ? l.endTime(!1) : e._dur;
                return R(n) && (isNaN(n) || n in a) ? (o = n.charAt(0), s = "%" === n.substr(-1), r = n.indexOf("="), "<" === o || ">" === o ? (r >= 0 && (n = n.replace(/=/, "")), ("<" === o ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (s ? (r < 0 ? l : i).totalDuration() / 100 : 1)) : r < 0 ? (n in a || (a[n] = c), a[n]) : (o = parseFloat(n.charAt(r - 1) + n.substr(r + 1)), s && i && (o = o / 100 * (U(i) ? i[0] : i).totalDuration()), r > 1 ? t(e, n.substr(0, r - 1), i) + o : c + o)) : null == n ? c : +n
            }, qt = function (t, e, n) {
                var i, r, o = O(e[1]), s = (o ? 2 : 1) + (t < 2 ? 0 : 1), a = e[s];
                if (o && (a.duration = e[1]), a.parent = n, t) {
                    for (i = a, r = n; r && !("immediateRender" in i);) i = r.vars.defaults || {}, r = k(r.vars.inherit) && r.parent;
                    a.immediateRender = k(i.immediateRender), t < 2 ? a.runBackwards = 1 : a.startAt = e[s - 1]
                }
                return new je(e[0], a, e[s + 1])
            }, Xt = function (t, e) {
                return t || 0 === t ? e(t) : e
            }, Yt = function (t, e, n) {
                return n < t ? t : n > e ? e : n
            }, Jt = function (t) {
                if ("string" != typeof t) return "";
                var e = X.exec(t);
                return e ? t.substr(e.index + e[0].length) : ""
            }, Zt = [].slice, Qt = function (t, e) {
                return t && z(t) && "length" in t && (!e && !t.length || t.length - 1 in t && z(t[0])) && !t.nodeType && t !== u
            }, Kt = function (t, e, n) {
                return void 0 === n && (n = []), t.forEach((function (t) {
                    var i;
                    return R(t) && !e || Qt(t, 1) ? (i = n).push.apply(i, $t(t)) : n.push(t)
                })) || n
            }, $t = function (t, e, n) {
                return !R(t) || n || !h && we() ? U(t) ? Kt(t, n) : Qt(t) ? Zt.call(t, 0) : t ? [t] : [] : Zt.call((e || d).querySelectorAll(t), 0)
            }, te = function (t) {
                return t.sort((function () {
                    return .5 - Math.random()
                }))
            }, ee = function (t) {
                if (I(t)) return t;
                var e = z(t) ? t : {each: t}, n = Le(e.ease), i = e.from || 0, r = parseFloat(e.base) || 0, o = {},
                    s = i > 0 && i < 1, a = isNaN(i) || s, l = e.axis, c = i, u = i;
                return R(i) ? c = u = {
                    center: .5,
                    edges: .5,
                    end: 1
                }[i] || 0 : !s && a && (c = i[0], u = i[1]), function (t, s, h) {
                    var d, p, f, m, g, v, y, x, _, b = (h || e).length, w = o[b];
                    if (!w) {
                        if (!(_ = "auto" === e.grid ? 0 : (e.grid || [1, S])[1])) {
                            for (y = -S; y < (y = h[_++].getBoundingClientRect().left) && _ < b;) ;
                            _--
                        }
                        for (w = o[b] = [], d = a ? Math.min(_, b) * c - .5 : i % _, p = a ? b * u / _ - .5 : i / _ | 0, y = 0, x = S, v = 0; v < b; v++) f = v % _ - d, m = p - (v / _ | 0), w[v] = g = l ? Math.abs("y" === l ? m : f) : P(f * f + m * m), g > y && (y = g), g < x && (x = g);
                        "random" === i && te(w), w.max = y - x, w.min = x, w.v = b = (parseFloat(e.amount) || parseFloat(e.each) * (_ > b ? b - 1 : l ? "y" === l ? b / _ : _ : Math.max(_, b / _)) || 0) * ("edges" === i ? -1 : 1), w.b = b < 0 ? r - b : r, w.u = Jt(e.amount || e.each) || 0, n = n && b < 0 ? Ae(n) : n
                    }
                    return b = (w[t] - w.min) / w.max || 0, ft(w.b + (n ? n(b) : b) * w.v) + w.u
                }
            }, ne = function (t) {
                var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
                return function (n) {
                    var i = Math.round(parseFloat(n) / t) * t * e;
                    return (i - i % 1) / e + (O(n) ? 0 : Jt(n))
                }
            }, ie = function (t, e) {
                var n, i, r = U(t);
                return !r && z(t) && (n = r = t.radius || S, t.values ? (t = $t(t.values), (i = !O(t[0])) && (n *= n)) : t = ne(t.increment)), Xt(e, r ? I(t) ? function (e) {
                    return i = t(e), Math.abs(i - e) <= n ? i : e
                } : function (e) {
                    for (var r, o, s = parseFloat(i ? e.x : e), a = parseFloat(i ? e.y : 0), l = S, c = 0, u = t.length; u--;) (r = i ? (r = t[u].x - s) * r + (o = t[u].y - a) * o : Math.abs(t[u] - s)) < l && (l = r, c = u);
                    return c = !n || l <= n ? t[c] : e, i || c === e || O(e) ? c : c + Jt(e)
                } : ne(t))
            }, re = function (t, e, n, i) {
                return Xt(U(t) ? !e : !0 === n ? !!(n = 0) : !i, (function () {
                    return U(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + .99 * n)) / n) * n * i) / i
                }))
            }, oe = function (t, e, n) {
                return Xt(n, (function (n) {
                    return t[~~e(n)]
                }))
            }, se = function (t) {
                for (var e, n, i, r, o = 0, s = ""; ~(e = t.indexOf("random(", o));) i = t.indexOf(")", e), r = "[" === t.charAt(e + 7), n = t.substr(e + 7, i - e - 7).match(r ? q : H), s += t.substr(o, e - o) + re(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5), o = i + 1;
                return s + t.substr(o, t.length - o)
            }, ae = function (t, e, n, i, r) {
                var o = e - t, s = i - n;
                return Xt(r, (function (e) {
                    return n + ((e - t) / o * s || 0)
                }))
            }, le = function (t, e, n) {
                var i, r, o, s = t.labels, a = S;
                for (i in s) (r = s[i] - e) < 0 == !!n && r && a > (r = Math.abs(r)) && (o = i, a = r);
                return o
            }, ce = function (t, e, n) {
                var i, r, o = t.vars, s = o[e];
                if (s) return i = o[e + "Params"], r = o.callbackScope || t, n && nt.length && gt(), i ? s.apply(r, i) : s.call(r)
            }, ue = function (t) {
                return At(t), t.scrollTrigger && t.scrollTrigger.kill(!1), t.progress() < 1 && ce(t, "onInterrupt"), t
            }, he = function (t) {
                var e = (t = !t.name && t.default || t).name, n = I(t), i = e && !n && t.init ? function () {
                        this._props = []
                    } : t, r = {init: tt, render: tn, add: Fe, kill: nn, modifier: en, rawVars: 0},
                    o = {targetTest: 0, get: 0, getSetter: Ze, aliases: {}, register: 0};
                if (we(), t !== i) {
                    if (rt[e]) return;
                    _t(i, _t(Mt(t, r), o)), wt(i.prototype, wt(r, Mt(t, o))), rt[i.prop = e] = i, t.targetTest && (at.push(i), et[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                }
                $(e, i), t.register && t.register(un, i, sn)
            }, de = 255, pe = {
                aqua: [0, de, de],
                lime: [0, de, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, de],
                navy: [0, 0, 128],
                white: [de, de, de],
                olive: [128, 128, 0],
                yellow: [de, de, 0],
                orange: [de, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [de, 0, 0],
                pink: [de, 192, 203],
                cyan: [0, de, de],
                transparent: [de, de, de, 0]
            }, fe = function (t, e, n) {
                return (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * de + .5 | 0
            }, me = function (t, e, n) {
                var i, r, o, s, a, l, c, u, h, d, p = t ? O(t) ? [t >> 16, t >> 8 & de, t & de] : 0 : pe.black;
                if (!p) {
                    if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), pe[t]) p = pe[t]; else if ("#" === t.charAt(0)) {
                        if (t.length < 6 && (i = t.charAt(1), r = t.charAt(2), o = t.charAt(3), t = "#" + i + i + r + r + o + o + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")), 9 === t.length) return [(p = parseInt(t.substr(1, 6), 16)) >> 16, p >> 8 & de, p & de, parseInt(t.substr(7), 16) / 255];
                        p = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & de, t & de]
                    } else if ("hsl" === t.substr(0, 3)) if (p = d = t.match(H), e) {
                        if (~t.indexOf("=")) return p = t.match(V), n && p.length < 4 && (p[3] = 1), p
                    } else s = +p[0] % 360 / 360, a = +p[1] / 100, i = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (a + 1) : l + a - l * a), p.length > 3 && (p[3] *= 1), p[0] = fe(s + 1 / 3, i, r), p[1] = fe(s, i, r), p[2] = fe(s - 1 / 3, i, r); else p = t.match(H) || pe.transparent;
                    p = p.map(Number)
                }
                return e && !d && (i = p[0] / de, r = p[1] / de, o = p[2] / de, l = ((c = Math.max(i, r, o)) + (u = Math.min(i, r, o))) / 2, c === u ? s = a = 0 : (h = c - u, a = l > .5 ? h / (2 - c - u) : h / (c + u), s = c === i ? (r - o) / h + (r < o ? 6 : 0) : c === r ? (o - i) / h + 2 : (i - r) / h + 4, s *= 60), p[0] = ~~(s + .5), p[1] = ~~(100 * a + .5), p[2] = ~~(100 * l + .5)), n && p.length < 4 && (p[3] = 1), p
            }, ge = function (t) {
                var e = [], n = [], i = -1;
                return t.split(ye).forEach((function (t) {
                    var r = t.match(G) || [];
                    e.push.apply(e, r), n.push(i += r.length + 1)
                })), e.c = n, e
            }, ve = function (t, e, n) {
                var i, r, o, s, a = "", l = (t + a).match(ye), c = e ? "hsla(" : "rgba(", u = 0;
                if (!l) return t;
                if (l = l.map((function (t) {
                    return (t = me(t, e, 1)) && c + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
                })), n && (o = ge(t), (i = n.c).join(a) !== o.c.join(a))) for (s = (r = t.replace(ye, "1").split(G)).length - 1; u < s; u++) a += r[u] + (~i.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (o.length ? o : l.length ? l : n).shift());
                if (!r) for (s = (r = t.split(ye)).length - 1; u < s; u++) a += r[u] + l[u];
                return a + r[s]
            }, ye = function () {
                var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
                for (t in pe) e += "|" + t + "\\b";
                return new RegExp(e + ")", "gi")
            }(), xe = /hsl[a]?\(/, _e = function (t) {
                var e, n = t.join(" ");
                if (ye.lastIndex = 0, ye.test(n)) return e = xe.test(n), t[1] = ve(t[1], e), t[0] = ve(t[0], e, ge(t[1])), !0
            }, be = function () {
                var t, e, n, i, r, o, s = Date.now, a = 500, l = 33, c = s(), f = c, m = 1e3 / 240, v = m, y = [],
                    x = function n(u) {
                        var h, d, p, g, x = s() - f, _ = !0 === u;
                        if (x > a && (c += x - l), ((h = (p = (f += x) - c) - v) > 0 || _) && (g = ++i.frame, r = p - 1e3 * i.time, i.time = p /= 1e3, v += h + (h >= m ? 4 : m - h), d = 1), _ || (t = e(n)), d) for (o = 0; o < y.length; o++) y[o](p, r, g, u)
                    };
                return i = {
                    time: 0, frame: 0, tick: function () {
                        x(!0)
                    }, deltaRatio: function (t) {
                        return r / (1e3 / (t || 60))
                    }, wake: function () {
                        p && (!h && N() && (u = h = window, d = u.document || {}, Y.gsap = un, (u.gsapVersions || (u.gsapVersions = [])).push(un.version), Z(J || u.GreenSockGlobals || !u.gsap && u || {}), n = u.requestAnimationFrame), t && i.sleep(), e = n || function (t) {
                            return setTimeout(t, v - 1e3 * i.time + 1 | 0)
                        }, g = 1, x(2))
                    }, sleep: function () {
                        (n ? u.cancelAnimationFrame : clearTimeout)(t), g = 0, e = tt
                    }, lagSmoothing: function (t, e) {
                        a = t || 1e8, l = Math.min(e, a, 0)
                    }, fps: function (t) {
                        m = 1e3 / (t || 240), v = 1e3 * i.time + m
                    }, add: function (t) {
                        y.indexOf(t) < 0 && y.push(t), we()
                    }, remove: function (t) {
                        var e;
                        ~(e = y.indexOf(t)) && y.splice(e, 1) && o >= e && o--
                    }, _listeners: y
                }
            }(), we = function () {
                return !g && be.wake()
            }, Se = {}, Me = /^[\d.\-M][\d.\-,\s]/, Te = /["']/g, Ee = function (t) {
                for (var e, n, i, r = {}, o = t.substr(1, t.length - 3).split(":"), s = o[0], a = 1, l = o.length; a < l; a++) n = o[a], e = a !== l - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, e), r[s] = isNaN(i) ? i.replace(Te, "").trim() : +i, s = n.substr(e + 1).trim();
                return r
            }, Ae = function (t) {
                return function (e) {
                    return 1 - t(1 - e)
                }
            }, Pe = function t(e, n) {
                for (var i, r = e._first; r;) r instanceof ke ? t(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? t(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next
            }, Le = function (t, e) {
                return t && (I(t) ? t : Se[t] || function (t) {
                    var e, n, i, r, o = (t + "").split("("), s = Se[o[0]];
                    return s && o.length > 1 && s.config ? s.config.apply(null, ~t.indexOf("{") ? [Ee(o[1])] : (e = t, n = e.indexOf("(") + 1, i = e.indexOf(")"), r = e.indexOf("(", n), e.substring(n, ~r && r < i ? e.indexOf(")", i + 1) : i)).split(",").map(yt)) : Se._CE && Me.test(t) ? Se._CE("", t) : s
                }(t)) || e
            }, Ce = function (t, e, n, i) {
                void 0 === n && (n = function (t) {
                    return 1 - e(1 - t)
                }), void 0 === i && (i = function (t) {
                    return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
                });
                var r, o = {easeIn: e, easeOut: n, easeInOut: i};
                return dt(t, (function (t) {
                    for (var e in Se[t] = Y[t] = o, Se[r = t.toLowerCase()] = n, o) Se[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Se[t + "." + e] = o[e]
                })), o
            }, Re = function (t) {
                return function (e) {
                    return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
                }
            }, Ie = function t(e, n, i) {
                var r = n >= 1 ? n : 1, o = (i || (e ? .3 : .45)) / (n < 1 ? n : 1), s = o / T * (Math.asin(1 / r) || 0),
                    a = function (t) {
                        return 1 === t ? 1 : r * Math.pow(2, -10 * t) * C((t - s) * o) + 1
                    }, l = "out" === e ? a : "in" === e ? function (t) {
                        return 1 - a(1 - t)
                    } : Re(a);
                return o = T / o, l.config = function (n, i) {
                    return t(e, n, i)
                }, l
            }, Oe = function t(e, n) {
                void 0 === n && (n = 1.70158);
                var i = function (t) {
                    return t ? --t * t * ((n + 1) * t + n) + 1 : 0
                }, r = "out" === e ? i : "in" === e ? function (t) {
                    return 1 - i(1 - t)
                } : Re(i);
                return r.config = function (n) {
                    return t(e, n)
                }, r
            };
        dt("Linear,Quad,Cubic,Quart,Quint,Strong", (function (t, e) {
            var n = e < 5 ? e + 1 : e;
            Ce(t + ",Power" + (n - 1), e ? function (t) {
                return Math.pow(t, n)
            } : function (t) {
                return t
            }, (function (t) {
                return 1 - Math.pow(1 - t, n)
            }), (function (t) {
                return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
            }))
        })), Se.Linear.easeNone = Se.none = Se.Linear.easeIn, Ce("Elastic", Ie("in"), Ie("out"), Ie()), v = 7.5625, x = 1 / (y = 2.75), Ce("Bounce", (function (t) {
            return 1 - _(1 - t)
        }), _ = function (t) {
            return t < x ? v * t * t : t < .7272727272727273 ? v * Math.pow(t - 1.5 / y, 2) + .75 : t < .9090909090909092 ? v * (t -= 2.25 / y) * t + .9375 : v * Math.pow(t - 2.625 / y, 2) + .984375
        }), Ce("Expo", (function (t) {
            return t ? Math.pow(2, 10 * (t - 1)) : 0
        })), Ce("Circ", (function (t) {
            return -(P(1 - t * t) - 1)
        })), Ce("Sine", (function (t) {
            return 1 === t ? 1 : 1 - L(t * E)
        })), Ce("Back", Oe("in"), Oe("out"), Oe()), Se.SteppedEase = Se.steps = Y.SteppedEase = {
            config: function (t, e) {
                void 0 === t && (t = 1);
                var n = 1 / t, i = t + (e ? 0 : 1), r = e ? 1 : 0;
                return function (t) {
                    return ((i * Yt(0, .99999999, t) | 0) + r) * n
                }
            }
        }, w.ease = Se["quad.out"], dt("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (t) {
            return lt += t + "," + t + "Params,"
        }));
        var De = function (t, e) {
            this.id = A++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : ht, this.set = e ? e.getSetter : Ze
        }, ze = function () {
            function t(t) {
                this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Vt(this, +t.duration, 1, 1), this.data = t.data, g || be.wake()
            }

            var e = t.prototype;
            return e.delay = function (t) {
                return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
            }, e.duration = function (t) {
                return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
            }, e.totalDuration = function (t) {
                return arguments.length ? (this._dirty = 0, Vt(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
            }, e.totalTime = function (t, e) {
                if (we(), !arguments.length) return this._tTime;
                var n = this._dp;
                if (n && n.smoothChildTiming && this._ts) {
                    for (zt(this, t), !n._dp || n.parent || kt(n, this); n && n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
                    !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && Nt(this._dp, this, this._start - this._delay)
                }
                return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === M || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), vt(this, t, e)), this
            }, e.time = function (t, e) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Rt(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
            }, e.totalProgress = function (t, e) {
                return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
            }, e.progress = function (t, e) {
                return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Rt(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
            }, e.iteration = function (t, e) {
                var n = this.duration() + this._rDelay;
                return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? It(this._tTime, n) + 1 : 1
            }, e.timeScale = function (t) {
                if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                if (this._rts === t) return this;
                var e = this.parent && this._ts ? Ot(this.parent._time, this) : this._tTime;
                return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, Lt(this.totalTime(Yt(-this._delay, this._tDur, e), !0)), Dt(this), this
            }, e.paused = function (t) {
                return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (we(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== M && (this._tTime -= M)))), this) : this._ps
            }, e.startTime = function (t) {
                if (arguments.length) {
                    this._start = t;
                    var e = this.parent || this._dp;
                    return e && (e._sort || !this.parent) && Nt(e, this, t - this._delay), this
                }
                return this._start
            }, e.endTime = function (t) {
                return this._start + (k(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
            }, e.rawTime = function (t) {
                var e = this.parent || this._dp;
                return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Ot(e.rawTime(t), this) : this._tTime : this._tTime
            }, e.globalTime = function (t) {
                for (var e = this, n = arguments.length ? t : e.rawTime(); e;) n = e._start + n / (e._ts || 1), e = e._dp;
                return n
            }, e.repeat = function (t) {
                return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, Gt(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
            }, e.repeatDelay = function (t) {
                if (arguments.length) {
                    var e = this._time;
                    return this._rDelay = t, Gt(this), e ? this.time(e) : this
                }
                return this._rDelay
            }, e.yoyo = function (t) {
                return arguments.length ? (this._yoyo = t, this) : this._yoyo
            }, e.seek = function (t, e) {
                return this.totalTime(jt(this, t), k(e))
            }, e.restart = function (t, e) {
                return this.play().totalTime(t ? -this._delay : 0, k(e))
            }, e.play = function (t, e) {
                return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
            }, e.reverse = function (t, e) {
                return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
            }, e.pause = function (t, e) {
                return null != t && this.seek(t, e), this.paused(!0)
            }, e.resume = function () {
                return this.paused(!1)
            }, e.reversed = function (t) {
                return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0
            }, e.invalidate = function () {
                return this._initted = this._act = 0, this._zTime = -1e-8, this
            }, e.isActive = function () {
                var t, e = this.parent || this._dp, n = this._start;
                return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - M))
            }, e.eventCallback = function (t, e, n) {
                var i = this.vars;
                return arguments.length > 1 ? (e ? (i[t] = e, n && (i[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete i[t], this) : i[t]
            }, e.then = function (t) {
                var e = this;
                return new Promise((function (n) {
                    var i = I(t) ? t : xt, r = function () {
                        var t = e.then;
                        e.then = null, I(i) && (i = i(e)) && (i.then || i === e) && (e.then = t), n(i), e.then = t
                    };
                    e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r
                }))
            }, e.kill = function () {
                ue(this)
            }, t
        }();
        _t(ze.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -1e-8,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var ke = function (t) {
            function e(e, n) {
                var i;
                return void 0 === e && (e = {}), (i = t.call(this, e) || this).labels = {}, i.smoothChildTiming = !!e.smoothChildTiming, i.autoRemoveChildren = !!e.autoRemoveChildren, i._sort = k(e.sortChildren), c && Nt(e.parent || c, s(i), n), e.reversed && i.reverse(), e.paused && i.paused(!0), e.scrollTrigger && Bt(s(i), e.scrollTrigger), i
            }

            a(e, t);
            var n = e.prototype;
            return n.to = function (t, e, n) {
                return qt(0, arguments, this), this
            }, n.from = function (t, e, n) {
                return qt(1, arguments, this), this
            }, n.fromTo = function (t, e, n, i) {
                return qt(2, arguments, this), this
            }, n.set = function (t, e, n) {
                return e.duration = 0, e.parent = this, Tt(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new je(t, e, jt(this, n), 1), this
            }, n.call = function (t, e, n) {
                return Nt(this, je.delayedCall(0, t, e), n)
            }, n.staggerTo = function (t, e, n, i, r, o, s) {
                return n.duration = e, n.stagger = n.stagger || i, n.onComplete = o, n.onCompleteParams = s, n.parent = this, new je(t, n, jt(this, r)), this
            }, n.staggerFrom = function (t, e, n, i, r, o, s) {
                return n.runBackwards = 1, Tt(n).immediateRender = k(n.immediateRender), this.staggerTo(t, e, n, i, r, o, s)
            }, n.staggerFromTo = function (t, e, n, i, r, o, s, a) {
                return i.startAt = n, Tt(i).immediateRender = k(i.immediateRender), this.staggerTo(t, e, i, r, o, s, a)
            }, n.render = function (t, e, n) {
                var i, r, o, s, a, l, u, h, d, p, f, m, g = this._time,
                    v = this._dirty ? this.totalDuration() : this._tDur, y = this._dur, x = t <= 0 ? 0 : ft(t),
                    _ = this._zTime < 0 != t < 0 && (this._initted || !y);
                if (this !== c && x > v && t >= 0 && (x = v), x !== this._tTime || n || _) {
                    if (g !== this._time && y && (x += this._time - g, t += this._time - g), i = x, d = this._start, l = !(h = this._ts), _ && (y || (g = this._zTime), (t || !e) && (this._zTime = t)), this._repeat) {
                        if (f = this._yoyo, a = y + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * a + t, e, n);
                        if (i = ft(x % a), x === v ? (s = this._repeat, i = y) : ((s = ~~(x / a)) && s === x / a && (i = y, s--), i > y && (i = y)), p = It(this._tTime, a), !g && this._tTime && p !== s && (p = s), f && 1 & s && (i = y - i, m = 1), s !== p && !this._lock) {
                            var b = f && 1 & p, w = b === (f && 1 & s);
                            if (s < p && (b = !b), g = b ? 0 : y, this._lock = 1, this.render(g || (m ? 0 : ft(s * a)), e, !y)._lock = 0, this._tTime = x, !e && this.parent && ce(this, "onRepeat"), this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1), g && g !== this._time || l !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                            if (y = this._dur, v = this._tDur, w && (this._lock = 2, g = b ? y : -1e-4, this.render(g, !0), this.vars.repeatRefresh && !m && this.invalidate()), this._lock = 0, !this._ts && !l) return this;
                            Pe(this, m)
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (u = function (t, e, n) {
                        var i;
                        if (n > e) for (i = t._first; i && i._start <= n;) {
                            if (!i._dur && "isPause" === i.data && i._start > e) return i;
                            i = i._next
                        } else for (i = t._last; i && i._start >= n;) {
                            if (!i._dur && "isPause" === i.data && i._start < e) return i;
                            i = i._prev
                        }
                    }(this, ft(g), ft(i)), u && (x -= i - (i = u._start))), this._tTime = x, this._time = i, this._act = !h, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, g = 0), !g && i && !e && (ce(this, "onStart"), this._tTime !== x)) return this;
                    if (i >= g && t >= 0) for (r = this._first; r;) {
                        if (o = r._next, (r._act || i >= r._start) && r._ts && u !== r) {
                            if (r.parent !== this) return this.render(t, e, n);
                            if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, e, n), i !== this._time || !this._ts && !l) {
                                u = 0, o && (x += this._zTime = -1e-8);
                                break
                            }
                        }
                        r = o
                    } else {
                        r = this._last;
                        for (var S = t < 0 ? t : i; r;) {
                            if (o = r._prev, (r._act || S <= r._end) && r._ts && u !== r) {
                                if (r.parent !== this) return this.render(t, e, n);
                                if (r.render(r._ts > 0 ? (S - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (S - r._start) * r._ts, e, n), i !== this._time || !this._ts && !l) {
                                    u = 0, o && (x += this._zTime = S ? -1e-8 : M);
                                    break
                                }
                            }
                            r = o
                        }
                    }
                    if (u && !e && (this.pause(), u.render(i >= g ? 0 : -1e-8)._zTime = i >= g ? 1 : -1, this._ts)) return this._start = d, Dt(this), this.render(t, e, n);
                    this._onUpdate && !e && ce(this, "onUpdate", !0), (x === v && v >= this.totalDuration() || !x && g) && (d !== this._start && Math.abs(h) === Math.abs(this._ts) || this._lock || ((t || !y) && (x === v && this._ts > 0 || !x && this._ts < 0) && At(this, 1), e || t < 0 && !g || !x && !g && v || (ce(this, x === v && t >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(x < v && this.timeScale() > 0) && this._prom())))
                }
                return this
            }, n.add = function (t, e) {
                var n = this;
                if (O(e) || (e = jt(this, e, t)), !(t instanceof ze)) {
                    if (U(t)) return t.forEach((function (t) {
                        return n.add(t, e)
                    })), this;
                    if (R(t)) return this.addLabel(t, e);
                    if (!I(t)) return this;
                    t = je.delayedCall(0, t)
                }
                return this !== t ? Nt(this, t, e) : this
            }, n.getChildren = function (t, e, n, i) {
                void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === i && (i = -S);
                for (var r = [], o = this._first; o;) o._start >= i && (o instanceof je ? e && r.push(o) : (n && r.push(o), t && r.push.apply(r, o.getChildren(!0, e, n)))), o = o._next;
                return r
            }, n.getById = function (t) {
                for (var e = this.getChildren(1, 1, 1), n = e.length; n--;) if (e[n].vars.id === t) return e[n]
            }, n.remove = function (t) {
                return R(t) ? this.removeLabel(t) : I(t) ? this.killTweensOf(t) : (Et(this, t), t === this._recent && (this._recent = this._last), Pt(this))
            }, n.totalTime = function (e, n) {
                return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = ft(be.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime
            }, n.addLabel = function (t, e) {
                return this.labels[t] = jt(this, e), this
            }, n.removeLabel = function (t) {
                return delete this.labels[t], this
            }, n.addPause = function (t, e, n) {
                var i = je.delayedCall(0, e || tt, n);
                return i.data = "isPause", this._hasPause = 1, Nt(this, i, jt(this, t))
            }, n.removePause = function (t) {
                var e = this._first;
                for (t = jt(this, t); e;) e._start === t && "isPause" === e.data && At(e), e = e._next
            }, n.killTweensOf = function (t, e, n) {
                for (var i = this.getTweensOf(t, n), r = i.length; r--;) Ne !== i[r] && i[r].kill(t, e);
                return this
            }, n.getTweensOf = function (t, e) {
                for (var n, i = [], r = $t(t), o = this._first, s = O(e); o;) o instanceof je ? mt(o._targets, r) && (s ? (!Ne || o._initted && o._ts) && o.globalTime(0) <= e && o.globalTime(o.totalDuration()) > e : !e || o.isActive()) && i.push(o) : (n = o.getTweensOf(r, e)).length && i.push.apply(i, n), o = o._next;
                return i
            }, n.tweenTo = function (t, e) {
                e = e || {};
                var n, i = this, r = jt(i, t), o = e, s = o.startAt, a = o.onStart, l = o.onStartParams,
                    c = o.immediateRender, u = je.to(i, _t({
                        ease: e.ease || "none",
                        lazy: !1,
                        immediateRender: !1,
                        time: r,
                        overwrite: "auto",
                        duration: e.duration || Math.abs((r - (s && "time" in s ? s.time : i._time)) / i.timeScale()) || M,
                        onStart: function () {
                            if (i.pause(), !n) {
                                var t = e.duration || Math.abs((r - (s && "time" in s ? s.time : i._time)) / i.timeScale());
                                u._dur !== t && Vt(u, t, 0, 1).render(u._time, !0, !0), n = 1
                            }
                            a && a.apply(u, l || [])
                        }
                    }, e));
                return c ? u.render(0) : u
            }, n.tweenFromTo = function (t, e, n) {
                return this.tweenTo(e, _t({startAt: {time: jt(this, t)}}, n))
            }, n.recent = function () {
                return this._recent
            }, n.nextLabel = function (t) {
                return void 0 === t && (t = this._time), le(this, jt(this, t))
            }, n.previousLabel = function (t) {
                return void 0 === t && (t = this._time), le(this, jt(this, t), 1)
            }, n.currentLabel = function (t) {
                return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + M)
            }, n.shiftChildren = function (t, e, n) {
                void 0 === n && (n = 0);
                for (var i, r = this._first, o = this.labels; r;) r._start >= n && (r._start += t, r._end += t), r = r._next;
                if (e) for (i in o) o[i] >= n && (o[i] += t);
                return Pt(this)
            }, n.invalidate = function () {
                var e = this._first;
                for (this._lock = 0; e;) e.invalidate(), e = e._next;
                return t.prototype.invalidate.call(this)
            }, n.clear = function (t) {
                void 0 === t && (t = !0);
                for (var e, n = this._first; n;) e = n._next, this.remove(n), n = e;
                return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), Pt(this)
            }, n.totalDuration = function (t) {
                var e, n, i, r = 0, o = this, s = o._last, a = S;
                if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -t : t));
                if (o._dirty) {
                    for (i = o.parent; s;) e = s._prev, s._dirty && s.totalDuration(), (n = s._start) > a && o._sort && s._ts && !o._lock ? (o._lock = 1, Nt(o, s, n - s._delay, 1)._lock = 0) : a = n, n < 0 && s._ts && (r -= n, (!i && !o._dp || i && i.smoothChildTiming) && (o._start += n / o._ts, o._time -= n, o._tTime -= n), o.shiftChildren(-n, !1, -Infinity), a = 0), s._end > r && s._ts && (r = s._end), s = e;
                    Vt(o, o === c && o._time > r ? o._time : r, 1, 1), o._dirty = 0
                }
                return o._tDur
            }, e.updateRoot = function (t) {
                if (c._ts && (vt(c, Ot(t, c)), f = be.frame), be.frame >= st) {
                    st += b.autoSleep || 120;
                    var e = c._first;
                    if ((!e || !e._ts) && b.autoSleep && be._listeners.length < 2) {
                        for (; e && !e._ts;) e = e._next;
                        e || be.sleep()
                    }
                }
            }, e
        }(ze);
        _t(ke.prototype, {_lock: 0, _hasPause: 0, _forcing: 0});
        var Ne, Be = function (t, e, n, i, r, o, s) {
                var a, l, c, u, h, d, p, f, m = new sn(this._pt, t, e, 0, 1, $e, null, r), g = 0, v = 0;
                for (m.b = n, m.e = i, n += "", (p = ~(i += "").indexOf("random(")) && (i = se(i)), o && (o(f = [n, i], t, e), n = f[0], i = f[1]), l = n.match(W) || []; a = W.exec(i);) u = a[0], h = i.substring(g, a.index), c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1), u !== l[v++] && (d = parseFloat(l[v - 1]) || 0, m._pt = {
                    _next: m._pt,
                    p: h || 1 === v ? h : ",",
                    s: d,
                    c: "=" === u.charAt(1) ? parseFloat(u.substr(2)) * ("-" === u.charAt(0) ? -1 : 1) : parseFloat(u) - d,
                    m: c && c < 4 ? Math.round : 0
                }, g = W.lastIndex);
                return m.c = g < i.length ? i.substring(g, i.length) : "", m.fp = s, (j.test(i) || p) && (m.e = 0), this._pt = m, m
            }, Fe = function (t, e, n, i, r, o, s, a, l) {
                I(i) && (i = i(r || 0, t, o));
                var c, u = t[e],
                    h = "get" !== n ? n : I(u) ? l ? t[e.indexOf("set") || !I(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : u,
                    d = I(u) ? l ? Ye : Xe : qe;
                if (R(i) && (~i.indexOf("random(") && (i = se(i)), "=" === i.charAt(1) && ((c = parseFloat(h) + parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) + (Jt(h) || 0)) || 0 === c) && (i = c)), h !== i) return isNaN(h * i) || "" === i ? (!u && !(e in t) && Q(e, i), Be.call(this, t, e, h, i, d, a || b.stringFilter, l)) : (c = new sn(this._pt, t, e, +h || 0, i - (h || 0), "boolean" == typeof u ? Ke : Qe, 0, d), l && (c.fp = l), s && c.modifier(s, this, t), this._pt = c)
            }, Ue = function (t, e, n, i, r, o) {
                var s, a, l, c;
                if (rt[t] && !1 !== (s = new rt[t]).init(r, s.rawVars ? e[t] : function (t, e, n, i, r) {
                    if (I(t) && (t = Ve(t, r, e, n, i)), !z(t) || t.style && t.nodeType || U(t) || F(t)) return R(t) ? Ve(t, r, e, n, i) : t;
                    var o, s = {};
                    for (o in t) s[o] = Ve(t[o], r, e, n, i);
                    return s
                }(e[t], i, r, o, n), n, i, o) && (n._pt = a = new sn(n._pt, r, t, 0, 1, s.render, s, 0, s.priority), n !== m)) for (l = n._ptLookup[n._targets.indexOf(r)], c = s._props.length; c--;) l[s._props[c]] = a;
                return s
            }, He = function t(e, n) {
                var i, r, o, s, a, u, h, d, p, f, m, g, v, y = e.vars, x = y.ease, _ = y.startAt, b = y.immediateRender,
                    S = y.lazy, T = y.onUpdate, E = y.onUpdateParams, A = y.callbackScope, P = y.runBackwards,
                    L = y.yoyoEase, C = y.keyframes, R = y.autoRevert, I = e._dur, O = e._startAt, D = e._targets,
                    z = e.parent, N = z && "nested" === z.data ? z.parent._targets : D, B = "auto" === e._overwrite && !l,
                    F = e.timeline;
                if (F && (!C || !x) && (x = "none"), e._ease = Le(x, w.ease), e._yEase = L ? Ae(Le(!0 === L ? x : L, w.ease)) : 0, L && e._yoyo && !e._repeat && (L = e._yEase, e._yEase = e._ease, e._ease = L), e._from = !F && !!y.runBackwards, !F) {
                    if (g = (d = D[0] ? ut(D[0]).harness : 0) && y[d.prop], i = Mt(y, et), O && O.render(-1, !0).kill(), _) if (At(e._startAt = je.set(D, _t({
                        data: "isStart",
                        overwrite: !1,
                        parent: z,
                        immediateRender: !0,
                        lazy: k(S),
                        startAt: null,
                        delay: 0,
                        onUpdate: T,
                        onUpdateParams: E,
                        callbackScope: A,
                        stagger: 0
                    }, _))), n < 0 && !b && !R && e._startAt.render(-1, !0), b) {
                        if (n > 0 && !R && (e._startAt = 0), I && n <= 0) return void (n && (e._zTime = n))
                    } else !1 === R && (e._startAt = 0); else if (P && I) if (O) !R && (e._startAt = 0); else if (n && (b = !1), o = _t({
                        overwrite: !1,
                        data: "isFromStart",
                        lazy: b && k(S),
                        immediateRender: b,
                        stagger: 0,
                        parent: z
                    }, i), g && (o[d.prop] = g), At(e._startAt = je.set(D, o)), n < 0 && e._startAt.render(-1, !0), b) {
                        if (!n) return
                    } else t(e._startAt, M);
                    for (e._pt = 0, S = I && k(S) || S && !I, r = 0; r < D.length; r++) {
                        if (h = (a = D[r])._gsap || ct(D)[r]._gsap, e._ptLookup[r] = f = {}, it[h.id] && nt.length && gt(), m = N === D ? r : N.indexOf(a), d && !1 !== (p = new d).init(a, g || i, e, m, N) && (e._pt = s = new sn(e._pt, a, p.name, 0, 1, p.render, p, 0, p.priority), p._props.forEach((function (t) {
                            f[t] = s
                        })), p.priority && (u = 1)), !d || g) for (o in i) rt[o] && (p = Ue(o, i, e, m, a, N)) ? p.priority && (u = 1) : f[o] = s = Fe.call(e, a, o, "get", i[o], m, N, 0, y.stringFilter);
                        e._op && e._op[r] && e.kill(a, e._op[r]), B && e._pt && (Ne = e, c.killTweensOf(a, f, e.globalTime(n)), v = !e.parent, Ne = 0), e._pt && S && (it[h.id] = 1)
                    }
                    u && on(e), e._onInit && e._onInit(e)
                }
                e._onUpdate = T, e._initted = (!e._op || e._pt) && !v
            }, Ve = function (t, e, n, i, r) {
                return I(t) ? t.call(e, n, i, r) : R(t) && ~t.indexOf("random(") ? se(t) : t
            }, Ge = lt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
            We = (Ge + ",id,stagger,delay,duration,paused,scrollTrigger").split(","), je = function (t) {
                function e(e, n, i, r) {
                    var o;
                    "number" == typeof n && (i.duration = n, n = i, i = null);
                    var a, u, h, d, p, f, m, g, v = (o = t.call(this, r ? n : Tt(n)) || this).vars, y = v.duration,
                        x = v.delay, _ = v.immediateRender, w = v.stagger, S = v.overwrite, M = v.keyframes, T = v.defaults,
                        E = v.scrollTrigger, A = v.yoyoEase, P = n.parent || c,
                        L = (U(e) || F(e) ? O(e[0]) : "length" in n) ? [e] : $t(e);
                    if (o._targets = L.length ? ct(L) : K("GSAP target " + e + " not found. https://greensock.com", !b.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = S, M || w || B(y) || B(x)) {
                        if (n = o.vars, (a = o.timeline = new ke({
                            data: "nested",
                            defaults: T || {}
                        })).kill(), a.parent = a._dp = s(o), a._start = 0, M) Tt(_t(a.vars.defaults, {ease: "none"})), w ? L.forEach((function (t, e) {
                            return M.forEach((function (n, i) {
                                return a.to(t, n, i ? ">" : e * w)
                            }))
                        })) : M.forEach((function (t) {
                            return a.to(L, t, ">")
                        })); else {
                            if (d = L.length, m = w ? ee(w) : tt, z(w)) for (p in w) ~Ge.indexOf(p) && (g || (g = {}), g[p] = w[p]);
                            for (u = 0; u < d; u++) {
                                for (p in h = {}, n) We.indexOf(p) < 0 && (h[p] = n[p]);
                                h.stagger = 0, A && (h.yoyoEase = A), g && wt(h, g), f = L[u], h.duration = +Ve(y, s(o), u, f, L), h.delay = (+Ve(x, s(o), u, f, L) || 0) - o._delay, !w && 1 === d && h.delay && (o._delay = x = h.delay, o._start += x, h.delay = 0), a.to(f, h, m(u, f, L))
                            }
                            a.duration() ? y = x = 0 : o.timeline = 0
                        }
                        y || o.duration(y = a.duration())
                    } else o.timeline = 0;
                    return !0 !== S || l || (Ne = s(o), c.killTweensOf(L), Ne = 0), Nt(P, s(o), i), n.reversed && o.reverse(), n.paused && o.paused(!0), (_ || !y && !M && o._start === ft(P._time) && k(_) && Ct(s(o)) && "nested" !== P.data) && (o._tTime = -1e-8, o.render(Math.max(0, -x))), E && Bt(s(o), E), o
                }

                a(e, t);
                var n = e.prototype;
                return n.render = function (t, e, n) {
                    var i, r, o, s, a, l, c, u, h, d = this._time, p = this._tDur, f = this._dur,
                        m = t > p - M && t >= 0 ? p : t < M ? 0 : t;
                    if (f) {
                        if (m !== this._tTime || !t || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 != t < 0) {
                            if (i = m, u = this.timeline, this._repeat) {
                                if (s = f + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * s + t, e, n);
                                if (i = ft(m % s), m === p ? (o = this._repeat, i = f) : ((o = ~~(m / s)) && o === m / s && (i = f, o--), i > f && (i = f)), (l = this._yoyo && 1 & o) && (h = this._yEase, i = f - i), a = It(this._tTime, s), i === d && !n && this._initted) return this;
                                o !== a && (u && this._yEase && Pe(u, l), !this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1, this.render(ft(s * o), !0).invalidate()._lock = 0))
                            }
                            if (!this._initted) {
                                if (Ft(this, t < 0 ? t : i, n, e)) return this._tTime = 0, this;
                                if (f !== this._dur) return this.render(t, e, n)
                            }
                            if (this._tTime = m, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (h || this._ease)(i / f), this._from && (this.ratio = c = 1 - c), i && !d && !e && (ce(this, "onStart"), this._tTime !== m)) return this;
                            for (r = this._pt; r;) r.r(c, r.d), r = r._next;
                            u && u.render(t < 0 ? t : !i && l ? -1e-8 : u._dur * c, e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n), ce(this, "onUpdate")), this._repeat && o !== a && this.vars.onRepeat && !e && this.parent && ce(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), (t || !f) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && At(this, 1), e || t < 0 && !d || !m && !d || (ce(this, m === p ? "onComplete" : "onReverseComplete", !0), this._prom && !(m < p && this.timeScale() > 0) && this._prom()))
                        }
                    } else !function (t, e, n, i) {
                        var r, o, s, a = t.ratio,
                            l = e < 0 || !e && (!t._start && Ut(t) && (t._initted || !Ht(t)) || (t._ts < 0 || t._dp._ts < 0) && !Ht(t)) ? 0 : 1,
                            c = t._rDelay, u = 0;
                        if (c && t._repeat && (u = Yt(0, t._tDur, e), o = It(u, c), s = It(t._tTime, c), t._yoyo && 1 & o && (l = 1 - l), o !== s && (a = 1 - l, t.vars.repeatRefresh && t._initted && t.invalidate())), l !== a || i || t._zTime === M || !e && t._zTime) {
                            if (!t._initted && Ft(t, e, i, n)) return;
                            for (s = t._zTime, t._zTime = e || (n ? M : 0), n || (n = e && !s), t.ratio = l, t._from && (l = 1 - l), t._time = 0, t._tTime = u, r = t._pt; r;) r.r(l, r.d), r = r._next;
                            t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !n && ce(t, "onUpdate"), u && t._repeat && !n && t.parent && ce(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === l && (l && At(t, 1), n || (ce(t, l ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                        } else t._zTime || (t._zTime = e)
                    }(this, t, e, n);
                    return this
                }, n.targets = function () {
                    return this._targets
                }, n.invalidate = function () {
                    return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this)
                }, n.kill = function (t, e) {
                    if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? ue(this) : this;
                    if (this.timeline) {
                        var n = this.timeline.totalDuration();
                        return this.timeline.killTweensOf(t, e, Ne && !0 !== Ne.vars.overwrite)._first || ue(this), this.parent && n !== this.timeline.totalDuration() && Vt(this, this._dur * this.timeline._tDur / n, 0, 1), this
                    }
                    var i, r, o, s, a, l, c, u = this._targets, h = t ? $t(t) : u, d = this._ptLookup, p = this._pt;
                    if ((!e || "all" === e) && function (t, e) {
                        for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n];) ;
                        return n < 0
                    }(u, h)) return "all" === e && (this._pt = 0), ue(this);
                    for (i = this._op = this._op || [], "all" !== e && (R(e) && (a = {}, dt(e, (function (t) {
                        return a[t] = 1
                    })), e = a), e = function (t, e) {
                        var n, i, r, o, s = t[0] ? ut(t[0]).harness : 0, a = s && s.aliases;
                        if (!a) return e;
                        for (i in n = wt({}, e), a) if (i in n) for (r = (o = a[i].split(",")).length; r--;) n[o[r]] = n[i];
                        return n
                    }(u, e)), c = u.length; c--;) if (~h.indexOf(u[c])) for (a in r = d[c], "all" === e ? (i[c] = e, s = r, o = {}) : (o = i[c] = i[c] || {}, s = e), s) (l = r && r[a]) && ("kill" in l.d && !0 !== l.d.kill(a) || Et(this, l, "_pt"), delete r[a]), "all" !== o && (o[a] = 1);
                    return this._initted && !this._pt && p && ue(this), this
                }, e.to = function (t, n) {
                    return new e(t, n, arguments[2])
                }, e.from = function (t, e) {
                    return qt(1, arguments)
                }, e.delayedCall = function (t, n, i, r) {
                    return new e(n, 0, {
                        immediateRender: !1,
                        lazy: !1,
                        overwrite: !1,
                        delay: t,
                        onComplete: n,
                        onReverseComplete: n,
                        onCompleteParams: i,
                        onReverseCompleteParams: i,
                        callbackScope: r
                    })
                }, e.fromTo = function (t, e, n) {
                    return qt(2, arguments)
                }, e.set = function (t, n) {
                    return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n)
                }, e.killTweensOf = function (t, e, n) {
                    return c.killTweensOf(t, e, n)
                }, e
            }(ze);
        _t(je.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }), dt("staggerTo,staggerFrom,staggerFromTo", (function (t) {
            je[t] = function () {
                var e = new ke, n = Zt.call(arguments, 0);
                return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
            }
        }));
        var qe = function (t, e, n) {
            return t[e] = n
        }, Xe = function (t, e, n) {
            return t[e](n)
        }, Ye = function (t, e, n, i) {
            return t[e](i.fp, n)
        }, Je = function (t, e, n) {
            return t.setAttribute(e, n)
        }, Ze = function (t, e) {
            return I(t[e]) ? Xe : D(t[e]) && t.setAttribute ? Je : qe
        }, Qe = function (t, e) {
            return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e)
        }, Ke = function (t, e) {
            return e.set(e.t, e.p, !!(e.s + e.c * t), e)
        }, $e = function (t, e) {
            var n = e._pt, i = "";
            if (!t && e.b) i = e.b; else if (1 === t && e.e) i = e.e; else {
                for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + i, n = n._next;
                i += e.c
            }
            e.set(e.t, e.p, i, e)
        }, tn = function (t, e) {
            for (var n = e._pt; n;) n.r(t, n.d), n = n._next
        }, en = function (t, e, n, i) {
            for (var r, o = this._pt; o;) r = o._next, o.p === i && o.modifier(t, e, n), o = r
        }, nn = function (t) {
            for (var e, n, i = this._pt; i;) n = i._next, i.p === t && !i.op || i.op === t ? Et(this, i, "_pt") : i.dep || (e = 1), i = n;
            return !e
        }, rn = function (t, e, n, i) {
            i.mSet(t, e, i.m.call(i.tween, n, i.mt), i)
        }, on = function (t) {
            for (var e, n, i, r, o = t._pt; o;) {
                for (e = o._next, n = i; n && n.pr > o.pr;) n = n._next;
                (o._prev = n ? n._prev : r) ? o._prev._next = o : i = o, (o._next = n) ? n._prev = o : r = o, o = e
            }
            t._pt = i
        }, sn = function () {
            function t(t, e, n, i, r, o, s, a, l) {
                this.t = e, this.s = i, this.c = r, this.p = n, this.r = o || Qe, this.d = s || this, this.set = a || qe, this.pr = l || 0, this._next = t, t && (t._prev = this)
            }

            return t.prototype.modifier = function (t, e, n) {
                this.mSet = this.mSet || this.set, this.set = rn, this.m = t, this.mt = n, this.tween = e
            }, t
        }();
        dt(lt + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (t) {
            return et[t] = 1
        })), Y.TweenMax = Y.TweenLite = je, Y.TimelineLite = Y.TimelineMax = ke, c = new ke({
            sortChildren: !1,
            defaults: w,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }), b.stringFilter = _e;
        var an = {
            registerPlugin: function () {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                e.forEach((function (t) {
                    return he(t)
                }))
            },
            timeline: function (t) {
                return new ke(t)
            },
            getTweensOf: function (t, e) {
                return c.getTweensOf(t, e)
            },
            getProperty: function (t, e, n, i) {
                R(t) && (t = $t(t)[0]);
                var r = ut(t || {}).get, o = n ? xt : yt;
                return "native" === n && (n = ""), t ? e ? o((rt[e] && rt[e].get || r)(t, e, n, i)) : function (e, n, i) {
                    return o((rt[e] && rt[e].get || r)(t, e, n, i))
                } : t
            },
            quickSetter: function (t, e, n) {
                if ((t = $t(t)).length > 1) {
                    var i = t.map((function (t) {
                        return un.quickSetter(t, e, n)
                    })), r = i.length;
                    return function (t) {
                        for (var e = r; e--;) i[e](t)
                    }
                }
                t = t[0] || {};
                var o = rt[e], s = ut(t), a = s.harness && (s.harness.aliases || {})[e] || e, l = o ? function (e) {
                    var i = new o;
                    m._pt = 0, i.init(t, n ? e + n : e, m, 0, [t]), i.render(1, i), m._pt && tn(1, m)
                } : s.set(t, a);
                return o ? l : function (e) {
                    return l(t, a, n ? e + n : e, s, 1)
                }
            },
            isTweening: function (t) {
                return c.getTweensOf(t, !0).length > 0
            },
            defaults: function (t) {
                return t && t.ease && (t.ease = Le(t.ease, w.ease)), St(w, t || {})
            },
            config: function (t) {
                return St(b, t || {})
            },
            registerEffect: function (t) {
                var e = t.name, n = t.effect, i = t.plugins, r = t.defaults, o = t.extendTimeline;
                (i || "").split(",").forEach((function (t) {
                    return t && !rt[t] && !Y[t] && K(e + " effect requires " + t + " plugin.")
                })), ot[e] = function (t, e, i) {
                    return n($t(t), _t(e || {}, r), i)
                }, o && (ke.prototype[e] = function (t, n, i) {
                    return this.add(ot[e](t, z(n) ? n : (i = n) && {}, this), i)
                })
            },
            registerEase: function (t, e) {
                Se[t] = Le(e)
            },
            parseEase: function (t, e) {
                return arguments.length ? Le(t, e) : Se
            },
            getById: function (t) {
                return c.getById(t)
            },
            exportRoot: function (t, e) {
                void 0 === t && (t = {});
                var n, i, r = new ke(t);
                for (r.smoothChildTiming = k(t.smoothChildTiming), c.remove(r), r._dp = 0, r._time = r._tTime = c._time, n = c._first; n;) i = n._next, !e && !n._dur && n instanceof je && n.vars.onComplete === n._targets[0] || Nt(r, n, n._start - n._delay), n = i;
                return Nt(c, r, 0), r
            },
            utils: {
                wrap: function t(e, n, i) {
                    var r = n - e;
                    return U(e) ? oe(e, t(0, e.length), n) : Xt(i, (function (t) {
                        return (r + (t - e) % r) % r + e
                    }))
                }, wrapYoyo: function t(e, n, i) {
                    var r = n - e, o = 2 * r;
                    return U(e) ? oe(e, t(0, e.length - 1), n) : Xt(i, (function (t) {
                        return e + ((t = (o + (t - e) % o) % o || 0) > r ? o - t : t)
                    }))
                }, distribute: ee, random: re, snap: ie, normalize: function (t, e, n) {
                    return ae(t, e, 0, 1, n)
                }, getUnit: Jt, clamp: function (t, e, n) {
                    return Xt(n, (function (n) {
                        return Yt(t, e, n)
                    }))
                }, splitColor: me, toArray: $t, selector: function (t) {
                    return t = $t(t)[0] || K("Invalid scope") || {}, function (e) {
                        var n = t.current || t.nativeElement || t;
                        return $t(e, n.querySelectorAll ? n : n === t ? K("Invalid scope") || d.createElement("div") : t)
                    }
                }, mapRange: ae, pipe: function () {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    return function (t) {
                        return e.reduce((function (t, e) {
                            return e(t)
                        }), t)
                    }
                }, unitize: function (t, e) {
                    return function (n) {
                        return t(parseFloat(n)) + (e || Jt(n))
                    }
                }, interpolate: function t(e, n, i, r) {
                    var o = isNaN(e + n) ? 0 : function (t) {
                        return (1 - t) * e + t * n
                    };
                    if (!o) {
                        var s, a, l, c, u, h = R(e), d = {};
                        if (!0 === i && (r = 1) && (i = null), h) e = {p: e}, n = {p: n}; else if (U(e) && !U(n)) {
                            for (l = [], c = e.length, u = c - 2, a = 1; a < c; a++) l.push(t(e[a - 1], e[a]));
                            c--, o = function (t) {
                                t *= c;
                                var e = Math.min(u, ~~t);
                                return l[e](t - e)
                            }, i = n
                        } else r || (e = wt(U(e) ? [] : {}, e));
                        if (!l) {
                            for (s in n) Fe.call(d, e, s, "get", n[s]);
                            o = function (t) {
                                return tn(t, d) || (h ? e.p : e)
                            }
                        }
                    }
                    return Xt(i, o)
                }, shuffle: te
            },
            install: Z,
            effects: ot,
            ticker: be,
            updateRoot: ke.updateRoot,
            plugins: rt,
            globalTimeline: c,
            core: {
                PropTween: sn,
                globals: $,
                Tween: je,
                Timeline: ke,
                Animation: ze,
                getCache: ut,
                _removeLinkedListItem: Et,
                suppressOverwrites: function (t) {
                    return l = t
                }
            }
        };
        dt("to,from,fromTo,delayedCall,set,killTweensOf", (function (t) {
            return an[t] = je[t]
        })), be.add(ke.updateRoot), m = an.to({}, {duration: 0});
        var ln = function (t, e) {
            for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next;
            return n
        }, cn = function (t, e) {
            return {
                name: t, rawVars: 1, init: function (t, n, i) {
                    i._onInit = function (t) {
                        var i, r;
                        if (R(n) && (i = {}, dt(n, (function (t) {
                            return i[t] = 1
                        })), n = i), e) {
                            for (r in i = {}, n) i[r] = e(n[r]);
                            n = i
                        }
                        !function (t, e) {
                            var n, i, r, o = t._targets;
                            for (n in e) for (i = o.length; i--;) (r = t._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = ln(r, n)), r && r.modifier && r.modifier(e[n], t, o[i], n))
                        }(t, n)
                    }
                }
            }
        }, un = an.registerPlugin({
            name: "attr", init: function (t, e, n, i, r) {
                var o, s;
                for (o in e) (s = this.add(t, "setAttribute", (t.getAttribute(o) || 0) + "", e[o], i, r, 0, 0, o)) && (s.op = o), this._props.push(o)
            }
        }, {
            name: "endArray", init: function (t, e) {
                for (var n = e.length; n--;) this.add(t, n, t[n] || 0, e[n])
            }
        }, cn("roundProps", ne), cn("modifiers"), cn("snap", ie)) || an;
        je.version = ke.version = un.version = "3.8.0", p = 1, N() && we();
        Se.Power0, Se.Power1, Se.Power2, Se.Power3, Se.Power4, Se.Linear, Se.Quad, Se.Cubic, Se.Quart, Se.Quint, Se.Strong, Se.Elastic, Se.Back, Se.SteppedEase, Se.Bounce, Se.Sine;
        var hn, dn, pn, fn, mn, gn, vn, yn = Se.Expo, xn = (Se.Circ, {}), _n = 180 / Math.PI, bn = Math.PI / 180,
            wn = Math.atan2, Sn = /([A-Z])/g, Mn = /(?:left|right|width|margin|padding|x)/i, Tn = /[\s,\(]\S/,
            En = {autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity"}, An = function (t, e) {
                return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            }, Pn = function (t, e) {
                return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
            }, Ln = function (t, e) {
                return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
            }, Cn = function (t, e) {
                var n = e.s + e.c * t;
                e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
            }, Rn = function (t, e) {
                return e.set(e.t, e.p, t ? e.e : e.b, e)
            }, In = function (t, e) {
                return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
            }, On = function (t, e, n) {
                return t.style[e] = n
            }, Dn = function (t, e, n) {
                return t.style.setProperty(e, n)
            }, zn = function (t, e, n) {
                return t._gsap[e] = n
            }, kn = function (t, e, n) {
                return t._gsap.scaleX = t._gsap.scaleY = n
            }, Nn = function (t, e, n, i, r) {
                var o = t._gsap;
                o.scaleX = o.scaleY = n, o.renderTransform(r, o)
            }, Bn = function (t, e, n, i, r) {
                var o = t._gsap;
                o[e] = n, o.renderTransform(r, o)
            }, Fn = "transform", Un = Fn + "Origin", Hn = function (t, e) {
                var n = dn.createElementNS ? dn.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : dn.createElement(t);
                return n.style ? n : dn.createElement(t)
            }, Vn = function t(e, n, i) {
                var r = getComputedStyle(e);
                return r[n] || r.getPropertyValue(n.replace(Sn, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && t(e, Wn(n) || n, 1) || ""
            }, Gn = "O,Moz,ms,Ms,Webkit".split(","), Wn = function (t, e, n) {
                var i = (e || mn).style, r = 5;
                if (t in i && !n) return t;
                for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(Gn[r] + t in i);) ;
                return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? Gn[r] : "") + t
            }, jn = function () {
                "undefined" != typeof window && window.document && (hn = window, dn = hn.document, pn = dn.documentElement, mn = Hn("div") || {style: {}}, Hn("div"), Fn = Wn(Fn), Un = Fn + "Origin", mn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", vn = !!Wn("perspective"), fn = 1)
            }, qn = function t(e) {
                var n,
                    i = Hn("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                    r = this.parentNode, o = this.nextSibling, s = this.style.cssText;
                if (pn.appendChild(i), i.appendChild(this), this.style.display = "block", e) try {
                    n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
                } catch (t) {
                } else this._gsapBBox && (n = this._gsapBBox());
                return r && (o ? r.insertBefore(this, o) : r.appendChild(this)), pn.removeChild(i), this.style.cssText = s, n
            }, Xn = function (t, e) {
                for (var n = e.length; n--;) if (t.hasAttribute(e[n])) return t.getAttribute(e[n])
            }, Yn = function (t) {
                var e;
                try {
                    e = t.getBBox()
                } catch (n) {
                    e = qn.call(t, !0)
                }
                return e && (e.width || e.height) || t.getBBox === qn || (e = qn.call(t, !0)), !e || e.width || e.x || e.y ? e : {
                    x: +Xn(t, ["x", "cx", "x1"]) || 0,
                    y: +Xn(t, ["y", "cy", "y1"]) || 0,
                    width: 0,
                    height: 0
                }
            }, Jn = function (t) {
                return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !Yn(t))
            }, Zn = function (t, e) {
                if (e) {
                    var n = t.style;
                    e in xn && e !== Un && (e = Fn), n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), n.removeProperty(e.replace(Sn, "-$1").toLowerCase())) : n.removeAttribute(e)
                }
            }, Qn = function (t, e, n, i, r, o) {
                var s = new sn(t._pt, e, n, 0, 1, o ? In : Rn);
                return t._pt = s, s.b = i, s.e = r, t._props.push(n), s
            }, Kn = {deg: 1, rad: 1, turn: 1}, $n = function t(e, n, i, r) {
                var o, s, a, l, c = parseFloat(i) || 0, u = (i + "").trim().substr((c + "").length) || "px", h = mn.style,
                    d = Mn.test(n), p = "svg" === e.tagName.toLowerCase(),
                    f = (p ? "client" : "offset") + (d ? "Width" : "Height"), m = 100, g = "px" === r, v = "%" === r;
                return r === u || !c || Kn[r] || Kn[u] ? c : ("px" !== u && !g && (c = t(e, n, i, "px")), l = e.getCTM && Jn(e), !v && "%" !== u || !xn[n] && !~n.indexOf("adius") ? (h[d ? "width" : "height"] = m + (g ? u : r), s = ~n.indexOf("adius") || "em" === r && e.appendChild && !p ? e : e.parentNode, l && (s = (e.ownerSVGElement || {}).parentNode), s && s !== dn && s.appendChild || (s = dn.body), (a = s._gsap) && v && a.width && d && a.time === be.time ? pt(c / a.width * m) : ((v || "%" === u) && (h.position = Vn(e, "position")), s === e && (h.position = "static"), s.appendChild(mn), o = mn[f], s.removeChild(mn), h.position = "absolute", d && v && ((a = ut(s)).time = be.time, a.width = s[f]), pt(g ? o * c / m : o && c ? m / o * c : 0))) : (o = l ? e.getBBox()[d ? "width" : "height"] : e[f], pt(v ? c / o * m : c / 100 * o)))
            }, ti = function (t, e, n, i) {
                var r;
                return fn || jn(), e in En && "transform" !== e && ~(e = En[e]).indexOf(",") && (e = e.split(",")[0]), xn[e] && "transform" !== e ? (r = hi(t, i), r = "transformOrigin" !== e ? r[e] : r.svg ? r.origin : di(Vn(t, Un)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = ri[e] && ri[e](t, e, n) || Vn(t, e) || ht(t, e) || ("opacity" === e ? 1 : 0)), n && !~(r + "").trim().indexOf(" ") ? $n(t, e, r, n) + n : r
            }, ei = function (t, e, n, i) {
                if (!n || "none" === n) {
                    var r = Wn(e, t, 1), o = r && Vn(t, r, 1);
                    o && o !== n ? (e = r, n = o) : "borderColor" === e && (n = Vn(t, "borderTopColor"))
                }
                var s, a, l, c, u, h, d, p, f, m, g, v, y = new sn(this._pt, t.style, e, 0, 1, $e), x = 0, _ = 0;
                if (y.b = n, y.e = i, n += "", "auto" === (i += "") && (t.style[e] = i, i = Vn(t, e) || i, t.style[e] = n), _e(s = [n, i]), i = s[1], l = (n = s[0]).match(G) || [], (i.match(G) || []).length) {
                    for (; a = G.exec(i);) d = a[0], f = i.substring(x, a.index), u ? u = (u + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (u = 1), d !== (h = l[_++] || "") && (c = parseFloat(h) || 0, g = h.substr((c + "").length), (v = "=" === d.charAt(1) ? +(d.charAt(0) + "1") : 0) && (d = d.substr(2)), p = parseFloat(d), m = d.substr((p + "").length), x = G.lastIndex - m.length, m || (m = m || b.units[e] || g, x === i.length && (i += m, y.e += m)), g !== m && (c = $n(t, e, h, m) || 0), y._pt = {
                        _next: y._pt,
                        p: f || 1 === _ ? f : ",",
                        s: c,
                        c: v ? v * p : p - c,
                        m: u && u < 4 || "zIndex" === e ? Math.round : 0
                    });
                    y.c = x < i.length ? i.substring(x, i.length) : ""
                } else y.r = "display" === e && "none" === i ? In : Rn;
                return j.test(i) && (y.e = 0), this._pt = y, y
            }, ni = {top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%"}, ii = function (t, e) {
                if (e.tween && e.tween._time === e.tween._dur) {
                    var n, i, r, o = e.t, s = o.style, a = e.u, l = o._gsap;
                    if ("all" === a || !0 === a) s.cssText = "", i = 1; else for (r = (a = a.split(",")).length; --r > -1;) n = a[r], xn[n] && (i = 1, n = "transformOrigin" === n ? Un : Fn), Zn(o, n);
                    i && (Zn(o, Fn), l && (l.svg && o.removeAttribute("transform"), hi(o, 1), l.uncache = 1))
                }
            }, ri = {
                clearProps: function (t, e, n, i, r) {
                    if ("isFromStart" !== r.data) {
                        var o = t._pt = new sn(t._pt, e, n, 0, 0, ii);
                        return o.u = i, o.pr = -10, o.tween = r, t._props.push(n), 1
                    }
                }
            }, oi = [1, 0, 0, 1, 0, 0], si = {}, ai = function (t) {
                return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
            }, li = function (t) {
                var e = Vn(t, Fn);
                return ai(e) ? oi : e.substr(7).match(V).map(pt)
            }, ci = function (t, e) {
                var n, i, r, o, s = t._gsap || ut(t), a = t.style, l = li(t);
                return s.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? oi : l : (l !== oi || t.offsetParent || t === pn || s.svg || (r = a.display, a.display = "block", (n = t.parentNode) && t.offsetParent || (o = 1, i = t.nextSibling, pn.appendChild(t)), l = li(t), r ? a.display = r : Zn(t, "display"), o && (i ? n.insertBefore(t, i) : n ? n.appendChild(t) : pn.removeChild(t))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
            }, ui = function (t, e, n, i, r, o) {
                var s, a, l, c = t._gsap, u = r || ci(t, !0), h = c.xOrigin || 0, d = c.yOrigin || 0, p = c.xOffset || 0,
                    f = c.yOffset || 0, m = u[0], g = u[1], v = u[2], y = u[3], x = u[4], _ = u[5], b = e.split(" "),
                    w = parseFloat(b[0]) || 0, S = parseFloat(b[1]) || 0;
                n ? u !== oi && (a = m * y - g * v) && (l = w * (-g / a) + S * (m / a) - (m * _ - g * x) / a, w = w * (y / a) + S * (-v / a) + (v * _ - y * x) / a, S = l) : (w = (s = Yn(t)).x + (~b[0].indexOf("%") ? w / 100 * s.width : w), S = s.y + (~(b[1] || b[0]).indexOf("%") ? S / 100 * s.height : S)), i || !1 !== i && c.smooth ? (x = w - h, _ = S - d, c.xOffset = p + (x * m + _ * v) - x, c.yOffset = f + (x * g + _ * y) - _) : c.xOffset = c.yOffset = 0, c.xOrigin = w, c.yOrigin = S, c.smooth = !!i, c.origin = e, c.originIsAbsolute = !!n, t.style[Un] = "0px 0px", o && (Qn(o, c, "xOrigin", h, w), Qn(o, c, "yOrigin", d, S), Qn(o, c, "xOffset", p, c.xOffset), Qn(o, c, "yOffset", f, c.yOffset)), t.setAttribute("data-svg-origin", w + " " + S)
            }, hi = function (t, e) {
                var n = t._gsap || new De(t);
                if ("x" in n && !e && !n.uncache) return n;
                var i, r, o, s, a, l, c, u, h, d, p, f, m, g, v, y, x, _, w, S, M, T, E, A, P, L, C, R, I, O, D, z,
                    k = t.style, N = n.scaleX < 0, B = "px", F = "deg", U = Vn(t, Un) || "0";
                return i = r = o = l = c = u = h = d = p = 0, s = a = 1, n.svg = !(!t.getCTM || !Jn(t)), g = ci(t, n.svg), n.svg && (A = (!n.uncache || "0px 0px" === U) && !e && t.getAttribute("data-svg-origin"), ui(t, A || U, !!A || n.originIsAbsolute, !1 !== n.smooth, g)), f = n.xOrigin || 0, m = n.yOrigin || 0, g !== oi && (_ = g[0], w = g[1], S = g[2], M = g[3], i = T = g[4], r = E = g[5], 6 === g.length ? (s = Math.sqrt(_ * _ + w * w), a = Math.sqrt(M * M + S * S), l = _ || w ? wn(w, _) * _n : 0, (h = S || M ? wn(S, M) * _n + l : 0) && (a *= Math.abs(Math.cos(h * bn))), n.svg && (i -= f - (f * _ + m * S), r -= m - (f * w + m * M))) : (z = g[6], O = g[7], C = g[8], R = g[9], I = g[10], D = g[11], i = g[12], r = g[13], o = g[14], c = (v = wn(z, I)) * _n, v && (A = T * (y = Math.cos(-v)) + C * (x = Math.sin(-v)), P = E * y + R * x, L = z * y + I * x, C = T * -x + C * y, R = E * -x + R * y, I = z * -x + I * y, D = O * -x + D * y, T = A, E = P, z = L), u = (v = wn(-S, I)) * _n, v && (y = Math.cos(-v), D = M * (x = Math.sin(-v)) + D * y, _ = A = _ * y - C * x, w = P = w * y - R * x, S = L = S * y - I * x), l = (v = wn(w, _)) * _n, v && (A = _ * (y = Math.cos(v)) + w * (x = Math.sin(v)), P = T * y + E * x, w = w * y - _ * x, E = E * y - T * x, _ = A, T = P), c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0, u = 180 - u), s = pt(Math.sqrt(_ * _ + w * w + S * S)), a = pt(Math.sqrt(E * E + z * z)), v = wn(T, E), h = Math.abs(v) > 2e-4 ? v * _n : 0, p = D ? 1 / (D < 0 ? -D : D) : 0), n.svg && (A = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !ai(Vn(t, Fn)), A && t.setAttribute("transform", A))), Math.abs(h) > 90 && Math.abs(h) < 270 && (N ? (s *= -1, h += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (a *= -1, h += h <= 0 ? 180 : -180)), n.x = i - ((n.xPercent = i && (n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + B, n.y = r - ((n.yPercent = r && (n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + B, n.z = o + B, n.scaleX = pt(s), n.scaleY = pt(a), n.rotation = pt(l) + F, n.rotationX = pt(c) + F, n.rotationY = pt(u) + F, n.skewX = h + F, n.skewY = d + F, n.transformPerspective = p + B, (n.zOrigin = parseFloat(U.split(" ")[2]) || 0) && (k[Un] = di(U)), n.xOffset = n.yOffset = 0, n.force3D = b.force3D, n.renderTransform = n.svg ? xi : vn ? yi : fi, n.uncache = 0, n
            }, di = function (t) {
                return (t = t.split(" "))[0] + " " + t[1]
            }, pi = function (t, e, n) {
                var i = Jt(e);
                return pt(parseFloat(e) + parseFloat($n(t, "x", n + "px", i))) + i
            }, fi = function (t, e) {
                e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, yi(t, e)
            }, mi = "0deg", gi = "0px", vi = ") ", yi = function (t, e) {
                var n = e || this, i = n.xPercent, r = n.yPercent, o = n.x, s = n.y, a = n.z, l = n.rotation,
                    c = n.rotationY, u = n.rotationX, h = n.skewX, d = n.skewY, p = n.scaleX, f = n.scaleY,
                    m = n.transformPerspective, g = n.force3D, v = n.target, y = n.zOrigin, x = "",
                    _ = "auto" === g && t && 1 !== t || !0 === g;
                if (y && (u !== mi || c !== mi)) {
                    var b, w = parseFloat(c) * bn, S = Math.sin(w), M = Math.cos(w);
                    w = parseFloat(u) * bn, b = Math.cos(w), o = pi(v, o, S * b * -y), s = pi(v, s, -Math.sin(w) * -y), a = pi(v, a, M * b * -y + y)
                }
                m !== gi && (x += "perspective(" + m + vi), (i || r) && (x += "translate(" + i + "%, " + r + "%) "), (_ || o !== gi || s !== gi || a !== gi) && (x += a !== gi || _ ? "translate3d(" + o + ", " + s + ", " + a + ") " : "translate(" + o + ", " + s + vi), l !== mi && (x += "rotate(" + l + vi), c !== mi && (x += "rotateY(" + c + vi), u !== mi && (x += "rotateX(" + u + vi), h === mi && d === mi || (x += "skew(" + h + ", " + d + vi), 1 === p && 1 === f || (x += "scale(" + p + ", " + f + vi), v.style[Fn] = x || "translate(0, 0)"
            }, xi = function (t, e) {
                var n, i, r, o, s, a = e || this, l = a.xPercent, c = a.yPercent, u = a.x, h = a.y, d = a.rotation,
                    p = a.skewX, f = a.skewY, m = a.scaleX, g = a.scaleY, v = a.target, y = a.xOrigin, x = a.yOrigin,
                    _ = a.xOffset, b = a.yOffset, w = a.forceCSS, S = parseFloat(u), M = parseFloat(h);
                d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= bn, p *= bn, n = Math.cos(d) * m, i = Math.sin(d) * m, r = Math.sin(d - p) * -g, o = Math.cos(d - p) * g, p && (f *= bn, s = Math.tan(p - f), r *= s = Math.sqrt(1 + s * s), o *= s, f && (s = Math.tan(f), n *= s = Math.sqrt(1 + s * s), i *= s)), n = pt(n), i = pt(i), r = pt(r), o = pt(o)) : (n = m, o = g, i = r = 0), (S && !~(u + "").indexOf("px") || M && !~(h + "").indexOf("px")) && (S = $n(v, "x", u, "px"), M = $n(v, "y", h, "px")), (y || x || _ || b) && (S = pt(S + y - (y * n + x * r) + _), M = pt(M + x - (y * i + x * o) + b)), (l || c) && (s = v.getBBox(), S = pt(S + l / 100 * s.width), M = pt(M + c / 100 * s.height)), s = "matrix(" + n + "," + i + "," + r + "," + o + "," + S + "," + M + ")", v.setAttribute("transform", s), w && (v.style[Fn] = s)
            }, _i = function (t, e, n, i, r, o) {
                var s, a, l = 360, c = R(r), u = parseFloat(r) * (c && ~r.indexOf("rad") ? _n : 1), h = o ? u * o : u - i,
                    d = i + h + "deg";
                return c && ("short" === (s = r.split("_")[1]) && (h %= l) !== h % 180 && (h += h < 0 ? l : -360), "cw" === s && h < 0 ? h = (h + 36e9) % l - ~~(h / l) * l : "ccw" === s && h > 0 && (h = (h - 36e9) % l - ~~(h / l) * l)), t._pt = a = new sn(t._pt, e, n, i, h, Pn), a.e = d, a.u = "deg", t._props.push(n), a
            }, bi = function (t, e) {
                for (var n in e) t[n] = e[n];
                return t
            }, wi = function (t, e, n) {
                var i, r, o, s, a, l, c, u = bi({}, n._gsap), h = n.style;
                for (r in u.svg ? (o = n.getAttribute("transform"), n.setAttribute("transform", ""), h[Fn] = e, i = hi(n, 1), Zn(n, Fn), n.setAttribute("transform", o)) : (o = getComputedStyle(n)[Fn], h[Fn] = e, i = hi(n, 1), h[Fn] = o), xn) (o = u[r]) !== (s = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (a = Jt(o) !== (c = Jt(s)) ? $n(n, r, o, c) : parseFloat(o), l = parseFloat(s), t._pt = new sn(t._pt, i, r, a, l - a, An), t._pt.u = c || 0, t._props.push(r));
                bi(i, u)
            };
        dt("padding,margin,Width,Radius", (function (t, e) {
            var n = "Top", i = "Right", r = "Bottom", o = "Left",
                s = (e < 3 ? [n, i, r, o] : [n + o, n + i, r + i, r + o]).map((function (n) {
                    return e < 2 ? t + n : "border" + n + t
                }));
            ri[e > 1 ? "border" + t : t] = function (t, e, n, i, r) {
                var o, a;
                if (arguments.length < 4) return o = s.map((function (e) {
                    return ti(t, e, n)
                })), 5 === (a = o.join(" ")).split(o[0]).length ? o[0] : a;
                o = (i + "").split(" "), a = {}, s.forEach((function (t, e) {
                    return a[t] = o[e] = o[e] || o[(e - 1) / 2 | 0]
                })), t.init(e, a, r)
            }
        }));
        var Si, Mi, Ti, Ei = {
            name: "css", register: jn, targetTest: function (t) {
                return t.style && t.nodeType
            }, init: function (t, e, n, i, r) {
                var o, s, a, l, c, u, h, d, p, f, m, g, v, y, x, _, w, S, M, T = this._props, E = t.style,
                    A = n.vars.startAt;
                for (h in fn || jn(), e) if ("autoRound" !== h && (s = e[h], !rt[h] || !Ue(h, e, n, i, t, r))) if (c = typeof s, u = ri[h], "function" === c && (c = typeof (s = s.call(n, i, t, r))), "string" === c && ~s.indexOf("random(") && (s = se(s)), u) u(this, t, h, s, n) && (x = 1); else if ("--" === h.substr(0, 2)) o = (getComputedStyle(t).getPropertyValue(h) + "").trim(), s += "", ye.lastIndex = 0, ye.test(o) || (d = Jt(o), p = Jt(s)), p ? d !== p && (o = $n(t, h, o, p) + p) : d && (s += d), this.add(E, "setProperty", o, s, i, r, 0, 0, h), T.push(h); else if ("undefined" !== c) {
                    if (A && h in A ? (o = "function" == typeof A[h] ? A[h].call(n, i, t, r) : A[h], h in b.units && !Jt(o) && (o += b.units[h]), R(o) && ~o.indexOf("random(") && (o = se(o)), "=" === (o + "").charAt(1) && (o = ti(t, h))) : o = ti(t, h), l = parseFloat(o), (f = "string" === c && "=" === s.charAt(1) ? +(s.charAt(0) + "1") : 0) && (s = s.substr(2)), a = parseFloat(s), h in En && ("autoAlpha" === h && (1 === l && "hidden" === ti(t, "visibility") && a && (l = 0), Qn(this, E, "visibility", l ? "inherit" : "hidden", a ? "inherit" : "hidden", !a)), "scale" !== h && "transform" !== h && ~(h = En[h]).indexOf(",") && (h = h.split(",")[0])), m = h in xn) if (g || ((v = t._gsap).renderTransform && !e.parseTransform || hi(t, e.parseTransform), y = !1 !== e.smoothOrigin && v.smooth, (g = this._pt = new sn(this._pt, E, Fn, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === h) this._pt = new sn(this._pt, v, "scaleY", v.scaleY, (f ? f * a : a - v.scaleY) || 0), T.push("scaleY", h), h += "X"; else {
                        if ("transformOrigin" === h) {
                            w = void 0, S = void 0, M = void 0, w = (_ = s).split(" "), S = w[0], M = w[1] || "50%", "top" !== S && "bottom" !== S && "left" !== M && "right" !== M || (_ = S, S = M, M = _), w[0] = ni[S] || S, w[1] = ni[M] || M, s = w.join(" "), v.svg ? ui(t, s, 0, y, 0, this) : ((p = parseFloat(s.split(" ")[2]) || 0) !== v.zOrigin && Qn(this, v, "zOrigin", v.zOrigin, p), Qn(this, E, h, di(o), di(s)));
                            continue
                        }
                        if ("svgOrigin" === h) {
                            ui(t, s, 1, y, 0, this);
                            continue
                        }
                        if (h in si) {
                            _i(this, v, h, l, s, f);
                            continue
                        }
                        if ("smoothOrigin" === h) {
                            Qn(this, v, "smooth", v.smooth, s);
                            continue
                        }
                        if ("force3D" === h) {
                            v[h] = s;
                            continue
                        }
                        if ("transform" === h) {
                            wi(this, s, t);
                            continue
                        }
                    } else h in E || (h = Wn(h) || h);
                    if (m || (a || 0 === a) && (l || 0 === l) && !Tn.test(s) && h in E) a || (a = 0), (d = (o + "").substr((l + "").length)) !== (p = Jt(s) || (h in b.units ? b.units[h] : d)) && (l = $n(t, h, o, p)), this._pt = new sn(this._pt, m ? v : E, h, l, f ? f * a : a - l, m || "px" !== p && "zIndex" !== h || !1 === e.autoRound ? An : Cn), this._pt.u = p || 0, d !== p && "%" !== p && (this._pt.b = o, this._pt.r = Ln); else if (h in E) ei.call(this, t, h, o, s); else {
                        if (!(h in t)) {
                            Q(h, s);
                            continue
                        }
                        this.add(t, h, o || t[h], s, i, r)
                    }
                    T.push(h)
                }
                x && on(this)
            }, get: ti, aliases: En, getSetter: function (t, e, n) {
                var i = En[e];
                return i && i.indexOf(",") < 0 && (e = i), e in xn && e !== Un && (t._gsap.x || ti(t, "x")) ? n && gn === n ? "scale" === e ? kn : zn : (gn = n || {}) && ("scale" === e ? Nn : Bn) : t.style && !D(t.style[e]) ? On : ~e.indexOf("-") ? Dn : Ze(t, e)
            }, core: {_removeProperty: Zn, _getMatrix: ci}
        };
        un.utils.checkPrefix = Wn, Ti = dt((Si = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (Mi = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (t) {
            xn[t] = 1
        })), dt(Mi, (function (t) {
            b.units[t] = "deg", si[t] = 1
        })), En[Ti[13]] = Si + "," + Mi, dt("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (t) {
            var e = t.split(":");
            En[e[1]] = Ti[e[0]]
        })), dt("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (t) {
            b.units[t] = "px"
        })), un.registerPlugin(Ei);
        var Ai = un.registerPlugin(Ei) || un;
        Ai.core.Tween;

        class Pi extends o {
            constructor() {
                super({
                    element: ".l__preloader",
                    elements: {content: ".preloader__content", navbar: ".l__navbar"}
                }), this.allImages = document.querySelectorAll("img"), this.createLoader()
            }

            createLoader() {
                this.loadedNumber = 0, this.percent = 0, this.allImages.forEach((t => {
                    const e = new Image;
                    e.crossOrigin = "anonymous", e.src = t.src, t.crossOrigin = "anonymous", t.src = t.src, e.onload = t => {
                        this.handleLoad()
                    }
                }))
            }

            handleLoad(t) {
                this.loadedNumber += 1, this.percent = this.loadedNumber / this.allImages.length, document.querySelector(".preloader__number").innerHTML = `${Math.round(100 * this.percent)}PERCENT`, 1 === this.percent && this.onLoaded()
            }

            onLoaded() {
                return new Promise((t => {
                    this.emit("completed");
                    const e = Ai.timeline({defaults: {duration: 1.5, ease: yn.easeInOut}});
                    e.to(this.elements.content, {
                        y: -100,
                        opacity: 0
                    }, "out"), e.to(this.elements.navbar, {top: "4rem"}, "out"), e.to(".navbar__menu--trigger, .navbar__label, .navbar__links", {opacity: "1"}, "out+=0.5"), e.to(this.element, {opacity: "0"}, "out+=0.5"), e.to(this.element, {display: "none"}, "out")
                }))
            }

            addEventListeners() {
            }
        }

        class Li {
            constructor({element: t, elements: e, id: n}) {
                this.selector = t, this.selectorChildren = {...e}
            }

            create() {
                r()(this.selectorChildren, ((t, e) => {
                    t instanceof window.HTMLElement || t instanceof window.NodeList || Array.isArray(t) ? this.elements[e] = t : (this.elements[e] = document.querySelectorAll(t), 0 === this.elements[e].length ? this.elements[e] = null : 1 === this.elements[e].length && (this.elements[e] = document.querySelector(t)))
                }))
            }
        }

        var Ci, Ri, Ii, Oi, Di = n(231), zi = n.n(Di), ki = n(292), Ni = n.n(ki), Bi = n(552), Fi = n.n(Bi),
            Ui = function () {
                return "undefined" != typeof window
            }, Hi = function () {
                return Ci || Ui() && (Ci = window.gsap) && Ci.registerPlugin && Ci
            }, Vi = function () {
                return Ri || (Gi(), Oi || console.warn("Please gsap.registerPlugin(CSSPlugin, CSSRulePlugin)")), Ri
            }, Gi = function (t) {
                Ci = t || Hi(), Ui() && (window, Ii = document), Ci && (Oi = Ci.plugins.css) && (Ri = 1)
            }, Wi = {
                version: "3.8.0", name: "cssRule", init: function (t, e, n, i, r) {
                    if (!Vi() || void 0 === t.cssText) return !1;
                    var o = t._gsProxy = t._gsProxy || Ii.createElement("div");
                    this.ss = t, this.style = o.style, o.style.cssText = t.cssText, Oi.prototype.init.call(this, o, e, n, i, r)
                }, render: function (t, e) {
                    for (var n, i = e._pt, r = e.style, o = e.ss; i;) i.r(t, i.d), i = i._next;
                    for (n = r.length; --n > -1;) o[r[n]] = r[r[n]]
                }, getRule: function (t) {
                    Vi();
                    var e, n, i, r, o = Ii.all ? "rules" : "cssRules", s = Ii.styleSheets, a = s.length,
                        l = ":" === t.charAt(0);
                    for (t = (l ? "" : ",") + t.split("::").join(":").toLowerCase() + ",", l && (r = []); a--;) {
                        try {
                            if (!(n = s[a][o])) continue;
                            e = n.length
                        } catch (t) {
                            console.warn(t);
                            continue
                        }
                        for (; --e > -1;) if ((i = n[e]).selectorText && -1 !== ("," + i.selectorText.split("::").join(":").toLowerCase() + ",").indexOf(t)) {
                            if (!l) return i.style;
                            r.push(i.style)
                        }
                    }
                    return r
                }, register: Gi
            };
        Hi() && Ci.registerPlugin(Wi);

        class ji extends o {
            constructor(t) {
                super({
                    element: ".l__navbar",
                    elements: {
                        openMenu: ".navbar__menu--trigger",
                        navbarLabel: ".navbar__label",
                        menu: ".l__menu",
                        menuOpenOverlay: ".l__menu__open--overlay",
                        overlay: ".l__menu--overlay",
                        menuLinks: ".l__menu a",
                        navbarLogo: ".navbar__menu--logo"
                    }
                }), this.asscroll = t, this.currentRotate = 0, this.menuLinks = Ai.utils.toArray(document.querySelectorAll(".l__menu a"))
            }

            menuClick() {
                this.elements.menu.classList.toggle("menu--open"), this.currentRotate += 90, Ai.to(this.elements.openMenu, {
                    rotate: this.currentRotate,
                    duration: .2
                }), this.elements.menu.classList.contains("menu--open") ? this.openMenu() : this.closeMenu()
            }

            openMenu() {
                this.element.classList.add("--noblend"), Ai.to("#navbar__label--closed", {top: "-2.2rem"}), Ai.to("#navbar__label--open", {top: 0}), Ai.set(this.elements.openMenu, {rotate: this.currentRotate}), Ai.to(this.elements.menuOpenOverlay, {
                    left: "0",
                    duration: 1,
                    ease: yn.easeInOut
                }), Ai.to(this.elements.menu, {
                    left: "0",
                    duration: 1.3,
                    ease: yn.easeInOut,
                    delay: -.1
                }), Ai.to(this.elements.overlay, {
                    opacity: .3,
                    pointerEvents: "all"
                }), Ai.set("#nav-dot1, #nav-dot4", {
                    top: "33%",
                    opacity: 1,
                    duration: .2
                }), Ai.set("#nav-dot2, #nav-dot5", {top: "67%", opacity: 1, duration: .2})
            }

            closeMenu() {
                this.element.classList.remove("--noblend"), Ai.to("#navbar__label--closed", {top: 0}), Ai.to("#navbar__label--open", {top: 20}), Ai.set(this.elements.openMenu, {rotate: this.currentRotate}), Ai.to(this.elements.menuOpenOverlay, {
                    left: "-75rem",
                    duration: 1.3,
                    ease: yn.easeInOut,
                    delay: -.1
                }), Ai.to(this.elements.menu, {
                    left: "-75rem",
                    duration: 1,
                    ease: yn.easeInOut
                }), Ai.to(this.elements.overlay, {
                    opacity: 0,
                    pointerEvents: "none"
                }), Ai.set("#nav-dot1, #nav-dot4", {top: "50%"}), Ai.set("#nav-dot2, #nav-dot5", {top: "50%"})
            }

            addEventListeners() {
                this.elements.openMenu.addEventListener("click", (t => {
                    t.preventDefault(), this.menuClick()
                })), this.elements.navbarLabel.addEventListener("click", (t => {
                    t.preventDefault(), this.menuClick()
                })), this.elements.overlay.addEventListener("click", (t => {
                    t.preventDefault(), this.menuClick()
                })), Ai.utils.toArray(this.elements.menuLinks).forEach((t => {
                    t.addEventListener("mouseenter", (() => {
                        Ai.utils.toArray(this.elements.menuLinks).forEach((t => {
                            t.classList.add("link--hidden")
                        })), t.classList.add("link--active")
                    })), t.addEventListener("mouseleave", (() => {
                        Ai.utils.toArray(this.elements.menuLinks).forEach((t => {
                            t.classList.remove("link--hidden")
                        })), t.classList.remove("link--active")
                    }))
                })), this.elements.navbarLogo.addEventListener("click", (() => {
                    if ("home" !== document.querySelector(".l__content").dataset.template) {
                        const t = Ai.timeline({defaults: {duration: 1.3, ease: yn.easeInOut}});
                        t.to(".preloader__overlay--yellow", {top: 0}), t.to(".preloader__overlay--black", {
                            top: 0,
                            delay: -1.2,
                            onComplete: () => window.location.href = "/"
                        })
                    }
                }))
            }
        }

        class qi {
            constructor() {
                this.allLinks = Ai.utils.toArray(document.querySelectorAll("[data-transition]")), this.initTransition()
            }

            initTransition() {
                this.allLinks.forEach((t => {
                    t.addEventListener("click", (e => {
                        e.preventDefault();
                        const n = Ai.timeline({defaults: {duration: 1.3, ease: yn.easeInOut}});
                        n.to(".preloader__overlay--yellow", {top: 0}), n.to(".preloader__overlay--black", {
                            top: 0,
                            delay: -1.2,
                            onComplete: () => window.location.href = t.getAttribute("href")
                        })
                    }))
                }))
            }
        }

        Ai.registerPlugin(Ei, Wi);

        class Xi extends Li {
            constructor() {
                super({id: "home", element: ".l__content", elements: {}}), this.asscroll = new (zi())({
                    disableRaf: !0,
                    touchScrollType: "scrollTop"
                }), this.isDesktop = window.innerWidth >= 1024, this.tileLanding = document.querySelector("#tile__landing"), this.tileManifesto = document.querySelector("#tile__manifesto"), this.tileAbout = document.querySelector("#tile__about"), this.tileProjects = document.querySelector("#tile__projects"), this.allRoles = Ai.utils.toArray(document.querySelectorAll(".role__item")), this.roleCounter = 0, this.applySizes(), this.initScroll(this.asscroll), this.splitText(), this.resizable(), this.addEventListeners(), setTimeout((() => {
                    this.initRolesAnimations()
                }), 500), this.isDesktop || this.initHomeSwiper()
            }

            applySizes() {
                let t = Ai.utils.toArray(document.querySelectorAll(".tile")), e = 0;
                t.forEach((t => {
                    e += t.offsetWidth
                })), this.tileLandingPosition = this.tileLanding.getBoundingClientRect().right, this.tileManifestoPosition = this.tileManifesto.getBoundingClientRect().left + this.tileLanding.getBoundingClientRect().width, this.tileAboutPosition = this.tileAbout.getBoundingClientRect().left + this.tileLanding.getBoundingClientRect().width + this.tileManifesto.getBoundingClientRect().width, this.tileProjectsPosition = this.tileProjects.getBoundingClientRect().left + this.tileLanding.getBoundingClientRect().width + this.tileManifesto.getBoundingClientRect().width + this.tileAbout.getBoundingClientRect().width, this.landingManifestoSize = this.tileLanding.getBoundingClientRect().width + this.tileManifesto.getBoundingClientRect().width, this.projectsSize = this.tileLanding.getBoundingClientRect().width + this.tileManifesto.getBoundingClientRect().width + this.tileAbout.getBoundingClientRect().width, document.querySelector(".l__content").style.minWidth = e + "px", document.querySelector("#project__clone--title").style.top = document.querySelector(".about__title").getBoundingClientRect().top + "px"
            }

            splitText() {
                document.querySelector(".landing__cta").childNodes.forEach((t => {
                    new (Fi())(t)
                }));
                const t = document.querySelector(".landing__cta").childNodes[1];
                t.childNodes[2].childNodes[3].innerHTML = "&nbsp;", t.childNodes[2].childNodes[4].classList.add("char--sometimes"), t.childNodes[2].childNodes[5].classList.add("char--sometimes"), t.childNodes[2].childNodes[6].classList.add("char--sometimes"), t.childNodes[2].childNodes[7].classList.add("char--sometimes"), document.querySelectorAll(".splitText").forEach((t => {
                    new (Fi())(t)
                }))
            }

            updateTilePositions(t) {
                Ai.to("#mi-0", {x: .25 * -t, ease: "none"}), Ai.to("#mi-1", {
                    x: .5 * -t,
                    ease: "none"
                }), Ai.to("#mi-2", {x: .75 * -t, ease: "none"}), Ai.to(".manifesto__title", {
                    x: .5 * -t,
                    ease: "none"
                }), Ai.to(this.tileLanding, {
                    x: -t,
                    ease: "none"
                }), t > this.tileManifestoPosition && Ai.to("#tile__manifesto", {
                    x: -(t - this.tileLanding.getBoundingClientRect().width),
                    ease: "none"
                }), t > this.tileAboutPosition - 10 && (Ai.to("#tile__about", {
                    x: -(t - this.landingManifestoSize),
                    ease: "none"
                }), Ai.to(".about__title h1", {
                    x: .05 * -(t - this.landingManifestoSize),
                    ease: "none"
                }), Ai.to("#project__clone--title h1", {
                    x: 1.05 * -(t - this.landingManifestoSize),
                    ease: "none"
                }), Ai.to(".projects__container", {
                    x: 1.25 * -(t - this.landingManifestoSize),
                    ease: "none"
                })), t > this.tileProjectsPosition - 10 && Ai.to("#tile__projects", {
                    x: -(t - this.projectsSize),
                    ease: "none"
                })
            }

            resizable() {
                let t = document.querySelector(".about__description--resize").offsetWidth;
                Ni()(".about__description--resize").resizable({
                    edges: {top: !1, left: !0, bottom: !1, right: !0},
                    listeners: {
                        move: function (e) {
                            let {x: n, y: i} = e.target.dataset,
                                r = document.querySelector(".about__description").offsetWidth;
                            r += .1 * r, n = (parseFloat(n) || 0) + e.deltaRect.left, i = (parseFloat(i) || 0) + e.deltaRect.top, e.rect.width > r ? e.rect.width = r : e.rect.width, e.rect.width <= t ? e.rect.width = t : e.rect.width, Object.assign(e.target.style, {
                                width: `${e.rect.width}px`,
                                height: `${e.rect.height}px`,
                                transform: `translate(${n}px, ${i}px)`
                            }), Object.assign(e.target.dataset, {x: n, y: i})
                        }
                    }
                })
            }

            initRolesAnimations() {
                const t = Ai.timeline({repeat: -1, repeatDelay: "0"});
                t.to(this.allRoles[0], {
                    top: "-120%",
                    duration: .6,
                    ease: Ai.easeInOut
                }, "firstTwo+=2"), t.to(this.allRoles[1], {
                    top: 0,
                    duration: .6,
                    ease: Ai.easeInOut
                }, "firstTwo+=2"), t.to(this.allRoles[1], {
                    top: "-120%",
                    duration: .6,
                    ease: Ai.easeInOut
                }, "secondTwo+=2"), t.to(this.allRoles[0], {
                    top: "120%",
                    duration: 0,
                    ease: "none"
                }, "secondTwo+=2"), t.to(this.allRoles[2], {
                    top: 0,
                    duration: .6,
                    ease: Ai.easeInOut
                }, "secondTwo+=2"), t.to(this.allRoles[2], {
                    top: "-120%",
                    duration: .6,
                    ease: Ai.easeInOut
                }, "three+=2"), t.to(this.allRoles[0], {top: 0, duration: .6, ease: Ai.easeInOut}, "three+=2")
            }

            create() {
                super.create(), this.navigation = new ji(this.asscroll), new qi
            }

            show() {
                const t = Ai.timeline({delay: 1.5}), e = Wi.getRule(".landing__bottom-left:before"),
                    n = Wi.getRule(".landing__right:before");
                t.to(e, {
                    duration: .5,
                    ease: Ai.easeIn,
                    cssRule: {width: "131rem"}
                }, "firstStep"), t.to(n, {
                    duration: .5,
                    ease: Ai.easeIn,
                    cssRule: {height: "100vh"}
                }, "firstStep"), t.to(".landing__retrospective .SplitTextJS-char", {
                    opacity: 1,
                    stagger: .02,
                    delay: .2,
                    ease: Ai.easeInOut
                }, "firstStep"), t.to(".landing__name .SplitTextJS-char", {
                    rotateX: 0,
                    y: 0,
                    x: 0,
                    opacity: 1,
                    stagger: .03,
                    duration: .8,
                    ease: Ai.easeInOut
                }, "firstStep"), t.to(".landing__roles", {
                    opacity: 1,
                    y: 0,
                    duration: 1,
                    duration: .8,
                    ease: Ai.easeIn
                }, "firstStep+=1.3"), t.to(".landing__cta .SplitTextJS-char", {
                    rotateX: 0,
                    stagger: .03,
                    duration: .8,
                    ease: Ai.easeInOut
                });
                const i = Wi.getRule(".landing__cta:before");
                t.to(i, {
                    duration: .8,
                    ease: Ai.easeInOut,
                    cssRule: {width: "100%"}
                }, "firstStep+=2"), t.to("#scrollIcon", {
                    opacity: 1,
                    duration: .5,
                    delay: .5,
                    ease: Ai.easeInOut
                }, "firstStep+=2.1"), t.to(".navbar__menu--trigger", {
                    transitionDelay: .2,
                    transitionDuration: .6,
                    duration: 0
                }, "firstStep+=1")
            }

            initHomeSwiper() {
                new Swiper(".swiper", {
                    direction: "horizontal",
                    preventClicks: !0,
                    freeMode: {enabled: !0, momentumBounce: !1},
                    slidesPerView: "auto"
                })
            }

            initScroll(t) {
                Ai.ticker.add(t.update), t.currentPos = 0, this.isDesktop && t.on("scroll", (t => this.updateTilePositions(t))), t.enable({
                    horizontalScroll: !0 === this.isDesktop,
                    reset: !0
                }), t.resize()
            }

            onResize() {
                this.applySizes(), this.asscroll.resize()
            }

            addEventListeners() {
                window.innerWidth > 1024 && document.querySelectorAll(".landing__cta p")[1].addEventListener("click", (t => {
                    this.asscroll.scrollTo(this.tileManifestoPosition), Ai.to(this.tileLanding, {
                        x: -this.tileLanding.offsetWidth,
                        duration: 1.5
                    })
                })), window.addEventListener("resize", this.onResize.bind(this))
            }
        }

        const Yi = "135", Ji = 100, Zi = 301, Qi = 302, Ki = 303, $i = 304, tr = 306, er = 307, nr = 1e3, ir = 1001,
            rr = 1002, or = 1003, sr = 1004, ar = 1005, lr = 1006, cr = 1008, ur = 1009, hr = 1012, dr = 1014,
            pr = 1015, fr = 1016, mr = 1020, gr = 1022, vr = 1023, yr = 1026, xr = 1027, _r = 2300, br = 2301,
            wr = 2302, Sr = 2400, Mr = 2401, Tr = 2402, Er = 2500, Ar = 3e3, Pr = 3001, Lr = 3007, Cr = 3002, Rr = 7680,
            Ir = 35044, Or = 35048, Dr = "300 es";

        class zr {
            addEventListener(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
            }

            hasEventListener(t, e) {
                if (void 0 === this._listeners) return !1;
                const n = this._listeners;
                return void 0 !== n[t] && -1 !== n[t].indexOf(e)
            }

            removeEventListener(t, e) {
                if (void 0 === this._listeners) return;
                const n = this._listeners[t];
                if (void 0 !== n) {
                    const t = n.indexOf(e);
                    -1 !== t && n.splice(t, 1)
                }
            }

            dispatchEvent(t) {
                if (void 0 === this._listeners) return;
                const e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    const n = e.slice(0);
                    for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
                    t.target = null
                }
            }
        }

        const kr = [];
        for (let t = 0; t < 256; t++) kr[t] = (t < 16 ? "0" : "") + t.toString(16);
        const Nr = Math.PI / 180, Br = 180 / Math.PI;

        function Fr() {
            const t = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0,
                n = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0;
            return (kr[255 & t] + kr[t >> 8 & 255] + kr[t >> 16 & 255] + kr[t >> 24 & 255] + "-" + kr[255 & e] + kr[e >> 8 & 255] + "-" + kr[e >> 16 & 15 | 64] + kr[e >> 24 & 255] + "-" + kr[63 & n | 128] + kr[n >> 8 & 255] + "-" + kr[n >> 16 & 255] + kr[n >> 24 & 255] + kr[255 & i] + kr[i >> 8 & 255] + kr[i >> 16 & 255] + kr[i >> 24 & 255]).toUpperCase()
        }

        function Ur(t, e, n) {
            return Math.max(e, Math.min(n, t))
        }

        function Hr(t, e) {
            return (t % e + e) % e
        }

        function Vr(t, e, n) {
            return (1 - n) * t + n * e
        }

        function Gr(t) {
            return 0 == (t & t - 1) && 0 !== t
        }

        function Wr(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }

        class jr {
            constructor(t = 0, e = 0) {
                this.x = t, this.y = e
            }

            get width() {
                return this.x
            }

            set width(t) {
                this.x = t
            }

            get height() {
                return this.y
            }

            set height(t) {
                this.y = t
            }

            set(t, e) {
                return this.x = t, this.y = e, this
            }

            setScalar(t) {
                return this.x = t, this.y = t, this
            }

            setX(t) {
                return this.x = t, this
            }

            setY(t) {
                return this.y = t, this
            }

            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }

            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }

            clone() {
                return new this.constructor(this.x, this.y)
            }

            copy(t) {
                return this.x = t.x, this.y = t.y, this
            }

            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
            }

            addScalar(t) {
                return this.x += t, this.y += t, this
            }

            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this
            }

            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this
            }

            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
            }

            subScalar(t) {
                return this.x -= t, this.y -= t, this
            }

            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this
            }

            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this
            }

            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this
            }

            divide(t) {
                return this.x /= t.x, this.y /= t.y, this
            }

            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }

            applyMatrix3(t) {
                const e = this.x, n = this.y, i = t.elements;
                return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
            }

            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            }

            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            }

            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            }

            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
            }

            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }

            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }

            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }

            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }

            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            }

            negate() {
                return this.x = -this.x, this.y = -this.y, this
            }

            dot(t) {
                return this.x * t.x + this.y * t.y
            }

            cross(t) {
                return this.x * t.y - this.y * t.x
            }

            lengthSq() {
                return this.x * this.x + this.y * this.y
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }

            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }

            normalize() {
                return this.divideScalar(this.length() || 1)
            }

            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }

            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }

            distanceToSquared(t) {
                const e = this.x - t.x, n = this.y - t.y;
                return e * e + n * n
            }

            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }

            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }

            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            }

            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
            }

            equals(t) {
                return t.x === this.x && t.y === this.y
            }

            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this
            }

            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t
            }

            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
            }

            rotateAround(t, e) {
                const n = Math.cos(e), i = Math.sin(e), r = this.x - t.x, o = this.y - t.y;
                return this.x = r * n - o * i + t.x, this.y = r * i + o * n + t.y, this
            }

            random() {
                return this.x = Math.random(), this.y = Math.random(), this
            }

            * [Symbol.iterator]() {
                yield this.x, yield this.y
            }
        }

        jr.prototype.isVector2 = !0;

        class qr {
            constructor() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }

            set(t, e, n, i, r, o, s, a, l) {
                const c = this.elements;
                return c[0] = t, c[1] = i, c[2] = s, c[3] = e, c[4] = r, c[5] = a, c[6] = n, c[7] = o, c[8] = l, this
            }

            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }

            copy(t) {
                const e = this.elements, n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
            }

            extractBasis(t, e, n) {
                return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
            }

            setFromMatrix4(t) {
                const e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
            }

            multiply(t) {
                return this.multiplyMatrices(this, t)
            }

            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }

            multiplyMatrices(t, e) {
                const n = t.elements, i = e.elements, r = this.elements, o = n[0], s = n[3], a = n[6], l = n[1],
                    c = n[4], u = n[7], h = n[2], d = n[5], p = n[8], f = i[0], m = i[3], g = i[6], v = i[1], y = i[4],
                    x = i[7], _ = i[2], b = i[5], w = i[8];
                return r[0] = o * f + s * v + a * _, r[3] = o * m + s * y + a * b, r[6] = o * g + s * x + a * w, r[1] = l * f + c * v + u * _, r[4] = l * m + c * y + u * b, r[7] = l * g + c * x + u * w, r[2] = h * f + d * v + p * _, r[5] = h * m + d * y + p * b, r[8] = h * g + d * x + p * w, this
            }

            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
            }

            determinant() {
                const t = this.elements, e = t[0], n = t[1], i = t[2], r = t[3], o = t[4], s = t[5], a = t[6], l = t[7],
                    c = t[8];
                return e * o * c - e * s * l - n * r * c + n * s * a + i * r * l - i * o * a
            }

            invert() {
                const t = this.elements, e = t[0], n = t[1], i = t[2], r = t[3], o = t[4], s = t[5], a = t[6], l = t[7],
                    c = t[8], u = c * o - s * l, h = s * a - c * r, d = l * r - o * a, p = e * u + n * h + i * d;
                if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const f = 1 / p;
                return t[0] = u * f, t[1] = (i * l - c * n) * f, t[2] = (s * n - i * o) * f, t[3] = h * f, t[4] = (c * e - i * a) * f, t[5] = (i * r - s * e) * f, t[6] = d * f, t[7] = (n * a - l * e) * f, t[8] = (o * e - n * r) * f, this
            }

            transpose() {
                let t;
                const e = this.elements;
                return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
            }

            getNormalMatrix(t) {
                return this.setFromMatrix4(t).invert().transpose()
            }

            transposeIntoArray(t) {
                const e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            }

            setUvTransform(t, e, n, i, r, o, s) {
                const a = Math.cos(r), l = Math.sin(r);
                return this.set(n * a, n * l, -n * (a * o + l * s) + o + t, -i * l, i * a, -i * (-l * o + a * s) + s + e, 0, 0, 1), this
            }

            scale(t, e) {
                const n = this.elements;
                return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
            }

            rotate(t) {
                const e = Math.cos(t), n = Math.sin(t), i = this.elements, r = i[0], o = i[3], s = i[6], a = i[1],
                    l = i[4], c = i[7];
                return i[0] = e * r + n * a, i[3] = e * o + n * l, i[6] = e * s + n * c, i[1] = -n * r + e * a, i[4] = -n * o + e * l, i[7] = -n * s + e * c, this
            }

            translate(t, e) {
                const n = this.elements;
                return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
            }

            equals(t) {
                const e = this.elements, n = t.elements;
                for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
                return !0
            }

            fromArray(t, e = 0) {
                for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                return this
            }

            toArray(t = [], e = 0) {
                const n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
            }

            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }

        function Xr(t) {
            if (0 === t.length) return -1 / 0;
            let e = t[0];
            for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
            return e
        }

        qr.prototype.isMatrix3 = !0;
        Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;

        function Yr(t) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", t)
        }

        function Jr(t, e = 0) {
            let n = 3735928559 ^ e, i = 1103547991 ^ e;
            for (let e, r = 0; r < t.length; r++) e = t.charCodeAt(r), n = Math.imul(n ^ e, 2654435761), i = Math.imul(i ^ e, 1597334677);
            return n = Math.imul(n ^ n >>> 16, 2246822507) ^ Math.imul(i ^ i >>> 13, 3266489909), i = Math.imul(i ^ i >>> 16, 2246822507) ^ Math.imul(n ^ n >>> 13, 3266489909), 4294967296 * (2097151 & i) + (n >>> 0)
        }

        let Zr;

        class Qr {
            static getDataURL(t) {
                if (/^data:/i.test(t.src)) return t.src;
                if ("undefined" == typeof HTMLCanvasElement) return t.src;
                let e;
                if (t instanceof HTMLCanvasElement) e = t; else {
                    void 0 === Zr && (Zr = Yr("canvas")), Zr.width = t.width, Zr.height = t.height;
                    const n = Zr.getContext("2d");
                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Zr
                }
                return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
            }
        }

        let Kr = 0;

        class $r extends zr {
            constructor(t = $r.DEFAULT_IMAGE, e = $r.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, o = 1008, s = 1023, a = 1009, l = 1, c = 3e3) {
                super(), Object.defineProperty(this, "id", {value: Kr++}), this.uuid = Fr(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = o, this.anisotropy = l, this.format = s, this.internalFormat = null, this.type = a, this.offset = new jr(0, 0), this.repeat = new jr(1, 1), this.center = new jr(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new qr, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1
            }

            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            copy(t) {
                return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this.userData = JSON.parse(JSON.stringify(t.userData)), this
            }

            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                const n = {
                    metadata: {version: 4.5, type: "Texture", generator: "Texture.toJSON"},
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if (void 0 !== this.image) {
                    const i = this.image;
                    if (void 0 === i.uuid && (i.uuid = Fr()), !e && void 0 === t.images[i.uuid]) {
                        let e;
                        if (Array.isArray(i)) {
                            e = [];
                            for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(to(i[t].image)) : e.push(to(i[t]))
                        } else e = to(i);
                        t.images[i.uuid] = {uuid: i.uuid, url: e}
                    }
                    n.image = i.uuid
                }
                return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n
            }

            dispose() {
                this.dispatchEvent({type: "dispose"})
            }

            transformUv(t) {
                if (300 !== this.mapping) return t;
                if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                    case nr:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case ir:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case rr:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
                if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                    case nr:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case ir:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case rr:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
                return this.flipY && (t.y = 1 - t.y), t
            }

            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }

        function to(t) {
            return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? Qr.getDataURL(t) : t.data ? {
                data: Array.prototype.slice.call(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
        }

        $r.DEFAULT_IMAGE = void 0, $r.DEFAULT_MAPPING = 300, $r.prototype.isTexture = !0;

        class eo {
            constructor(t = 0, e = 0, n = 0, i = 1) {
                this.x = t, this.y = e, this.z = n, this.w = i
            }

            get width() {
                return this.z
            }

            set width(t) {
                this.z = t
            }

            get height() {
                return this.w
            }

            set height(t) {
                this.w = t
            }

            set(t, e, n, i) {
                return this.x = t, this.y = e, this.z = n, this.w = i, this
            }

            setScalar(t) {
                return this.x = t, this.y = t, this.z = t, this.w = t, this
            }

            setX(t) {
                return this.x = t, this
            }

            setY(t) {
                return this.y = t, this
            }

            setZ(t) {
                return this.z = t, this
            }

            setW(t) {
                return this.w = t, this
            }

            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }

            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }

            clone() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }

            copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            }

            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
            }

            addScalar(t) {
                return this.x += t, this.y += t, this.z += t, this.w += t, this
            }

            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
            }

            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
            }

            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
            }

            subScalar(t) {
                return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
            }

            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
            }

            multiply(t) {
                return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
            }

            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
            }

            applyMatrix4(t) {
                const e = this.x, n = this.y, i = this.z, r = this.w, o = t.elements;
                return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r, this
            }

            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }

            setAxisAngleFromQuaternion(t) {
                this.w = 2 * Math.acos(t.w);
                const e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
            }

            setAxisAngleFromRotationMatrix(t) {
                let e, n, i, r;
                const o = .01, s = .1, a = t.elements, l = a[0], c = a[4], u = a[8], h = a[1], d = a[5], p = a[9],
                    f = a[2], m = a[6], g = a[10];
                if (Math.abs(c - h) < o && Math.abs(u - f) < o && Math.abs(p - m) < o) {
                    if (Math.abs(c + h) < s && Math.abs(u + f) < s && Math.abs(p + m) < s && Math.abs(l + d + g - 3) < s) return this.set(1, 0, 0, 0), this;
                    e = Math.PI;
                    const t = (l + 1) / 2, a = (d + 1) / 2, v = (g + 1) / 2, y = (c + h) / 4, x = (u + f) / 4,
                        _ = (p + m) / 4;
                    return t > a && t > v ? t < o ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(t), i = y / n, r = x / n) : a > v ? a < o ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(a), n = y / i, r = _ / i) : v < o ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(v), n = x / r, i = _ / r), this.set(n, i, r, e), this
                }
                let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c));
                return Math.abs(v) < .001 && (v = 1), this.x = (m - p) / v, this.y = (u - f) / v, this.z = (h - c) / v, this.w = Math.acos((l + d + g - 1) / 2), this
            }

            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            }

            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            }

            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            }

            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
            }

            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }

            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }

            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }

            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }

            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            }

            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }

            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }

            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }

            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }

            normalize() {
                return this.divideScalar(this.length() || 1)
            }

            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }

            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            }

            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
            }

            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }

            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            }

            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            }

            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            }

            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            }

            * [Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z, yield this.w
            }
        }

        eo.prototype.isVector4 = !0;

        class no extends zr {
            constructor(t, e, n = {}) {
                super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new eo(0, 0, t, e), this.scissorTest = !1, this.viewport = new eo(0, 0, t, e), this.texture = new $r(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
                    width: t,
                    height: e,
                    depth: 1
                }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : lr, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }

            setTexture(t) {
                t.image = {width: this.width, height: this.height, depth: this.depth}, this.texture = t
            }

            setSize(t, e, n = 1) {
                this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            copy(t) {
                return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.image = {...this.texture.image}, this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
            }

            dispose() {
                this.dispatchEvent({type: "dispose"})
            }
        }

        no.prototype.isWebGLRenderTarget = !0;
        (class extends no {
            constructor(t, e, n) {
                super(t, e);
                const i = this.texture;
                this.texture = [];
                for (let t = 0; t < n; t++) this.texture[t] = i.clone()
            }

            setSize(t, e, n = 1) {
                if (this.width !== t || this.height !== e || this.depth !== n) {
                    this.width = t, this.height = e, this.depth = n;
                    for (let i = 0, r = this.texture.length; i < r; i++) this.texture[i].image.width = t, this.texture[i].image.height = e, this.texture[i].image.depth = n;
                    this.dispose()
                }
                return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
            }

            copy(t) {
                this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0;
                for (let e = 0, n = t.texture.length; e < n; e++) this.texture[e] = t.texture[e].clone();
                return this
            }
        }).prototype.isWebGLMultipleRenderTargets = !0;

        class io extends no {
            constructor(t, e, n = {}) {
                super(t, e, n), this.samples = 4, this.ignoreDepthForMultisampleCopy = void 0 === n.ignoreDepth || n.ignoreDepth, this.useRenderToTexture = void 0 !== n.useRenderToTexture && n.useRenderToTexture, this.useRenderbuffer = !1 === this.useRenderToTexture
            }

            copy(t) {
                return super.copy.call(this, t), this.samples = t.samples, this.useRenderToTexture = t.useRenderToTexture, this.useRenderbuffer = t.useRenderbuffer, this
            }
        }

        io.prototype.isWebGLMultisampleRenderTarget = !0;

        class ro {
            constructor(t = 0, e = 0, n = 0, i = 1) {
                this._x = t, this._y = e, this._z = n, this._w = i
            }

            static slerp(t, e, n, i) {
                return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, i)
            }

            static slerpFlat(t, e, n, i, r, o, s) {
                let a = n[i + 0], l = n[i + 1], c = n[i + 2], u = n[i + 3];
                const h = r[o + 0], d = r[o + 1], p = r[o + 2], f = r[o + 3];
                if (0 === s) return t[e + 0] = a, t[e + 1] = l, t[e + 2] = c, void (t[e + 3] = u);
                if (1 === s) return t[e + 0] = h, t[e + 1] = d, t[e + 2] = p, void (t[e + 3] = f);
                if (u !== f || a !== h || l !== d || c !== p) {
                    let t = 1 - s;
                    const e = a * h + l * d + c * p + u * f, n = e >= 0 ? 1 : -1, i = 1 - e * e;
                    if (i > Number.EPSILON) {
                        const r = Math.sqrt(i), o = Math.atan2(r, e * n);
                        t = Math.sin(t * o) / r, s = Math.sin(s * o) / r
                    }
                    const r = s * n;
                    if (a = a * t + h * r, l = l * t + d * r, c = c * t + p * r, u = u * t + f * r, t === 1 - s) {
                        const t = 1 / Math.sqrt(a * a + l * l + c * c + u * u);
                        a *= t, l *= t, c *= t, u *= t
                    }
                }
                t[e] = a, t[e + 1] = l, t[e + 2] = c, t[e + 3] = u
            }

            static multiplyQuaternionsFlat(t, e, n, i, r, o) {
                const s = n[i], a = n[i + 1], l = n[i + 2], c = n[i + 3], u = r[o], h = r[o + 1], d = r[o + 2],
                    p = r[o + 3];
                return t[e] = s * p + c * u + a * d - l * h, t[e + 1] = a * p + c * h + l * u - s * d, t[e + 2] = l * p + c * d + s * h - a * u, t[e + 3] = c * p - s * u - a * h - l * d, t
            }

            get x() {
                return this._x
            }

            set x(t) {
                this._x = t, this._onChangeCallback()
            }

            get y() {
                return this._y
            }

            set y(t) {
                this._y = t, this._onChangeCallback()
            }

            get z() {
                return this._z
            }

            set z(t) {
                this._z = t, this._onChangeCallback()
            }

            get w() {
                return this._w
            }

            set w(t) {
                this._w = t, this._onChangeCallback()
            }

            set(t, e, n, i) {
                return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
            }

            clone() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            }

            copy(t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
            }

            setFromEuler(t, e) {
                if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                const n = t._x, i = t._y, r = t._z, o = t._order, s = Math.cos, a = Math.sin, l = s(n / 2),
                    c = s(i / 2), u = s(r / 2), h = a(n / 2), d = a(i / 2), p = a(r / 2);
                switch (o) {
                    case"XYZ":
                        this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p;
                        break;
                    case"YXZ":
                        this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p;
                        break;
                    case"ZXY":
                        this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p;
                        break;
                    case"ZYX":
                        this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p;
                        break;
                    case"YZX":
                        this._x = h * c * u + l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u - h * d * p;
                        break;
                    case"XZY":
                        this._x = h * c * u - l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u + h * d * p;
                        break;
                    default:
                        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
                }
                return !1 !== e && this._onChangeCallback(), this
            }

            setFromAxisAngle(t, e) {
                const n = e / 2, i = Math.sin(n);
                return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
            }

            setFromRotationMatrix(t) {
                const e = t.elements, n = e[0], i = e[4], r = e[8], o = e[1], s = e[5], a = e[9], l = e[2], c = e[6],
                    u = e[10], h = n + s + u;
                if (h > 0) {
                    const t = .5 / Math.sqrt(h + 1);
                    this._w = .25 / t, this._x = (c - a) * t, this._y = (r - l) * t, this._z = (o - i) * t
                } else if (n > s && n > u) {
                    const t = 2 * Math.sqrt(1 + n - s - u);
                    this._w = (c - a) / t, this._x = .25 * t, this._y = (i + o) / t, this._z = (r + l) / t
                } else if (s > u) {
                    const t = 2 * Math.sqrt(1 + s - n - u);
                    this._w = (r - l) / t, this._x = (i + o) / t, this._y = .25 * t, this._z = (a + c) / t
                } else {
                    const t = 2 * Math.sqrt(1 + u - n - s);
                    this._w = (o - i) / t, this._x = (r + l) / t, this._y = (a + c) / t, this._z = .25 * t
                }
                return this._onChangeCallback(), this
            }

            setFromUnitVectors(t, e) {
                let n = t.dot(e) + 1;
                return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
            }

            angleTo(t) {
                return 2 * Math.acos(Math.abs(Ur(this.dot(t), -1, 1)))
            }

            rotateTowards(t, e) {
                const n = this.angleTo(t);
                if (0 === n) return this;
                const i = Math.min(1, e / n);
                return this.slerp(t, i), this
            }

            identity() {
                return this.set(0, 0, 0, 1)
            }

            invert() {
                return this.conjugate()
            }

            conjugate() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            }

            dot(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }

            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }

            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }

            normalize() {
                let t = this.length();
                return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
            }

            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
            }

            premultiply(t) {
                return this.multiplyQuaternions(t, this)
            }

            multiplyQuaternions(t, e) {
                const n = t._x, i = t._y, r = t._z, o = t._w, s = e._x, a = e._y, l = e._z, c = e._w;
                return this._x = n * c + o * s + i * l - r * a, this._y = i * c + o * a + r * s - n * l, this._z = r * c + o * l + n * a - i * s, this._w = o * c - n * s - i * a - r * l, this._onChangeCallback(), this
            }

            slerp(t, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(t);
                const n = this._x, i = this._y, r = this._z, o = this._w;
                let s = o * t._w + n * t._x + i * t._y + r * t._z;
                if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1) return this._w = o, this._x = n, this._y = i, this._z = r, this;
                const a = 1 - s * s;
                if (a <= Number.EPSILON) {
                    const t = 1 - e;
                    return this._w = t * o + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this
                }
                const l = Math.sqrt(a), c = Math.atan2(l, s), u = Math.sin((1 - e) * c) / l, h = Math.sin(e * c) / l;
                return this._w = o * u + this._w * h, this._x = n * u + this._x * h, this._y = i * u + this._y * h, this._z = r * u + this._z * h, this._onChangeCallback(), this
            }

            slerpQuaternions(t, e, n) {
                this.copy(t).slerp(e, n)
            }

            random() {
                const t = Math.random(), e = Math.sqrt(1 - t), n = Math.sqrt(t), i = 2 * Math.PI * Math.random(),
                    r = 2 * Math.PI * Math.random();
                return this.set(e * Math.cos(i), n * Math.sin(r), n * Math.cos(r), e * Math.sin(i))
            }

            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }

            fromArray(t, e = 0) {
                return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
            }

            toArray(t = [], e = 0) {
                return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            }

            fromBufferAttribute(t, e) {
                return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
            }

            _onChange(t) {
                return this._onChangeCallback = t, this
            }

            _onChangeCallback() {
            }
        }

        ro.prototype.isQuaternion = !0;

        class oo {
            constructor(t = 0, e = 0, n = 0) {
                this.x = t, this.y = e, this.z = n
            }

            set(t, e, n) {
                return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
            }

            setScalar(t) {
                return this.x = t, this.y = t, this.z = t, this
            }

            setX(t) {
                return this.x = t, this
            }

            setY(t) {
                return this.y = t, this
            }

            setZ(t) {
                return this.z = t, this
            }

            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }

            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }

            clone() {
                return new this.constructor(this.x, this.y, this.z)
            }

            copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            }

            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
            }

            addScalar(t) {
                return this.x += t, this.y += t, this.z += t, this
            }

            addVectors(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
            }

            addScaledVector(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
            }

            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
            }

            subScalar(t) {
                return this.x -= t, this.y -= t, this.z -= t, this
            }

            subVectors(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
            }

            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
            }

            multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this
            }

            multiplyVectors(t, e) {
                return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
            }

            applyEuler(t) {
                return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(ao.setFromEuler(t))
            }

            applyAxisAngle(t, e) {
                return this.applyQuaternion(ao.setFromAxisAngle(t, e))
            }

            applyMatrix3(t) {
                const e = this.x, n = this.y, i = this.z, r = t.elements;
                return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
            }

            applyNormalMatrix(t) {
                return this.applyMatrix3(t).normalize()
            }

            applyMatrix4(t) {
                const e = this.x, n = this.y, i = this.z, r = t.elements,
                    o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o, this
            }

            applyQuaternion(t) {
                const e = this.x, n = this.y, i = this.z, r = t.x, o = t.y, s = t.z, a = t.w, l = a * e + o * i - s * n,
                    c = a * n + s * e - r * i, u = a * i + r * n - o * e, h = -r * e - o * n - s * i;
                return this.x = l * a + h * -r + c * -s - u * -o, this.y = c * a + h * -o + u * -r - l * -s, this.z = u * a + h * -s + l * -o - c * -r, this
            }

            project(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }

            unproject(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }

            transformDirection(t) {
                const e = this.x, n = this.y, i = this.z, r = t.elements;
                return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
            }

            divide(t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            }

            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }

            min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            }

            max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            }

            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            }

            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
            }

            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }

            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }

            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }

            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }

            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            }

            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }

            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }

            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }

            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }

            normalize() {
                return this.divideScalar(this.length() || 1)
            }

            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }

            lerp(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            }

            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
            }

            cross(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
            }

            crossVectors(t, e) {
                const n = t.x, i = t.y, r = t.z, o = e.x, s = e.y, a = e.z;
                return this.x = i * a - r * s, this.y = r * o - n * a, this.z = n * s - i * o, this
            }

            projectOnVector(t) {
                const e = t.lengthSq();
                if (0 === e) return this.set(0, 0, 0);
                const n = t.dot(this) / e;
                return this.copy(t).multiplyScalar(n)
            }

            projectOnPlane(t) {
                return so.copy(this).projectOnVector(t), this.sub(so)
            }

            reflect(t) {
                return this.sub(so.copy(t).multiplyScalar(2 * this.dot(t)))
            }

            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e) return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(Ur(n, -1, 1))
            }

            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }

            distanceToSquared(t) {
                const e = this.x - t.x, n = this.y - t.y, i = this.z - t.z;
                return e * e + n * n + i * i
            }

            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }

            setFromSpherical(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            }

            setFromSphericalCoords(t, e, n) {
                const i = Math.sin(e) * t;
                return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
            }

            setFromCylindrical(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }

            setFromCylindricalCoords(t, e, n) {
                return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
            }

            setFromMatrixPosition(t) {
                const e = t.elements;
                return this.x = e[12], this.y = e[13], this.z = e[14], this
            }

            setFromMatrixScale(t) {
                const e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(),
                    i = this.setFromMatrixColumn(t, 2).length();
                return this.x = e, this.y = n, this.z = i, this
            }

            setFromMatrixColumn(t, e) {
                return this.fromArray(t.elements, 4 * e)
            }

            setFromMatrix3Column(t, e) {
                return this.fromArray(t.elements, 3 * e)
            }

            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }

            fromArray(t, e = 0) {
                return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            }

            toArray(t = [], e = 0) {
                return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            }

            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            }

            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
            }

            randomDirection() {
                const t = 2 * (Math.random() - .5), e = Math.random() * Math.PI * 2, n = Math.sqrt(1 - t ** 2);
                return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this
            }

            * [Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z
            }
        }

        oo.prototype.isVector3 = !0;
        const so = new oo, ao = new ro;

        class lo {
            constructor(t = new oo(1 / 0, 1 / 0, 1 / 0), e = new oo(-1 / 0, -1 / 0, -1 / 0)) {
                this.min = t, this.max = e
            }

            set(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }

            setFromArray(t) {
                let e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, s = -1 / 0;
                for (let a = 0, l = t.length; a < l; a += 3) {
                    const l = t[a], c = t[a + 1], u = t[a + 2];
                    l < e && (e = l), c < n && (n = c), u < i && (i = u), l > r && (r = l), c > o && (o = c), u > s && (s = u)
                }
                return this.min.set(e, n, i), this.max.set(r, o, s), this
            }

            setFromBufferAttribute(t) {
                let e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, s = -1 / 0;
                for (let a = 0, l = t.count; a < l; a++) {
                    const l = t.getX(a), c = t.getY(a), u = t.getZ(a);
                    l < e && (e = l), c < n && (n = c), u < i && (i = u), l > r && (r = l), c > o && (o = c), u > s && (s = u)
                }
                return this.min.set(e, n, i), this.max.set(r, o, s), this
            }

            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                return this
            }

            setFromCenterAndSize(t, e) {
                const n = uo.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
            }

            setFromObject(t) {
                return this.makeEmpty(), this.expandByObject(t)
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            copy(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }

            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            }

            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }

            getCenter(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }

            getSize(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }

            expandByPoint(t) {
                return this.min.min(t), this.max.max(t), this
            }

            expandByVector(t) {
                return this.min.sub(t), this.max.add(t), this
            }

            expandByScalar(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }

            expandByObject(t) {
                t.updateWorldMatrix(!1, !1);
                const e = t.geometry;
                void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), ho.copy(e.boundingBox), ho.applyMatrix4(t.matrixWorld), this.union(ho));
                const n = t.children;
                for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
                return this
            }

            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }

            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }

            getParameter(t, e) {
                return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }

            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }

            intersectsSphere(t) {
                return this.clampPoint(t.center, uo), uo.distanceToSquared(t.center) <= t.radius * t.radius
            }

            intersectsPlane(t) {
                let e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
            }

            intersectsTriangle(t) {
                if (this.isEmpty()) return !1;
                this.getCenter(xo), _o.subVectors(this.max, xo), po.subVectors(t.a, xo), fo.subVectors(t.b, xo), mo.subVectors(t.c, xo), go.subVectors(fo, po), vo.subVectors(mo, fo), yo.subVectors(po, mo);
                let e = [0, -go.z, go.y, 0, -vo.z, vo.y, 0, -yo.z, yo.y, go.z, 0, -go.x, vo.z, 0, -vo.x, yo.z, 0, -yo.x, -go.y, go.x, 0, -vo.y, vo.x, 0, -yo.y, yo.x, 0];
                return !!So(e, po, fo, mo, _o) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!So(e, po, fo, mo, _o) && (bo.crossVectors(go, vo), e = [bo.x, bo.y, bo.z], So(e, po, fo, mo, _o)))
            }

            clampPoint(t, e) {
                return e.copy(t).clamp(this.min, this.max)
            }

            distanceToPoint(t) {
                return uo.copy(t).clamp(this.min, this.max).sub(t).length()
            }

            getBoundingSphere(t) {
                return this.getCenter(t.center), t.radius = .5 * this.getSize(uo).length(), t
            }

            intersect(t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            }

            union(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }

            applyMatrix4(t) {
                return this.isEmpty() || (co[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), co[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), co[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), co[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), co[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), co[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), co[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), co[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(co)), this
            }

            translate(t) {
                return this.min.add(t), this.max.add(t), this
            }

            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }

        lo.prototype.isBox3 = !0;
        const co = [new oo, new oo, new oo, new oo, new oo, new oo, new oo, new oo], uo = new oo, ho = new lo,
            po = new oo, fo = new oo, mo = new oo, go = new oo, vo = new oo, yo = new oo, xo = new oo, _o = new oo,
            bo = new oo, wo = new oo;

        function So(t, e, n, i, r) {
            for (let o = 0, s = t.length - 3; o <= s; o += 3) {
                wo.fromArray(t, o);
                const s = r.x * Math.abs(wo.x) + r.y * Math.abs(wo.y) + r.z * Math.abs(wo.z), a = e.dot(wo),
                    l = n.dot(wo), c = i.dot(wo);
                if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > s) return !1
            }
            return !0
        }

        const Mo = new lo, To = new oo, Eo = new oo, Ao = new oo;

        class Po {
            constructor(t = new oo, e = -1) {
                this.center = t, this.radius = e
            }

            set(t, e) {
                return this.center.copy(t), this.radius = e, this
            }

            setFromPoints(t, e) {
                const n = this.center;
                void 0 !== e ? n.copy(e) : Mo.setFromPoints(t).getCenter(n);
                let i = 0;
                for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
                return this.radius = Math.sqrt(i), this
            }

            copy(t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            }

            isEmpty() {
                return this.radius < 0
            }

            makeEmpty() {
                return this.center.set(0, 0, 0), this.radius = -1, this
            }

            containsPoint(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }

            distanceToPoint(t) {
                return t.distanceTo(this.center) - this.radius
            }

            intersectsSphere(t) {
                const e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }

            intersectsBox(t) {
                return t.intersectsSphere(this)
            }

            intersectsPlane(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }

            clampPoint(t, e) {
                const n = this.center.distanceToSquared(t);
                return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
            }

            getBoundingBox(t) {
                return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
            }

            applyMatrix4(t) {
                return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
            }

            translate(t) {
                return this.center.add(t), this
            }

            expandByPoint(t) {
                Ao.subVectors(t, this.center);
                const e = Ao.lengthSq();
                if (e > this.radius * this.radius) {
                    const t = Math.sqrt(e), n = .5 * (t - this.radius);
                    this.center.add(Ao.multiplyScalar(n / t)), this.radius += n
                }
                return this
            }

            union(t) {
                return Eo.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(To.copy(t.center).add(Eo)), this.expandByPoint(To.copy(t.center).sub(Eo)), this
            }

            equals(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }

            clone() {
                return (new this.constructor).copy(this)
            }
        }

        const Lo = new oo, Co = new oo, Ro = new oo, Io = new oo, Oo = new oo, Do = new oo, zo = new oo;

        class ko {
            constructor(t = new oo, e = new oo(0, 0, -1)) {
                this.origin = t, this.direction = e
            }

            set(t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            }

            copy(t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            }

            at(t, e) {
                return e.copy(this.direction).multiplyScalar(t).add(this.origin)
            }

            lookAt(t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            }

            recast(t) {
                return this.origin.copy(this.at(t, Lo)), this
            }

            closestPointToPoint(t, e) {
                e.subVectors(t, this.origin);
                const n = e.dot(this.direction);
                return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
            }

            distanceToPoint(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }

            distanceSqToPoint(t) {
                const e = Lo.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (Lo.copy(this.direction).multiplyScalar(e).add(this.origin), Lo.distanceToSquared(t))
            }

            distanceSqToSegment(t, e, n, i) {
                Co.copy(t).add(e).multiplyScalar(.5), Ro.copy(e).sub(t).normalize(), Io.copy(this.origin).sub(Co);
                const r = .5 * t.distanceTo(e), o = -this.direction.dot(Ro), s = Io.dot(this.direction),
                    a = -Io.dot(Ro), l = Io.lengthSq(), c = Math.abs(1 - o * o);
                let u, h, d, p;
                if (c > 0) if (u = o * a - s, h = o * s - a, p = r * c, u >= 0) if (h >= -p) if (h <= p) {
                    const t = 1 / c;
                    u *= t, h *= t, d = u * (u + o * h + 2 * s) + h * (o * u + h + 2 * a) + l
                } else h = r, u = Math.max(0, -(o * h + s)), d = -u * u + h * (h + 2 * a) + l; else h = -r, u = Math.max(0, -(o * h + s)), d = -u * u + h * (h + 2 * a) + l; else h <= -p ? (u = Math.max(0, -(-o * r + s)), h = u > 0 ? -r : Math.min(Math.max(-r, -a), r), d = -u * u + h * (h + 2 * a) + l) : h <= p ? (u = 0, h = Math.min(Math.max(-r, -a), r), d = h * (h + 2 * a) + l) : (u = Math.max(0, -(o * r + s)), h = u > 0 ? r : Math.min(Math.max(-r, -a), r), d = -u * u + h * (h + 2 * a) + l); else h = o > 0 ? -r : r, u = Math.max(0, -(o * h + s)), d = -u * u + h * (h + 2 * a) + l;
                return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), i && i.copy(Ro).multiplyScalar(h).add(Co), d
            }

            intersectSphere(t, e) {
                Lo.subVectors(t.center, this.origin);
                const n = Lo.dot(this.direction), i = Lo.dot(Lo) - n * n, r = t.radius * t.radius;
                if (i > r) return null;
                const o = Math.sqrt(r - i), s = n - o, a = n + o;
                return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e)
            }

            intersectsSphere(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }

            distanceToPlane(t) {
                const e = t.normal.dot(this.direction);
                if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n : null
            }

            intersectPlane(t, e) {
                const n = this.distanceToPlane(t);
                return null === n ? null : this.at(n, e)
            }

            intersectsPlane(t) {
                const e = t.distanceToPoint(this.origin);
                if (0 === e) return !0;
                return t.normal.dot(this.direction) * e < 0
            }

            intersectBox(t, e) {
                let n, i, r, o, s, a;
                const l = 1 / this.direction.x, c = 1 / this.direction.y, u = 1 / this.direction.z, h = this.origin;
                return l >= 0 ? (n = (t.min.x - h.x) * l, i = (t.max.x - h.x) * l) : (n = (t.max.x - h.x) * l, i = (t.min.x - h.x) * l), c >= 0 ? (r = (t.min.y - h.y) * c, o = (t.max.y - h.y) * c) : (r = (t.max.y - h.y) * c, o = (t.min.y - h.y) * c), n > o || r > i ? null : ((r > n || n != n) && (n = r), (o < i || i != i) && (i = o), u >= 0 ? (s = (t.min.z - h.z) * u, a = (t.max.z - h.z) * u) : (s = (t.max.z - h.z) * u, a = (t.min.z - h.z) * u), n > a || s > i ? null : ((s > n || n != n) && (n = s), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            }

            intersectsBox(t) {
                return null !== this.intersectBox(t, Lo)
            }

            intersectTriangle(t, e, n, i, r) {
                Oo.subVectors(e, t), Do.subVectors(n, t), zo.crossVectors(Oo, Do);
                let o, s = this.direction.dot(zo);
                if (s > 0) {
                    if (i) return null;
                    o = 1
                } else {
                    if (!(s < 0)) return null;
                    o = -1, s = -s
                }
                Io.subVectors(this.origin, t);
                const a = o * this.direction.dot(Do.crossVectors(Io, Do));
                if (a < 0) return null;
                const l = o * this.direction.dot(Oo.cross(Io));
                if (l < 0) return null;
                if (a + l > s) return null;
                const c = -o * Io.dot(zo);
                return c < 0 ? null : this.at(c / s, r)
            }

            applyMatrix4(t) {
                return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
            }

            equals(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }

            clone() {
                return (new this.constructor).copy(this)
            }
        }

        class No {
            constructor() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }

            set(t, e, n, i, r, o, s, a, l, c, u, h, d, p, f, m) {
                const g = this.elements;
                return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = o, g[9] = s, g[13] = a, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
            }

            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }

            clone() {
                return (new No).fromArray(this.elements)
            }

            copy(t) {
                const e = this.elements, n = t.elements;
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
            }

            copyPosition(t) {
                const e = this.elements, n = t.elements;
                return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
            }

            setFromMatrix3(t) {
                const e = t.elements;
                return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
            }

            extractBasis(t, e, n) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
            }

            makeBasis(t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
            }

            extractRotation(t) {
                const e = this.elements, n = t.elements, i = 1 / Bo.setFromMatrixColumn(t, 0).length(),
                    r = 1 / Bo.setFromMatrixColumn(t, 1).length(), o = 1 / Bo.setFromMatrixColumn(t, 2).length();
                return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }

            makeRotationFromEuler(t) {
                t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                const e = this.elements, n = t.x, i = t.y, r = t.z, o = Math.cos(n), s = Math.sin(n), a = Math.cos(i),
                    l = Math.sin(i), c = Math.cos(r), u = Math.sin(r);
                if ("XYZ" === t.order) {
                    const t = o * c, n = o * u, i = s * c, r = s * u;
                    e[0] = a * c, e[4] = -a * u, e[8] = l, e[1] = n + i * l, e[5] = t - r * l, e[9] = -s * a, e[2] = r - t * l, e[6] = i + n * l, e[10] = o * a
                } else if ("YXZ" === t.order) {
                    const t = a * c, n = a * u, i = l * c, r = l * u;
                    e[0] = t + r * s, e[4] = i * s - n, e[8] = o * l, e[1] = o * u, e[5] = o * c, e[9] = -s, e[2] = n * s - i, e[6] = r + t * s, e[10] = o * a
                } else if ("ZXY" === t.order) {
                    const t = a * c, n = a * u, i = l * c, r = l * u;
                    e[0] = t - r * s, e[4] = -o * u, e[8] = i + n * s, e[1] = n + i * s, e[5] = o * c, e[9] = r - t * s, e[2] = -o * l, e[6] = s, e[10] = o * a
                } else if ("ZYX" === t.order) {
                    const t = o * c, n = o * u, i = s * c, r = s * u;
                    e[0] = a * c, e[4] = i * l - n, e[8] = t * l + r, e[1] = a * u, e[5] = r * l + t, e[9] = n * l - i, e[2] = -l, e[6] = s * a, e[10] = o * a
                } else if ("YZX" === t.order) {
                    const t = o * a, n = o * l, i = s * a, r = s * l;
                    e[0] = a * c, e[4] = r - t * u, e[8] = i * u + n, e[1] = u, e[5] = o * c, e[9] = -s * c, e[2] = -l * c, e[6] = n * u + i, e[10] = t - r * u
                } else if ("XZY" === t.order) {
                    const t = o * a, n = o * l, i = s * a, r = s * l;
                    e[0] = a * c, e[4] = -u, e[8] = l * c, e[1] = t * u + r, e[5] = o * c, e[9] = n * u - i, e[2] = i * u - n, e[6] = s * c, e[10] = r * u + t
                }
                return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            }

            makeRotationFromQuaternion(t) {
                return this.compose(Uo, t, Ho)
            }

            lookAt(t, e, n) {
                const i = this.elements;
                return Wo.subVectors(t, e), 0 === Wo.lengthSq() && (Wo.z = 1), Wo.normalize(), Vo.crossVectors(n, Wo), 0 === Vo.lengthSq() && (1 === Math.abs(n.z) ? Wo.x += 1e-4 : Wo.z += 1e-4, Wo.normalize(), Vo.crossVectors(n, Wo)), Vo.normalize(), Go.crossVectors(Wo, Vo), i[0] = Vo.x, i[4] = Go.x, i[8] = Wo.x, i[1] = Vo.y, i[5] = Go.y, i[9] = Wo.y, i[2] = Vo.z, i[6] = Go.z, i[10] = Wo.z, this
            }

            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            }

            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }

            multiplyMatrices(t, e) {
                const n = t.elements, i = e.elements, r = this.elements, o = n[0], s = n[4], a = n[8], l = n[12],
                    c = n[1], u = n[5], h = n[9], d = n[13], p = n[2], f = n[6], m = n[10], g = n[14], v = n[3],
                    y = n[7], x = n[11], _ = n[15], b = i[0], w = i[4], S = i[8], M = i[12], T = i[1], E = i[5],
                    A = i[9], P = i[13], L = i[2], C = i[6], R = i[10], I = i[14], O = i[3], D = i[7], z = i[11],
                    k = i[15];
                return r[0] = o * b + s * T + a * L + l * O, r[4] = o * w + s * E + a * C + l * D, r[8] = o * S + s * A + a * R + l * z, r[12] = o * M + s * P + a * I + l * k, r[1] = c * b + u * T + h * L + d * O, r[5] = c * w + u * E + h * C + d * D, r[9] = c * S + u * A + h * R + d * z, r[13] = c * M + u * P + h * I + d * k, r[2] = p * b + f * T + m * L + g * O, r[6] = p * w + f * E + m * C + g * D, r[10] = p * S + f * A + m * R + g * z, r[14] = p * M + f * P + m * I + g * k, r[3] = v * b + y * T + x * L + _ * O, r[7] = v * w + y * E + x * C + _ * D, r[11] = v * S + y * A + x * R + _ * z, r[15] = v * M + y * P + x * I + _ * k, this
            }

            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
            }

            determinant() {
                const t = this.elements, e = t[0], n = t[4], i = t[8], r = t[12], o = t[1], s = t[5], a = t[9],
                    l = t[13], c = t[2], u = t[6], h = t[10], d = t[14];
                return t[3] * (+r * a * u - i * l * u - r * s * h + n * l * h + i * s * d - n * a * d) + t[7] * (+e * a * d - e * l * h + r * o * h - i * o * d + i * l * c - r * a * c) + t[11] * (+e * l * u - e * s * d - r * o * u + n * o * d + r * s * c - n * l * c) + t[15] * (-i * s * c - e * a * u + e * s * h + i * o * u - n * o * h + n * a * c)
            }

            transpose() {
                const t = this.elements;
                let e;
                return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
            }

            setPosition(t, e, n) {
                const i = this.elements;
                return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
            }

            invert() {
                const t = this.elements, e = t[0], n = t[1], i = t[2], r = t[3], o = t[4], s = t[5], a = t[6], l = t[7],
                    c = t[8], u = t[9], h = t[10], d = t[11], p = t[12], f = t[13], m = t[14], g = t[15],
                    v = u * m * l - f * h * l + f * a * d - s * m * d - u * a * g + s * h * g,
                    y = p * h * l - c * m * l - p * a * d + o * m * d + c * a * g - o * h * g,
                    x = c * f * l - p * u * l + p * s * d - o * f * d - c * s * g + o * u * g,
                    _ = p * u * a - c * f * a - p * s * h + o * f * h + c * s * m - o * u * m,
                    b = e * v + n * y + i * x + r * _;
                if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const w = 1 / b;
                return t[0] = v * w, t[1] = (f * h * r - u * m * r - f * i * d + n * m * d + u * i * g - n * h * g) * w, t[2] = (s * m * r - f * a * r + f * i * l - n * m * l - s * i * g + n * a * g) * w, t[3] = (u * a * r - s * h * r - u * i * l + n * h * l + s * i * d - n * a * d) * w, t[4] = y * w, t[5] = (c * m * r - p * h * r + p * i * d - e * m * d - c * i * g + e * h * g) * w, t[6] = (p * a * r - o * m * r - p * i * l + e * m * l + o * i * g - e * a * g) * w, t[7] = (o * h * r - c * a * r + c * i * l - e * h * l - o * i * d + e * a * d) * w, t[8] = x * w, t[9] = (p * u * r - c * f * r - p * n * d + e * f * d + c * n * g - e * u * g) * w, t[10] = (o * f * r - p * s * r + p * n * l - e * f * l - o * n * g + e * s * g) * w, t[11] = (c * s * r - o * u * r - c * n * l + e * u * l + o * n * d - e * s * d) * w, t[12] = _ * w, t[13] = (c * f * i - p * u * i + p * n * h - e * f * h - c * n * m + e * u * m) * w, t[14] = (p * s * i - o * f * i - p * n * a + e * f * a + o * n * m - e * s * m) * w, t[15] = (o * u * i - c * s * i + c * n * a - e * u * a - o * n * h + e * s * h) * w, this
            }

            scale(t) {
                const e = this.elements, n = t.x, i = t.y, r = t.z;
                return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
            }

            getMaxScaleOnAxis() {
                const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                    n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, i))
            }

            makeTranslation(t, e, n) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
            }

            makeRotationX(t) {
                const e = Math.cos(t), n = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
            }

            makeRotationY(t) {
                const e = Math.cos(t), n = Math.sin(t);
                return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
            }

            makeRotationZ(t) {
                const e = Math.cos(t), n = Math.sin(t);
                return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }

            makeRotationAxis(t, e) {
                const n = Math.cos(e), i = Math.sin(e), r = 1 - n, o = t.x, s = t.y, a = t.z, l = r * o, c = r * s;
                return this.set(l * o + n, l * s - i * a, l * a + i * s, 0, l * s + i * a, c * s + n, c * a - i * o, 0, l * a - i * s, c * a + i * o, r * a * a + n, 0, 0, 0, 0, 1), this
            }

            makeScale(t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            }

            makeShear(t, e, n, i, r, o) {
                return this.set(1, n, r, 0, t, 1, o, 0, e, i, 1, 0, 0, 0, 0, 1), this
            }

            compose(t, e, n) {
                const i = this.elements, r = e._x, o = e._y, s = e._z, a = e._w, l = r + r, c = o + o, u = s + s,
                    h = r * l, d = r * c, p = r * u, f = o * c, m = o * u, g = s * u, v = a * l, y = a * c, x = a * u,
                    _ = n.x, b = n.y, w = n.z;
                return i[0] = (1 - (f + g)) * _, i[1] = (d + x) * _, i[2] = (p - y) * _, i[3] = 0, i[4] = (d - x) * b, i[5] = (1 - (h + g)) * b, i[6] = (m + v) * b, i[7] = 0, i[8] = (p + y) * w, i[9] = (m - v) * w, i[10] = (1 - (h + f)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
            }

            decompose(t, e, n) {
                const i = this.elements;
                let r = Bo.set(i[0], i[1], i[2]).length();
                const o = Bo.set(i[4], i[5], i[6]).length(), s = Bo.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], Fo.copy(this);
                const a = 1 / r, l = 1 / o, c = 1 / s;
                return Fo.elements[0] *= a, Fo.elements[1] *= a, Fo.elements[2] *= a, Fo.elements[4] *= l, Fo.elements[5] *= l, Fo.elements[6] *= l, Fo.elements[8] *= c, Fo.elements[9] *= c, Fo.elements[10] *= c, e.setFromRotationMatrix(Fo), n.x = r, n.y = o, n.z = s, this
            }

            makePerspective(t, e, n, i, r, o) {
                void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                const s = this.elements, a = 2 * r / (e - t), l = 2 * r / (n - i), c = (e + t) / (e - t),
                    u = (n + i) / (n - i), h = -(o + r) / (o - r), d = -2 * o * r / (o - r);
                return s[0] = a, s[4] = 0, s[8] = c, s[12] = 0, s[1] = 0, s[5] = l, s[9] = u, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = h, s[14] = d, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
            }

            makeOrthographic(t, e, n, i, r, o) {
                const s = this.elements, a = 1 / (e - t), l = 1 / (n - i), c = 1 / (o - r), u = (e + t) * a,
                    h = (n + i) * l, d = (o + r) * c;
                return s[0] = 2 * a, s[4] = 0, s[8] = 0, s[12] = -u, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -h, s[2] = 0, s[6] = 0, s[10] = -2 * c, s[14] = -d, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
            }

            equals(t) {
                const e = this.elements, n = t.elements;
                for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
                return !0
            }

            fromArray(t, e = 0) {
                for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
                return this
            }

            toArray(t = [], e = 0) {
                const n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
            }
        }

        No.prototype.isMatrix4 = !0;
        const Bo = new oo, Fo = new No, Uo = new oo(0, 0, 0), Ho = new oo(1, 1, 1), Vo = new oo, Go = new oo,
            Wo = new oo, jo = new No, qo = new ro;

        class Xo {
            constructor(t = 0, e = 0, n = 0, i = Xo.DefaultOrder) {
                this._x = t, this._y = e, this._z = n, this._order = i
            }

            get x() {
                return this._x
            }

            set x(t) {
                this._x = t, this._onChangeCallback()
            }

            get y() {
                return this._y
            }

            set y(t) {
                this._y = t, this._onChangeCallback()
            }

            get z() {
                return this._z
            }

            set z(t) {
                this._z = t, this._onChangeCallback()
            }

            get order() {
                return this._order
            }

            set order(t) {
                this._order = t, this._onChangeCallback()
            }

            set(t, e, n, i = this._order) {
                return this._x = t, this._y = e, this._z = n, this._order = i, this._onChangeCallback(), this
            }

            clone() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            }

            copy(t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
            }

            setFromRotationMatrix(t, e = this._order, n = !0) {
                const i = t.elements, r = i[0], o = i[4], s = i[8], a = i[1], l = i[5], c = i[9], u = i[2], h = i[6],
                    d = i[10];
                switch (e) {
                    case"XYZ":
                        this._y = Math.asin(Ur(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(h, l), this._z = 0);
                        break;
                    case"YXZ":
                        this._x = Math.asin(-Ur(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-u, r), this._z = 0);
                        break;
                    case"ZXY":
                        this._x = Math.asin(Ur(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(a, r));
                        break;
                    case"ZYX":
                        this._y = Math.asin(-Ur(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(a, r)) : (this._x = 0, this._z = Math.atan2(-o, l));
                        break;
                    case"YZX":
                        this._z = Math.asin(Ur(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(s, d));
                        break;
                    case"XZY":
                        this._z = Math.asin(-Ur(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(h, l), this._y = Math.atan2(s, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
                        break;
                    default:
                        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                }
                return this._order = e, !0 === n && this._onChangeCallback(), this
            }

            setFromQuaternion(t, e, n) {
                return jo.makeRotationFromQuaternion(t), this.setFromRotationMatrix(jo, e, n)
            }

            setFromVector3(t, e = this._order) {
                return this.set(t.x, t.y, t.z, e)
            }

            reorder(t) {
                return qo.setFromEuler(this), this.setFromQuaternion(qo, t)
            }

            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }

            fromArray(t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
            }

            toArray(t = [], e = 0) {
                return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            }

            toVector3(t) {
                return t ? t.set(this._x, this._y, this._z) : new oo(this._x, this._y, this._z)
            }

            _onChange(t) {
                return this._onChangeCallback = t, this
            }

            _onChangeCallback() {
            }
        }

        Xo.prototype.isEuler = !0, Xo.DefaultOrder = "XYZ", Xo.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];

        class Yo {
            constructor() {
                this.mask = 1
            }

            set(t) {
                this.mask = (1 << t | 0) >>> 0
            }

            enable(t) {
                this.mask |= 1 << t | 0
            }

            enableAll() {
                this.mask = -1
            }

            toggle(t) {
                this.mask ^= 1 << t | 0
            }

            disable(t) {
                this.mask &= ~(1 << t | 0)
            }

            disableAll() {
                this.mask = 0
            }

            test(t) {
                return 0 != (this.mask & t.mask)
            }

            isEnabled(t) {
                return 0 != (this.mask & (1 << t | 0))
            }
        }

        let Jo = 0;
        const Zo = new oo, Qo = new ro, Ko = new No, $o = new oo, ts = new oo, es = new oo, ns = new ro,
            is = new oo(1, 0, 0), rs = new oo(0, 1, 0), os = new oo(0, 0, 1), ss = {type: "added"},
            as = {type: "removed"};

        class ls extends zr {
            constructor() {
                super(), Object.defineProperty(this, "id", {value: Jo++}), this.uuid = Fr(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ls.DefaultUp.clone();
                const t = new oo, e = new Xo, n = new ro, i = new oo(1, 1, 1);
                e._onChange((function () {
                    n.setFromEuler(e, !1)
                })), n._onChange((function () {
                    e.setFromQuaternion(n, void 0, !1)
                })), Object.defineProperties(this, {
                    position: {configurable: !0, enumerable: !0, value: t},
                    rotation: {configurable: !0, enumerable: !0, value: e},
                    quaternion: {configurable: !0, enumerable: !0, value: n},
                    scale: {configurable: !0, enumerable: !0, value: i},
                    modelViewMatrix: {value: new No},
                    normalMatrix: {value: new qr}
                }), this.matrix = new No, this.matrixWorld = new No, this.matrixAutoUpdate = ls.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Yo, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
            }

            onBeforeRender() {
            }

            onAfterRender() {
            }

            applyMatrix4(t) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
            }

            applyQuaternion(t) {
                return this.quaternion.premultiply(t), this
            }

            setRotationFromAxisAngle(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            }

            setRotationFromEuler(t) {
                this.quaternion.setFromEuler(t, !0)
            }

            setRotationFromMatrix(t) {
                this.quaternion.setFromRotationMatrix(t)
            }

            setRotationFromQuaternion(t) {
                this.quaternion.copy(t)
            }

            rotateOnAxis(t, e) {
                return Qo.setFromAxisAngle(t, e), this.quaternion.multiply(Qo), this
            }

            rotateOnWorldAxis(t, e) {
                return Qo.setFromAxisAngle(t, e), this.quaternion.premultiply(Qo), this
            }

            rotateX(t) {
                return this.rotateOnAxis(is, t)
            }

            rotateY(t) {
                return this.rotateOnAxis(rs, t)
            }

            rotateZ(t) {
                return this.rotateOnAxis(os, t)
            }

            translateOnAxis(t, e) {
                return Zo.copy(t).applyQuaternion(this.quaternion), this.position.add(Zo.multiplyScalar(e)), this
            }

            translateX(t) {
                return this.translateOnAxis(is, t)
            }

            translateY(t) {
                return this.translateOnAxis(rs, t)
            }

            translateZ(t) {
                return this.translateOnAxis(os, t)
            }

            localToWorld(t) {
                return t.applyMatrix4(this.matrixWorld)
            }

            worldToLocal(t) {
                return t.applyMatrix4(Ko.copy(this.matrixWorld).invert())
            }

            lookAt(t, e, n) {
                t.isVector3 ? $o.copy(t) : $o.set(t, e, n);
                const i = this.parent;
                this.updateWorldMatrix(!0, !1), ts.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ko.lookAt(ts, $o, this.up) : Ko.lookAt($o, ts, this.up), this.quaternion.setFromRotationMatrix(Ko), i && (Ko.extractRotation(i.matrixWorld), Qo.setFromRotationMatrix(Ko), this.quaternion.premultiply(Qo.invert()))
            }

            add(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(ss)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
            }

            remove(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                    return this
                }
                const e = this.children.indexOf(t);
                return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(as)), this
            }

            removeFromParent() {
                const t = this.parent;
                return null !== t && t.remove(this), this
            }

            clear() {
                for (let t = 0; t < this.children.length; t++) {
                    const e = this.children[t];
                    e.parent = null, e.dispatchEvent(as)
                }
                return this.children.length = 0, this
            }

            attach(t) {
                return this.updateWorldMatrix(!0, !1), Ko.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Ko.multiply(t.parent.matrixWorld)), t.applyMatrix4(Ko), this.add(t), t.updateWorldMatrix(!1, !0), this
            }

            getObjectById(t) {
                return this.getObjectByProperty("id", t)
            }

            getObjectByName(t) {
                return this.getObjectByProperty("name", t)
            }

            getObjectByProperty(t, e) {
                if (this[t] === e) return this;
                for (let n = 0, i = this.children.length; n < i; n++) {
                    const i = this.children[n].getObjectByProperty(t, e);
                    if (void 0 !== i) return i
                }
            }

            getWorldPosition(t) {
                return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
            }

            getWorldQuaternion(t) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ts, t, es), t
            }

            getWorldScale(t) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ts, ns, t), t
            }

            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            }

            raycast() {
            }

            traverse(t) {
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t)
            }

            traverseVisible(t) {
                if (!1 === this.visible) return;
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
            }

            traverseAncestors(t) {
                const e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            }

            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            }

            updateMatrixWorld(t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
            }

            updateWorldMatrix(t, e) {
                const n = this.parent;
                if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                    const t = this.children;
                    for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0)
                }
            }

            toJSON(t) {
                const e = void 0 === t || "string" == typeof t, n = {};
                e && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {}
                }, n.metadata = {version: 4.5, type: "Object", generator: "Object3D.toJSON"});
                const i = {};

                function r(e, n) {
                    return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                }

                if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && (i.environment = this.environment.toJSON(t).uuid); else if (this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(t.geometries, this.geometry);
                    const e = this.geometry.parameters;
                    if (void 0 !== e && void 0 !== e.shapes) {
                        const n = e.shapes;
                        if (Array.isArray(n)) for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e];
                            r(t.shapes, i)
                        } else r(t.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) {
                    const e = [];
                    for (let n = 0, i = this.material.length; n < i; n++) e.push(r(t.materials, this.material[n]));
                    i.material = e
                } else i.material = r(t.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object)
                }
                if (this.animations.length > 0) {
                    i.animations = [];
                    for (let e = 0; e < this.animations.length; e++) {
                        const n = this.animations[e];
                        i.animations.push(r(t.animations, n))
                    }
                }
                if (e) {
                    const e = o(t.geometries), i = o(t.materials), r = o(t.textures), s = o(t.images), a = o(t.shapes),
                        l = o(t.skeletons), c = o(t.animations);
                    e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c)
                }
                return n.object = i, n;

                function o(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata, e.push(i)
                    }
                    return e
                }
            }

            clone(t) {
                return (new this.constructor).copy(this, t)
            }

            copy(t, e = !0) {
                if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (let e = 0; e < t.children.length; e++) {
                    const n = t.children[e];
                    this.add(n.clone())
                }
                return this
            }
        }

        ls.DefaultUp = new oo(0, 1, 0), ls.DefaultMatrixAutoUpdate = !0, ls.prototype.isObject3D = !0;
        const cs = new oo, us = new oo, hs = new oo, ds = new oo, ps = new oo, fs = new oo, ms = new oo, gs = new oo,
            vs = new oo, ys = new oo;

        class xs {
            constructor(t = new oo, e = new oo, n = new oo) {
                this.a = t, this.b = e, this.c = n
            }

            static getNormal(t, e, n, i) {
                i.subVectors(n, e), cs.subVectors(t, e), i.cross(cs);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            }

            static getBarycoord(t, e, n, i, r) {
                cs.subVectors(i, e), us.subVectors(n, e), hs.subVectors(t, e);
                const o = cs.dot(cs), s = cs.dot(us), a = cs.dot(hs), l = us.dot(us), c = us.dot(hs), u = o * l - s * s;
                if (0 === u) return r.set(-2, -1, -1);
                const h = 1 / u, d = (l * a - s * c) * h, p = (o * c - s * a) * h;
                return r.set(1 - d - p, p, d)
            }

            static containsPoint(t, e, n, i) {
                return this.getBarycoord(t, e, n, i, ds), ds.x >= 0 && ds.y >= 0 && ds.x + ds.y <= 1
            }

            static getUV(t, e, n, i, r, o, s, a) {
                return this.getBarycoord(t, e, n, i, ds), a.set(0, 0), a.addScaledVector(r, ds.x), a.addScaledVector(o, ds.y), a.addScaledVector(s, ds.z), a
            }

            static isFrontFacing(t, e, n, i) {
                return cs.subVectors(n, e), us.subVectors(t, e), cs.cross(us).dot(i) < 0
            }

            set(t, e, n) {
                return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
            }

            setFromPointsAndIndices(t, e, n, i) {
                return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
            }

            setFromAttributeAndIndices(t, e, n, i) {
                return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, i), this
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            copy(t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            }

            getArea() {
                return cs.subVectors(this.c, this.b), us.subVectors(this.a, this.b), .5 * cs.cross(us).length()
            }

            getMidpoint(t) {
                return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }

            getNormal(t) {
                return xs.getNormal(this.a, this.b, this.c, t)
            }

            getPlane(t) {
                return t.setFromCoplanarPoints(this.a, this.b, this.c)
            }

            getBarycoord(t, e) {
                return xs.getBarycoord(t, this.a, this.b, this.c, e)
            }

            getUV(t, e, n, i, r) {
                return xs.getUV(t, this.a, this.b, this.c, e, n, i, r)
            }

            containsPoint(t) {
                return xs.containsPoint(t, this.a, this.b, this.c)
            }

            isFrontFacing(t) {
                return xs.isFrontFacing(this.a, this.b, this.c, t)
            }

            intersectsBox(t) {
                return t.intersectsTriangle(this)
            }

            closestPointToPoint(t, e) {
                const n = this.a, i = this.b, r = this.c;
                let o, s;
                ps.subVectors(i, n), fs.subVectors(r, n), gs.subVectors(t, n);
                const a = ps.dot(gs), l = fs.dot(gs);
                if (a <= 0 && l <= 0) return e.copy(n);
                vs.subVectors(t, i);
                const c = ps.dot(vs), u = fs.dot(vs);
                if (c >= 0 && u <= c) return e.copy(i);
                const h = a * u - c * l;
                if (h <= 0 && a >= 0 && c <= 0) return o = a / (a - c), e.copy(n).addScaledVector(ps, o);
                ys.subVectors(t, r);
                const d = ps.dot(ys), p = fs.dot(ys);
                if (p >= 0 && d <= p) return e.copy(r);
                const f = d * l - a * p;
                if (f <= 0 && l >= 0 && p <= 0) return s = l / (l - p), e.copy(n).addScaledVector(fs, s);
                const m = c * p - d * u;
                if (m <= 0 && u - c >= 0 && d - p >= 0) return ms.subVectors(r, i), s = (u - c) / (u - c + (d - p)), e.copy(i).addScaledVector(ms, s);
                const g = 1 / (m + f + h);
                return o = f * g, s = h * g, e.copy(n).addScaledVector(ps, o).addScaledVector(fs, s)
            }

            equals(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }

        let _s = 0;

        class bs extends zr {
            constructor() {
                super(), Object.defineProperty(this, "id", {value: _s++}), this.uuid = Fr(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.format = vr, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = Ji, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Rr, this.stencilZFail = Rr, this.stencilZPass = Rr, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
            }

            get alphaTest() {
                return this._alphaTest
            }

            set alphaTest(t) {
                this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
            }

            onBuild() {
            }

            onBeforeRender() {
            }

            onBeforeCompile() {
            }

            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }

            setValues(t) {
                if (void 0 !== t) for (const e in t) {
                    const n = t[e];
                    if (void 0 === n) {
                        console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                        continue
                    }
                    if ("shading" === e) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                        continue
                    }
                    const i = this[e];
                    void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                }
            }

            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                e && (t = {textures: {}, images: {}});
                const n = {metadata: {version: 4.5, type: "Material", generator: "Material.toJSON"}};

                function i(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata, e.push(i)
                    }
                    return e
                }

                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.format !== vr && (n.format = this.format), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                    const e = i(t.textures), r = i(t.images);
                    e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
                }
                return n
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            copy(t) {
                this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.format = t.format, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                const e = t.clippingPlanes;
                let n = null;
                if (null !== e) {
                    const t = e.length;
                    n = new Array(t);
                    for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
                }
                return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
            }

            dispose() {
                this.dispatchEvent({type: "dispose"})
            }

            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }

        bs.prototype.isMaterial = !0;
        const ws = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        }, Ss = {h: 0, s: 0, l: 0}, Ms = {h: 0, s: 0, l: 0};

        function Ts(t, e, n) {
            return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
        }

        function Es(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }

        function As(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }

        class Ps {
            constructor(t, e, n) {
                return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
            }

            set(t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
            }

            setScalar(t) {
                return this.r = t, this.g = t, this.b = t, this
            }

            setHex(t) {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
            }

            setRGB(t, e, n) {
                return this.r = t, this.g = e, this.b = n, this
            }

            setHSL(t, e, n) {
                if (t = Hr(t, 1), e = Ur(e, 0, 1), n = Ur(n, 0, 1), 0 === e) this.r = this.g = this.b = n; else {
                    const i = n <= .5 ? n * (1 + e) : n + e - n * e, r = 2 * n - i;
                    this.r = Ts(r, i, t + 1 / 3), this.g = Ts(r, i, t), this.b = Ts(r, i, t - 1 / 3)
                }
                return this
            }

            setStyle(t) {
                function e(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }

                let n;
                if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                    let t;
                    const i = n[1], r = n[2];
                    switch (i) {
                        case"rgb":
                        case"rgba":
                            if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[4]), this;
                            if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[4]), this;
                            break;
                        case"hsl":
                        case"hsla":
                            if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                                const n = parseFloat(t[1]) / 360, i = parseInt(t[2], 10) / 100,
                                    r = parseInt(t[3], 10) / 100;
                                return e(t[4]), this.setHSL(n, i, r)
                            }
                    }
                } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                    const t = n[1], e = t.length;
                    if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                    if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                }
                return t && t.length > 0 ? this.setColorName(t) : this
            }

            setColorName(t) {
                const e = ws[t.toLowerCase()];
                return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
            }

            clone() {
                return new this.constructor(this.r, this.g, this.b)
            }

            copy(t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            }

            copyGammaToLinear(t, e = 2) {
                return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
            }

            copyLinearToGamma(t, e = 2) {
                const n = e > 0 ? 1 / e : 1;
                return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
            }

            convertGammaToLinear(t) {
                return this.copyGammaToLinear(this, t), this
            }

            convertLinearToGamma(t) {
                return this.copyLinearToGamma(this, t), this
            }

            copySRGBToLinear(t) {
                return this.r = Es(t.r), this.g = Es(t.g), this.b = Es(t.b), this
            }

            copyLinearToSRGB(t) {
                return this.r = As(t.r), this.g = As(t.g), this.b = As(t.b), this
            }

            convertSRGBToLinear() {
                return this.copySRGBToLinear(this), this
            }

            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this), this
            }

            getHex() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            }

            getHexString() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            }

            getHSL(t) {
                const e = this.r, n = this.g, i = this.b, r = Math.max(e, n, i), o = Math.min(e, n, i);
                let s, a;
                const l = (o + r) / 2;
                if (o === r) s = 0, a = 0; else {
                    const t = r - o;
                    switch (a = l <= .5 ? t / (r + o) : t / (2 - r - o), r) {
                        case e:
                            s = (n - i) / t + (n < i ? 6 : 0);
                            break;
                        case n:
                            s = (i - e) / t + 2;
                            break;
                        case i:
                            s = (e - n) / t + 4
                    }
                    s /= 6
                }
                return t.h = s, t.s = a, t.l = l, t
            }

            getStyle() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            }

            offsetHSL(t, e, n) {
                return this.getHSL(Ss), Ss.h += t, Ss.s += e, Ss.l += n, this.setHSL(Ss.h, Ss.s, Ss.l), this
            }

            add(t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            }

            addColors(t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            }

            addScalar(t) {
                return this.r += t, this.g += t, this.b += t, this
            }

            sub(t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            }

            multiply(t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            }

            multiplyScalar(t) {
                return this.r *= t, this.g *= t, this.b *= t, this
            }

            lerp(t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            }

            lerpColors(t, e, n) {
                return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
            }

            lerpHSL(t, e) {
                this.getHSL(Ss), t.getHSL(Ms);
                const n = Vr(Ss.h, Ms.h, e), i = Vr(Ss.s, Ms.s, e), r = Vr(Ss.l, Ms.l, e);
                return this.setHSL(n, i, r), this
            }

            equals(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }

            fromArray(t, e = 0) {
                return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            }

            toArray(t = [], e = 0) {
                return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            }

            fromBufferAttribute(t, e) {
                return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
            }

            toJSON() {
                return this.getHex()
            }
        }

        Ps.NAMES = ws, Ps.prototype.isColor = !0, Ps.prototype.r = 1, Ps.prototype.g = 1, Ps.prototype.b = 1;

        class Ls extends bs {
            constructor(t) {
                super(), this.type = "MeshBasicMaterial", this.color = new Ps(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
            }

            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
            }
        }

        Ls.prototype.isMeshBasicMaterial = !0;
        const Cs = new oo, Rs = new jr;

        class Is {
            constructor(t, e, n) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = Ir, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            onUploadCallback() {
            }

            set needsUpdate(t) {
                !0 === t && this.version++
            }

            setUsage(t) {
                return this.usage = t, this
            }

            copy(t) {
                return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
            }

            copyAt(t, e, n) {
                t *= this.itemSize, n *= e.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
                return this
            }

            copyArray(t) {
                return this.array.set(t), this
            }

            copyColorsArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new Ps), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
                }
                return this
            }

            copyVector2sArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new jr), e[n++] = r.x, e[n++] = r.y
                }
                return this
            }

            copyVector3sArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new oo), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
                }
                return this
            }

            copyVector4sArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new eo), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
                }
                return this
            }

            applyMatrix3(t) {
                if (2 === this.itemSize) for (let e = 0, n = this.count; e < n; e++) Rs.fromBufferAttribute(this, e), Rs.applyMatrix3(t), this.setXY(e, Rs.x, Rs.y); else if (3 === this.itemSize) for (let e = 0, n = this.count; e < n; e++) Cs.fromBufferAttribute(this, e), Cs.applyMatrix3(t), this.setXYZ(e, Cs.x, Cs.y, Cs.z);
                return this
            }

            applyMatrix4(t) {
                for (let e = 0, n = this.count; e < n; e++) Cs.x = this.getX(e), Cs.y = this.getY(e), Cs.z = this.getZ(e), Cs.applyMatrix4(t), this.setXYZ(e, Cs.x, Cs.y, Cs.z);
                return this
            }

            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++) Cs.x = this.getX(e), Cs.y = this.getY(e), Cs.z = this.getZ(e), Cs.applyNormalMatrix(t), this.setXYZ(e, Cs.x, Cs.y, Cs.z);
                return this
            }

            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++) Cs.x = this.getX(e), Cs.y = this.getY(e), Cs.z = this.getZ(e), Cs.transformDirection(t), this.setXYZ(e, Cs.x, Cs.y, Cs.z);
                return this
            }

            set(t, e = 0) {
                return this.array.set(t, e), this
            }

            getX(t) {
                return this.array[t * this.itemSize]
            }

            setX(t, e) {
                return this.array[t * this.itemSize] = e, this
            }

            getY(t) {
                return this.array[t * this.itemSize + 1]
            }

            setY(t, e) {
                return this.array[t * this.itemSize + 1] = e, this
            }

            getZ(t) {
                return this.array[t * this.itemSize + 2]
            }

            setZ(t, e) {
                return this.array[t * this.itemSize + 2] = e, this
            }

            getW(t) {
                return this.array[t * this.itemSize + 3]
            }

            setW(t, e) {
                return this.array[t * this.itemSize + 3] = e, this
            }

            setXY(t, e, n) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
            }

            setXYZ(t, e, n, i) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
            }

            setXYZW(t, e, n, i, r) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
            }

            onUpload(t) {
                return this.onUploadCallback = t, this
            }

            clone() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }

            toJSON() {
                const t = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (t.name = this.name), this.usage !== Ir && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
            }
        }

        Is.prototype.isBufferAttribute = !0;

        class Os extends Is {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }

        class Ds extends Is {
            constructor(t, e, n) {
                super(new Uint32Array(t), e, n)
            }
        }

        (class extends Is {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }).prototype.isFloat16BufferAttribute = !0;

        class zs extends Is {
            constructor(t, e, n) {
                super(new Float32Array(t), e, n)
            }
        }

        let ks = 0;
        const Ns = new No, Bs = new ls, Fs = new oo, Us = new lo, Hs = new lo, Vs = new oo;

        class Gs extends zr {
            constructor() {
                super(), Object.defineProperty(this, "id", {value: ks++}), this.uuid = Fr(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }

            getIndex() {
                return this.index
            }

            setIndex(t) {
                return Array.isArray(t) ? this.index = new (Xr(t) > 65535 ? Ds : Os)(t, 1) : this.index = t, this
            }

            getAttribute(t) {
                return this.attributes[t]
            }

            setAttribute(t, e) {
                return this.attributes[t] = e, this
            }

            deleteAttribute(t) {
                return delete this.attributes[t], this
            }

            hasAttribute(t) {
                return void 0 !== this.attributes[t]
            }

            addGroup(t, e, n = 0) {
                this.groups.push({start: t, count: e, materialIndex: n})
            }

            clearGroups() {
                this.groups = []
            }

            setDrawRange(t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            }

            applyMatrix4(t) {
                const e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const e = (new qr).getNormalMatrix(t);
                    n.applyNormalMatrix(e), n.needsUpdate = !0
                }
                const i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            }

            applyQuaternion(t) {
                return Ns.makeRotationFromQuaternion(t), this.applyMatrix4(Ns), this
            }

            rotateX(t) {
                return Ns.makeRotationX(t), this.applyMatrix4(Ns), this
            }

            rotateY(t) {
                return Ns.makeRotationY(t), this.applyMatrix4(Ns), this
            }

            rotateZ(t) {
                return Ns.makeRotationZ(t), this.applyMatrix4(Ns), this
            }

            translate(t, e, n) {
                return Ns.makeTranslation(t, e, n), this.applyMatrix4(Ns), this
            }

            scale(t, e, n) {
                return Ns.makeScale(t, e, n), this.applyMatrix4(Ns), this
            }

            lookAt(t) {
                return Bs.lookAt(t), Bs.updateMatrix(), this.applyMatrix4(Bs.matrix), this
            }

            center() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(Fs).negate(), this.translate(Fs.x, Fs.y, Fs.z), this
            }

            setFromPoints(t) {
                const e = [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    e.push(i.x, i.y, i.z || 0)
                }
                return this.setAttribute("position", new zs(e, 3)), this
            }

            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new lo);
                const t = this.attributes.position, e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new oo(-1 / 0, -1 / 0, -1 / 0), new oo(1 / 0, 1 / 0, 1 / 0));
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t), e) for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        Us.setFromBufferAttribute(n), this.morphTargetsRelative ? (Vs.addVectors(this.boundingBox.min, Us.min), this.boundingBox.expandByPoint(Vs), Vs.addVectors(this.boundingBox.max, Us.max), this.boundingBox.expandByPoint(Vs)) : (this.boundingBox.expandByPoint(Us.min), this.boundingBox.expandByPoint(Us.max))
                    }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }

            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new Po);
                const t = this.attributes.position, e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new oo, 1 / 0);
                if (t) {
                    const n = this.boundingSphere.center;
                    if (Us.setFromBufferAttribute(t), e) for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        Hs.setFromBufferAttribute(n), this.morphTargetsRelative ? (Vs.addVectors(Us.min, Hs.min), Us.expandByPoint(Vs), Vs.addVectors(Us.max, Hs.max), Us.expandByPoint(Vs)) : (Us.expandByPoint(Hs.min), Us.expandByPoint(Hs.max))
                    }
                    Us.getCenter(n);
                    let i = 0;
                    for (let e = 0, r = t.count; e < r; e++) Vs.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(Vs));
                    if (e) for (let r = 0, o = e.length; r < o; r++) {
                        const o = e[r], s = this.morphTargetsRelative;
                        for (let e = 0, r = o.count; e < r; e++) Vs.fromBufferAttribute(o, e), s && (Fs.fromBufferAttribute(t, e), Vs.add(Fs)), i = Math.max(i, n.distanceToSquared(Vs))
                    }
                    this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }

            computeTangents() {
                const t = this.index, e = this.attributes;
                if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = t.array, i = e.position.array, r = e.normal.array, o = e.uv.array, s = i.length / 3;
                void 0 === e.tangent && this.setAttribute("tangent", new Is(new Float32Array(4 * s), 4));
                const a = e.tangent.array, l = [], c = [];
                for (let t = 0; t < s; t++) l[t] = new oo, c[t] = new oo;
                const u = new oo, h = new oo, d = new oo, p = new jr, f = new jr, m = new jr, g = new oo, v = new oo;

                function y(t, e, n) {
                    u.fromArray(i, 3 * t), h.fromArray(i, 3 * e), d.fromArray(i, 3 * n), p.fromArray(o, 2 * t), f.fromArray(o, 2 * e), m.fromArray(o, 2 * n), h.sub(u), d.sub(u), f.sub(p), m.sub(p);
                    const r = 1 / (f.x * m.y - m.x * f.y);
                    isFinite(r) && (g.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r), v.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(v), c[e].add(v), c[n].add(v))
                }

                let x = this.groups;
                0 === x.length && (x = [{start: 0, count: n.length}]);
                for (let t = 0, e = x.length; t < e; ++t) {
                    const e = x[t], i = e.start;
                    for (let t = i, r = i + e.count; t < r; t += 3) y(n[t + 0], n[t + 1], n[t + 2])
                }
                const _ = new oo, b = new oo, w = new oo, S = new oo;

                function M(t) {
                    w.fromArray(r, 3 * t), S.copy(w);
                    const e = l[t];
                    _.copy(e), _.sub(w.multiplyScalar(w.dot(e))).normalize(), b.crossVectors(S, e);
                    const n = b.dot(c[t]) < 0 ? -1 : 1;
                    a[4 * t] = _.x, a[4 * t + 1] = _.y, a[4 * t + 2] = _.z, a[4 * t + 3] = n
                }

                for (let t = 0, e = x.length; t < e; ++t) {
                    const e = x[t], i = e.start;
                    for (let t = i, r = i + e.count; t < r; t += 3) M(n[t + 0]), M(n[t + 1]), M(n[t + 2])
                }
            }

            computeVertexNormals() {
                const t = this.index, e = this.getAttribute("position");
                if (void 0 !== e) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n) n = new Is(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n); else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                    const i = new oo, r = new oo, o = new oo, s = new oo, a = new oo, l = new oo, c = new oo,
                        u = new oo;
                    if (t) for (let h = 0, d = t.count; h < d; h += 3) {
                        const d = t.getX(h + 0), p = t.getX(h + 1), f = t.getX(h + 2);
                        i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), o.fromBufferAttribute(e, f), c.subVectors(o, r), u.subVectors(i, r), c.cross(u), s.fromBufferAttribute(n, d), a.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), s.add(c), a.add(c), l.add(c), n.setXYZ(d, s.x, s.y, s.z), n.setXYZ(p, a.x, a.y, a.z), n.setXYZ(f, l.x, l.y, l.z)
                    } else for (let t = 0, s = e.count; t < s; t += 3) i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), o.fromBufferAttribute(e, t + 2), c.subVectors(o, r), u.subVectors(i, r), c.cross(u), n.setXYZ(t + 0, c.x, c.y, c.z), n.setXYZ(t + 1, c.x, c.y, c.z), n.setXYZ(t + 2, c.x, c.y, c.z);
                    this.normalizeNormals(), n.needsUpdate = !0
                }
            }

            merge(t, e) {
                if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                const n = this.attributes;
                for (const i in n) {
                    if (void 0 === t.attributes[i]) continue;
                    const r = n[i].array, o = t.attributes[i], s = o.array, a = o.itemSize * e,
                        l = Math.min(s.length, r.length - a);
                    for (let t = 0, e = a; t < l; t++, e++) r[e] = s[t]
                }
                return this
            }

            normalizeNormals() {
                const t = this.attributes.normal;
                for (let e = 0, n = t.count; e < n; e++) Vs.fromBufferAttribute(t, e), Vs.normalize(), t.setXYZ(e, Vs.x, Vs.y, Vs.z)
            }

            toNonIndexed() {
                function t(t, e) {
                    const n = t.array, i = t.itemSize, r = t.normalized, o = new n.constructor(e.length * i);
                    let s = 0, a = 0;
                    for (let r = 0, l = e.length; r < l; r++) {
                        s = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i;
                        for (let t = 0; t < i; t++) o[a++] = n[s++]
                    }
                    return new Is(o, i, r)
                }

                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                const e = new Gs, n = this.index.array, i = this.attributes;
                for (const r in i) {
                    const o = t(i[r], n);
                    e.setAttribute(r, o)
                }
                const r = this.morphAttributes;
                for (const i in r) {
                    const o = [], s = r[i];
                    for (let e = 0, i = s.length; e < i; e++) {
                        const i = t(s[e], n);
                        o.push(i)
                    }
                    e.morphAttributes[i] = o
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const o = this.groups;
                for (let t = 0, n = o.length; t < n; t++) {
                    const n = o[t];
                    e.addGroup(n.start, n.count, n.materialIndex)
                }
                return e
            }

            toJSON() {
                const t = {metadata: {version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON"}};
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                    const e = this.parameters;
                    for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                t.data = {attributes: {}};
                const e = this.index;
                null !== e && (t.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                const n = this.attributes;
                for (const e in n) {
                    const i = n[e];
                    t.data.attributes[e] = i.toJSON(t.data)
                }
                const i = {};
                let r = !1;
                for (const e in this.morphAttributes) {
                    const n = this.morphAttributes[e], o = [];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        o.push(i.toJSON(t.data))
                    }
                    o.length > 0 && (i[e] = o, r = !0)
                }
                r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
                const o = this.groups;
                o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
                const s = this.boundingSphere;
                return null !== s && (t.data.boundingSphere = {center: s.center.toArray(), radius: s.radius}), t
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            copy(t) {
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                const e = {};
                this.name = t.name;
                const n = t.index;
                null !== n && this.setIndex(n.clone(e));
                const i = t.attributes;
                for (const t in i) {
                    const n = i[t];
                    this.setAttribute(t, n.clone(e))
                }
                const r = t.morphAttributes;
                for (const t in r) {
                    const n = [], i = r[t];
                    for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
                    this.morphAttributes[t] = n
                }
                this.morphTargetsRelative = t.morphTargetsRelative;
                const o = t.groups;
                for (let t = 0, e = o.length; t < e; t++) {
                    const e = o[t];
                    this.addGroup(e.start, e.count, e.materialIndex)
                }
                const s = t.boundingBox;
                null !== s && (this.boundingBox = s.clone());
                const a = t.boundingSphere;
                return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, void 0 !== t.parameters && (this.parameters = Object.assign({}, t.parameters)), this
            }

            dispose() {
                this.dispatchEvent({type: "dispose"})
            }
        }

        Gs.prototype.isBufferGeometry = !0;
        const Ws = new No, js = new ko, qs = new Po, Xs = new oo, Ys = new oo, Js = new oo, Zs = new oo, Qs = new oo,
            Ks = new oo, $s = new oo, ta = new oo, ea = new oo, na = new jr, ia = new jr, ra = new jr, oa = new oo,
            sa = new oo;

        class aa extends ls {
            constructor(t = new Gs, e = new Ls) {
                super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
            }

            copy(t) {
                return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
            }

            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes, n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }

            raycast(t, e) {
                const n = this.geometry, i = this.material, r = this.matrixWorld;
                if (void 0 === i) return;
                if (null === n.boundingSphere && n.computeBoundingSphere(), qs.copy(n.boundingSphere), qs.applyMatrix4(r), !1 === t.ray.intersectsSphere(qs)) return;
                if (Ws.copy(r).invert(), js.copy(t.ray).applyMatrix4(Ws), null !== n.boundingBox && !1 === js.intersectsBox(n.boundingBox)) return;
                let o;
                if (n.isBufferGeometry) {
                    const r = n.index, s = n.attributes.position, a = n.morphAttributes.position,
                        l = n.morphTargetsRelative, c = n.attributes.uv, u = n.attributes.uv2, h = n.groups,
                        d = n.drawRange;
                    if (null !== r) if (Array.isArray(i)) for (let n = 0, p = h.length; n < p; n++) {
                        const p = h[n], f = i[p.materialIndex];
                        for (let n = Math.max(p.start, d.start), i = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); n < i; n += 3) {
                            const i = r.getX(n), h = r.getX(n + 1), d = r.getX(n + 2);
                            o = la(this, f, t, js, s, a, l, c, u, i, h, d), o && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = p.materialIndex, e.push(o))
                        }
                    } else {
                        for (let n = Math.max(0, d.start), h = Math.min(r.count, d.start + d.count); n < h; n += 3) {
                            const h = r.getX(n), d = r.getX(n + 1), p = r.getX(n + 2);
                            o = la(this, i, t, js, s, a, l, c, u, h, d, p), o && (o.faceIndex = Math.floor(n / 3), e.push(o))
                        }
                    } else if (void 0 !== s) if (Array.isArray(i)) for (let n = 0, r = h.length; n < r; n++) {
                        const r = h[n], p = i[r.materialIndex];
                        for (let n = Math.max(r.start, d.start), i = Math.min(s.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3) {
                            o = la(this, p, t, js, s, a, l, c, u, n, n + 1, n + 2), o && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = r.materialIndex, e.push(o))
                        }
                    } else {
                        for (let n = Math.max(0, d.start), r = Math.min(s.count, d.start + d.count); n < r; n += 3) {
                            o = la(this, i, t, js, s, a, l, c, u, n, n + 1, n + 2), o && (o.faceIndex = Math.floor(n / 3), e.push(o))
                        }
                    }
                } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }

        function la(t, e, n, i, r, o, s, a, l, c, u, h) {
            Xs.fromBufferAttribute(r, c), Ys.fromBufferAttribute(r, u), Js.fromBufferAttribute(r, h);
            const d = t.morphTargetInfluences;
            if (o && d) {
                $s.set(0, 0, 0), ta.set(0, 0, 0), ea.set(0, 0, 0);
                for (let t = 0, e = o.length; t < e; t++) {
                    const e = d[t], n = o[t];
                    0 !== e && (Zs.fromBufferAttribute(n, c), Qs.fromBufferAttribute(n, u), Ks.fromBufferAttribute(n, h), s ? ($s.addScaledVector(Zs, e), ta.addScaledVector(Qs, e), ea.addScaledVector(Ks, e)) : ($s.addScaledVector(Zs.sub(Xs), e), ta.addScaledVector(Qs.sub(Ys), e), ea.addScaledVector(Ks.sub(Js), e)))
                }
                Xs.add($s), Ys.add(ta), Js.add(ea)
            }
            t.isSkinnedMesh && (t.boneTransform(c, Xs), t.boneTransform(u, Ys), t.boneTransform(h, Js));
            const p = function (t, e, n, i, r, o, s, a) {
                let l;
                if (l = 1 === e.side ? i.intersectTriangle(s, o, r, !0, a) : i.intersectTriangle(r, o, s, 2 !== e.side, a), null === l) return null;
                sa.copy(a), sa.applyMatrix4(t.matrixWorld);
                const c = n.ray.origin.distanceTo(sa);
                return c < n.near || c > n.far ? null : {distance: c, point: sa.clone(), object: t}
            }(t, e, n, i, Xs, Ys, Js, oa);
            if (p) {
                a && (na.fromBufferAttribute(a, c), ia.fromBufferAttribute(a, u), ra.fromBufferAttribute(a, h), p.uv = xs.getUV(oa, Xs, Ys, Js, na, ia, ra, new jr)), l && (na.fromBufferAttribute(l, c), ia.fromBufferAttribute(l, u), ra.fromBufferAttribute(l, h), p.uv2 = xs.getUV(oa, Xs, Ys, Js, na, ia, ra, new jr));
                const t = {a: c, b: u, c: h, normal: new oo, materialIndex: 0};
                xs.getNormal(Xs, Ys, Js, t.normal), p.face = t
            }
            return p
        }

        aa.prototype.isMesh = !0;

        class ca extends Gs {
            constructor(t = 1, e = 1, n = 1, i = 1, r = 1, o = 1) {
                super(), this.type = "BoxGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: o
                };
                const s = this;
                i = Math.floor(i), r = Math.floor(r), o = Math.floor(o);
                const a = [], l = [], c = [], u = [];
                let h = 0, d = 0;

                function p(t, e, n, i, r, o, p, f, m, g, v) {
                    const y = o / m, x = p / g, _ = o / 2, b = p / 2, w = f / 2, S = m + 1, M = g + 1;
                    let T = 0, E = 0;
                    const A = new oo;
                    for (let o = 0; o < M; o++) {
                        const s = o * x - b;
                        for (let a = 0; a < S; a++) {
                            const h = a * y - _;
                            A[t] = h * i, A[e] = s * r, A[n] = w, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = f > 0 ? 1 : -1, c.push(A.x, A.y, A.z), u.push(a / m), u.push(1 - o / g), T += 1
                        }
                    }
                    for (let t = 0; t < g; t++) for (let e = 0; e < m; e++) {
                        const n = h + e + S * t, i = h + e + S * (t + 1), r = h + (e + 1) + S * (t + 1),
                            o = h + (e + 1) + S * t;
                        a.push(n, i, o), a.push(i, r, o), E += 6
                    }
                    s.addGroup(d, E, v), d += E, h += T
                }

                p("z", "y", "x", -1, -1, n, e, t, o, r, 0), p("z", "y", "x", 1, -1, n, e, -t, o, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, o, 2), p("x", "z", "y", 1, -1, t, n, -e, i, o, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new zs(l, 3)), this.setAttribute("normal", new zs(c, 3)), this.setAttribute("uv", new zs(u, 2))
            }

            static fromJSON(t) {
                return new ca(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
            }
        }

        function ua(t) {
            const e = {};
            for (const n in t) {
                e[n] = {};
                for (const i in t[n]) {
                    const r = t[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                }
            }
            return e
        }

        function ha(t) {
            const e = {};
            for (let n = 0; n < t.length; n++) {
                const i = ua(t[n]);
                for (const t in i) e[t] = i[t]
            }
            return e
        }

        const da = {clone: ua, merge: ha};

        class pa extends bs {
            constructor(t) {
                super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
            }

            copy(t) {
                return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = ua(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
            }

            toJSON(t) {
                const e = super.toJSON(t);
                e.glslVersion = this.glslVersion, e.uniforms = {};
                for (const n in this.uniforms) {
                    const i = this.uniforms[n].value;
                    i && i.isTexture ? e.uniforms[n] = {
                        type: "t",
                        value: i.toJSON(t).uuid
                    } : i && i.isColor ? e.uniforms[n] = {
                        type: "c",
                        value: i.getHex()
                    } : i && i.isVector2 ? e.uniforms[n] = {
                        type: "v2",
                        value: i.toArray()
                    } : i && i.isVector3 ? e.uniforms[n] = {
                        type: "v3",
                        value: i.toArray()
                    } : i && i.isVector4 ? e.uniforms[n] = {
                        type: "v4",
                        value: i.toArray()
                    } : i && i.isMatrix3 ? e.uniforms[n] = {
                        type: "m3",
                        value: i.toArray()
                    } : i && i.isMatrix4 ? e.uniforms[n] = {type: "m4", value: i.toArray()} : e.uniforms[n] = {value: i}
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                const n = {};
                for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                return Object.keys(n).length > 0 && (e.extensions = n), e
            }
        }

        pa.prototype.isShaderMaterial = !0;

        class fa extends ls {
            constructor() {
                super(), this.type = "Camera", this.matrixWorldInverse = new No, this.projectionMatrix = new No, this.projectionMatrixInverse = new No
            }

            copy(t, e) {
                return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
            }

            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(-e[8], -e[9], -e[10]).normalize()
            }

            updateMatrixWorld(t) {
                super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }

            updateWorldMatrix(t, e) {
                super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }

            clone() {
                return (new this.constructor).copy(this)
            }
        }

        fa.prototype.isCamera = !0;

        class ma extends fa {
            constructor(t = 50, e = 1, n = .1, i = 2e3) {
                super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }

            copy(t, e) {
                return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
            }

            setFocalLength(t) {
                const e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * Br * Math.atan(e), this.updateProjectionMatrix()
            }

            getFocalLength() {
                const t = Math.tan(.5 * Nr * this.fov);
                return .5 * this.getFilmHeight() / t
            }

            getEffectiveFOV() {
                return 2 * Br * Math.atan(Math.tan(.5 * Nr * this.fov) / this.zoom)
            }

            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }

            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }

            setViewOffset(t, e, n, i, r, o) {
                this.aspect = t / e, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
            }

            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }

            updateProjectionMatrix() {
                const t = this.near;
                let e = t * Math.tan(.5 * Nr * this.fov) / this.zoom, n = 2 * e, i = this.aspect * n, r = -.5 * i;
                const o = this.view;
                if (null !== this.view && this.view.enabled) {
                    const t = o.fullWidth, s = o.fullHeight;
                    r += o.offsetX * i / t, e -= o.offsetY * n / s, i *= o.width / t, n *= o.height / s
                }
                const s = this.filmOffset;
                0 !== s && (r += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }

            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
            }
        }

        ma.prototype.isPerspectiveCamera = !0;
        const ga = 90;

        class va extends ls {
            constructor(t, e, n) {
                if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                this.renderTarget = n;
                const i = new ma(ga, 1, t, e);
                i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new oo(1, 0, 0)), this.add(i);
                const r = new ma(ga, 1, t, e);
                r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new oo(-1, 0, 0)), this.add(r);
                const o = new ma(ga, 1, t, e);
                o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new oo(0, 1, 0)), this.add(o);
                const s = new ma(ga, 1, t, e);
                s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new oo(0, -1, 0)), this.add(s);
                const a = new ma(ga, 1, t, e);
                a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new oo(0, 0, 1)), this.add(a);
                const l = new ma(ga, 1, t, e);
                l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new oo(0, 0, -1)), this.add(l)
            }

            update(t, e) {
                null === this.parent && this.updateMatrixWorld();
                const n = this.renderTarget, [i, r, o, s, a, l] = this.children, c = t.xr.enabled,
                    u = t.getRenderTarget();
                t.xr.enabled = !1;
                const h = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, o), t.setRenderTarget(n, 3), t.render(e, s), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = h, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(u), t.xr.enabled = c
            }
        }

        class ya extends $r {
            constructor(t, e, n, i, r, o, s, a, l, c) {
                super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : Zi, n, i, r, o, s, a, l, c), this.flipY = !1
            }

            get images() {
                return this.image
            }

            set images(t) {
                this.image = t
            }
        }

        ya.prototype.isCubeTexture = !0;

        class xa extends no {
            constructor(t, e, n) {
                Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new ya(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : lr, this.texture._needsFlipEnvMap = !1
            }

            fromEquirectangularTexture(t, e) {
                this.texture.type = e.type, this.texture.format = vr, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                const n = {
                    uniforms: {tEquirect: {value: null}},
                    vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                }, i = new ca(5, 5, 5), r = new pa({
                    name: "CubemapFromEquirect",
                    uniforms: ua(n.uniforms),
                    vertexShader: n.vertexShader,
                    fragmentShader: n.fragmentShader,
                    side: 1,
                    blending: 0
                });
                r.uniforms.tEquirect.value = e;
                const o = new aa(i, r), s = e.minFilter;
                e.minFilter === cr && (e.minFilter = lr);
                return new va(1, 10, this).update(t, o), e.minFilter = s, o.geometry.dispose(), o.material.dispose(), this
            }

            clear(t, e, n, i) {
                const r = t.getRenderTarget();
                for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
                t.setRenderTarget(r)
            }
        }

        xa.prototype.isWebGLCubeRenderTarget = !0;
        const _a = new oo, ba = new oo, wa = new qr;

        class Sa {
            constructor(t = new oo(1, 0, 0), e = 0) {
                this.normal = t, this.constant = e
            }

            set(t, e) {
                return this.normal.copy(t), this.constant = e, this
            }

            setComponents(t, e, n, i) {
                return this.normal.set(t, e, n), this.constant = i, this
            }

            setFromNormalAndCoplanarPoint(t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            }

            setFromCoplanarPoints(t, e, n) {
                const i = _a.subVectors(n, e).cross(ba.subVectors(t, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, t), this
            }

            copy(t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            }

            normalize() {
                const t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            }

            negate() {
                return this.constant *= -1, this.normal.negate(), this
            }

            distanceToPoint(t) {
                return this.normal.dot(t) + this.constant
            }

            distanceToSphere(t) {
                return this.distanceToPoint(t.center) - t.radius
            }

            projectPoint(t, e) {
                return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            }

            intersectLine(t, e) {
                const n = t.delta(_a), i = this.normal.dot(n);
                if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                const r = -(t.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start)
            }

            intersectsLine(t) {
                const e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end);
                return e < 0 && n > 0 || n < 0 && e > 0
            }

            intersectsBox(t) {
                return t.intersectsPlane(this)
            }

            intersectsSphere(t) {
                return t.intersectsPlane(this)
            }

            coplanarPoint(t) {
                return t.copy(this.normal).multiplyScalar(-this.constant)
            }

            applyMatrix4(t, e) {
                const n = e || wa.getNormalMatrix(t), i = this.coplanarPoint(_a).applyMatrix4(t),
                    r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r), this
            }

            translate(t) {
                return this.constant -= t.dot(this.normal), this
            }

            equals(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }

            clone() {
                return (new this.constructor).copy(this)
            }
        }

        Sa.prototype.isPlane = !0;
        const Ma = new Po, Ta = new oo;

        class Ea {
            constructor(t = new Sa, e = new Sa, n = new Sa, i = new Sa, r = new Sa, o = new Sa) {
                this.planes = [t, e, n, i, r, o]
            }

            set(t, e, n, i, r, o) {
                const s = this.planes;
                return s[0].copy(t), s[1].copy(e), s[2].copy(n), s[3].copy(i), s[4].copy(r), s[5].copy(o), this
            }

            copy(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                return this
            }

            setFromProjectionMatrix(t) {
                const e = this.planes, n = t.elements, i = n[0], r = n[1], o = n[2], s = n[3], a = n[4], l = n[5],
                    c = n[6], u = n[7], h = n[8], d = n[9], p = n[10], f = n[11], m = n[12], g = n[13], v = n[14],
                    y = n[15];
                return e[0].setComponents(s - i, u - a, f - h, y - m).normalize(), e[1].setComponents(s + i, u + a, f + h, y + m).normalize(), e[2].setComponents(s + r, u + l, f + d, y + g).normalize(), e[3].setComponents(s - r, u - l, f - d, y - g).normalize(), e[4].setComponents(s - o, u - c, f - p, y - v).normalize(), e[5].setComponents(s + o, u + c, f + p, y + v).normalize(), this
            }

            intersectsObject(t) {
                const e = t.geometry;
                return null === e.boundingSphere && e.computeBoundingSphere(), Ma.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Ma)
            }

            intersectsSprite(t) {
                return Ma.center.set(0, 0, 0), Ma.radius = .7071067811865476, Ma.applyMatrix4(t.matrixWorld), this.intersectsSphere(Ma)
            }

            intersectsSphere(t) {
                const e = this.planes, n = t.center, i = -t.radius;
                for (let t = 0; t < 6; t++) {
                    if (e[t].distanceToPoint(n) < i) return !1
                }
                return !0
            }

            intersectsBox(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = e[n];
                    if (Ta.x = i.normal.x > 0 ? t.max.x : t.min.x, Ta.y = i.normal.y > 0 ? t.max.y : t.min.y, Ta.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Ta) < 0) return !1
                }
                return !0
            }

            containsPoint(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
                return !0
            }

            clone() {
                return (new this.constructor).copy(this)
            }
        }

        function Aa() {
            let t = null, e = !1, n = null, i = null;

            function r(e, o) {
                n(e, o), i = t.requestAnimationFrame(r)
            }

            return {
                start: function () {
                    !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0)
                }, stop: function () {
                    t.cancelAnimationFrame(i), e = !1
                }, setAnimationLoop: function (t) {
                    n = t
                }, setContext: function (e) {
                    t = e
                }
            }
        }

        function Pa(t, e) {
            const n = e.isWebGL2, i = new WeakMap;
            return {
                get: function (t) {
                    return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
                }, remove: function (e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const n = i.get(e);
                    n && (t.deleteBuffer(n.buffer), i.delete(e))
                }, update: function (e, r) {
                    if (e.isGLBufferAttribute) {
                        const t = i.get(e);
                        return void ((!t || t.version < e.version) && i.set(e, {
                            buffer: e.buffer,
                            type: e.type,
                            bytesPerElement: e.elementSize,
                            version: e.version
                        }))
                    }
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const o = i.get(e);
                    void 0 === o ? i.set(e, function (e, i) {
                        const r = e.array, o = e.usage, s = t.createBuffer();
                        t.bindBuffer(i, s), t.bufferData(i, r, o), e.onUploadCallback();
                        let a = 5126;
                        return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) && (a = 5121), {
                            buffer: s,
                            type: a,
                            bytesPerElement: r.BYTES_PER_ELEMENT,
                            version: e.version
                        }
                    }(e, r)) : o.version < e.version && (!function (e, i, r) {
                        const o = i.array, s = i.updateRange;
                        t.bindBuffer(r, e), -1 === s.count ? t.bufferSubData(r, 0, o) : (n ? t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o, s.offset, s.count) : t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)), s.count = -1)
                    }(o.buffer, e, r), o.version = e.version)
                }
            }
        }

        class La extends Gs {
            constructor(t = 1, e = 1, n = 1, i = 1) {
                super(), this.type = "PlaneGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                };
                const r = t / 2, o = e / 2, s = Math.floor(n), a = Math.floor(i), l = s + 1, c = a + 1, u = t / s,
                    h = e / a, d = [], p = [], f = [], m = [];
                for (let t = 0; t < c; t++) {
                    const e = t * h - o;
                    for (let n = 0; n < l; n++) {
                        const i = n * u - r;
                        p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / s), m.push(1 - t / a)
                    }
                }
                for (let t = 0; t < a; t++) for (let e = 0; e < s; e++) {
                    const n = e + l * t, i = e + l * (t + 1), r = e + 1 + l * (t + 1), o = e + 1 + l * t;
                    d.push(n, i, o), d.push(i, r, o)
                }
                this.setIndex(d), this.setAttribute("position", new zs(p, 3)), this.setAttribute("normal", new zs(f, 3)), this.setAttribute("uv", new zs(m, 2))
            }

            static fromJSON(t) {
                return new La(t.width, t.height, t.widthSegments, t.heightSegments)
            }
        }

        const Ca = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
            alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
            common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
            normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
            normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
            output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
            transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
            uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
        }, Ra = {
            common: {
                diffuse: {value: new Ps(16777215)},
                opacity: {value: 1},
                map: {value: null},
                uvTransform: {value: new qr},
                uv2Transform: {value: new qr},
                alphaMap: {value: null},
                alphaTest: {value: 0}
            },
            specularmap: {specularMap: {value: null}},
            envmap: {
                envMap: {value: null},
                flipEnvMap: {value: -1},
                reflectivity: {value: 1},
                ior: {value: 1.5},
                refractionRatio: {value: .98}
            },
            aomap: {aoMap: {value: null}, aoMapIntensity: {value: 1}},
            lightmap: {lightMap: {value: null}, lightMapIntensity: {value: 1}},
            emissivemap: {emissiveMap: {value: null}},
            bumpmap: {bumpMap: {value: null}, bumpScale: {value: 1}},
            normalmap: {normalMap: {value: null}, normalScale: {value: new jr(1, 1)}},
            displacementmap: {
                displacementMap: {value: null},
                displacementScale: {value: 1},
                displacementBias: {value: 0}
            },
            roughnessmap: {roughnessMap: {value: null}},
            metalnessmap: {metalnessMap: {value: null}},
            gradientmap: {gradientMap: {value: null}},
            fog: {
                fogDensity: {value: 25e-5},
                fogNear: {value: 1},
                fogFar: {value: 2e3},
                fogColor: {value: new Ps(16777215)}
            },
            lights: {
                ambientLightColor: {value: []},
                lightProbe: {value: []},
                directionalLights: {value: [], properties: {direction: {}, color: {}}},
                directionalLightShadows: {
                    value: [],
                    properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}}
                },
                directionalShadowMap: {value: []},
                directionalShadowMatrix: {value: []},
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}}
                },
                spotShadowMap: {value: []},
                spotShadowMatrix: {value: []},
                pointLights: {value: [], properties: {color: {}, position: {}, decay: {}, distance: {}}},
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {value: []},
                pointShadowMatrix: {value: []},
                hemisphereLights: {value: [], properties: {direction: {}, skyColor: {}, groundColor: {}}},
                rectAreaLights: {value: [], properties: {color: {}, position: {}, width: {}, height: {}}},
                ltc_1: {value: null},
                ltc_2: {value: null}
            },
            points: {
                diffuse: {value: new Ps(16777215)},
                opacity: {value: 1},
                size: {value: 1},
                scale: {value: 1},
                map: {value: null},
                alphaMap: {value: null},
                alphaTest: {value: 0},
                uvTransform: {value: new qr}
            },
            sprite: {
                diffuse: {value: new Ps(16777215)},
                opacity: {value: 1},
                center: {value: new jr(.5, .5)},
                rotation: {value: 0},
                map: {value: null},
                alphaMap: {value: null},
                alphaTest: {value: 0},
                uvTransform: {value: new qr}
            }
        }, Ia = {
            basic: {
                uniforms: ha([Ra.common, Ra.specularmap, Ra.envmap, Ra.aomap, Ra.lightmap, Ra.fog]),
                vertexShader: Ca.meshbasic_vert,
                fragmentShader: Ca.meshbasic_frag
            },
            lambert: {
                uniforms: ha([Ra.common, Ra.specularmap, Ra.envmap, Ra.aomap, Ra.lightmap, Ra.emissivemap, Ra.fog, Ra.lights, {emissive: {value: new Ps(0)}}]),
                vertexShader: Ca.meshlambert_vert,
                fragmentShader: Ca.meshlambert_frag
            },
            phong: {
                uniforms: ha([Ra.common, Ra.specularmap, Ra.envmap, Ra.aomap, Ra.lightmap, Ra.emissivemap, Ra.bumpmap, Ra.normalmap, Ra.displacementmap, Ra.fog, Ra.lights, {
                    emissive: {value: new Ps(0)},
                    specular: {value: new Ps(1118481)},
                    shininess: {value: 30}
                }]), vertexShader: Ca.meshphong_vert, fragmentShader: Ca.meshphong_frag
            },
            standard: {
                uniforms: ha([Ra.common, Ra.envmap, Ra.aomap, Ra.lightmap, Ra.emissivemap, Ra.bumpmap, Ra.normalmap, Ra.displacementmap, Ra.roughnessmap, Ra.metalnessmap, Ra.fog, Ra.lights, {
                    emissive: {value: new Ps(0)},
                    roughness: {value: 1},
                    metalness: {value: 0},
                    envMapIntensity: {value: 1}
                }]), vertexShader: Ca.meshphysical_vert, fragmentShader: Ca.meshphysical_frag
            },
            toon: {
                uniforms: ha([Ra.common, Ra.aomap, Ra.lightmap, Ra.emissivemap, Ra.bumpmap, Ra.normalmap, Ra.displacementmap, Ra.gradientmap, Ra.fog, Ra.lights, {emissive: {value: new Ps(0)}}]),
                vertexShader: Ca.meshtoon_vert,
                fragmentShader: Ca.meshtoon_frag
            },
            matcap: {
                uniforms: ha([Ra.common, Ra.bumpmap, Ra.normalmap, Ra.displacementmap, Ra.fog, {matcap: {value: null}}]),
                vertexShader: Ca.meshmatcap_vert,
                fragmentShader: Ca.meshmatcap_frag
            },
            points: {uniforms: ha([Ra.points, Ra.fog]), vertexShader: Ca.points_vert, fragmentShader: Ca.points_frag},
            dashed: {
                uniforms: ha([Ra.common, Ra.fog, {
                    scale: {value: 1},
                    dashSize: {value: 1},
                    totalSize: {value: 2}
                }]), vertexShader: Ca.linedashed_vert, fragmentShader: Ca.linedashed_frag
            },
            depth: {
                uniforms: ha([Ra.common, Ra.displacementmap]),
                vertexShader: Ca.depth_vert,
                fragmentShader: Ca.depth_frag
            },
            normal: {
                uniforms: ha([Ra.common, Ra.bumpmap, Ra.normalmap, Ra.displacementmap, {opacity: {value: 1}}]),
                vertexShader: Ca.meshnormal_vert,
                fragmentShader: Ca.meshnormal_frag
            },
            sprite: {uniforms: ha([Ra.sprite, Ra.fog]), vertexShader: Ca.sprite_vert, fragmentShader: Ca.sprite_frag},
            background: {
                uniforms: {uvTransform: {value: new qr}, t2D: {value: null}},
                vertexShader: Ca.background_vert,
                fragmentShader: Ca.background_frag
            },
            cube: {
                uniforms: ha([Ra.envmap, {opacity: {value: 1}}]),
                vertexShader: Ca.cube_vert,
                fragmentShader: Ca.cube_frag
            },
            equirect: {
                uniforms: {tEquirect: {value: null}},
                vertexShader: Ca.equirect_vert,
                fragmentShader: Ca.equirect_frag
            },
            distanceRGBA: {
                uniforms: ha([Ra.common, Ra.displacementmap, {
                    referencePosition: {value: new oo},
                    nearDistance: {value: 1},
                    farDistance: {value: 1e3}
                }]), vertexShader: Ca.distanceRGBA_vert, fragmentShader: Ca.distanceRGBA_frag
            },
            shadow: {
                uniforms: ha([Ra.lights, Ra.fog, {color: {value: new Ps(0)}, opacity: {value: 1}}]),
                vertexShader: Ca.shadow_vert,
                fragmentShader: Ca.shadow_frag
            }
        };

        function Oa(t, e, n, i, r) {
            const o = new Ps(0);
            let s, a, l = 0, c = null, u = 0, h = null;

            function d(t, e) {
                n.buffers.color.setClear(t.r, t.g, t.b, e, r)
            }

            return {
                getClearColor: function () {
                    return o
                }, setClearColor: function (t, e = 1) {
                    o.set(t), l = e, d(o, l)
                }, getClearAlpha: function () {
                    return l
                }, setClearAlpha: function (t) {
                    l = t, d(o, l)
                }, render: function (n, r) {
                    let p = !1, f = !0 === r.isScene ? r.background : null;
                    f && f.isTexture && (f = e.get(f));
                    const m = t.xr, g = m.getSession && m.getSession();
                    g && "additive" === g.environmentBlendMode && (f = null), null === f ? d(o, l) : f && f.isColor && (d(f, 1), p = !0), (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), f && (f.isCubeTexture || f.mapping === tr) ? (void 0 === a && (a = new aa(new ca(1, 1, 1), new pa({
                        name: "BackgroundCubeMaterial",
                        uniforms: ua(Ia.cube.uniforms),
                        vertexShader: Ia.cube.vertexShader,
                        fragmentShader: Ia.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function (t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(a.material, "envMap", {
                        get: function () {
                            return this.uniforms.envMap.value
                        }
                    }), i.update(a)), a.material.uniforms.envMap.value = f, a.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1, c === f && u === f.version && h === t.toneMapping || (a.material.needsUpdate = !0, c = f, u = f.version, h = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null)) : f && f.isTexture && (void 0 === s && (s = new aa(new La(2, 2), new pa({
                        name: "BackgroundMaterial",
                        uniforms: ua(Ia.background.uniforms),
                        vertexShader: Ia.background.vertexShader,
                        fragmentShader: Ia.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), s.geometry.deleteAttribute("normal"), Object.defineProperty(s.material, "map", {
                        get: function () {
                            return this.uniforms.t2D.value
                        }
                    }), i.update(s)), s.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), s.material.uniforms.uvTransform.value.copy(f.matrix), c === f && u === f.version && h === t.toneMapping || (s.material.needsUpdate = !0, c = f, u = f.version, h = t.toneMapping), n.unshift(s, s.geometry, s.material, 0, 0, null))
                }
            }
        }

        function Da(t, e, n, i) {
            const r = t.getParameter(34921), o = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                s = i.isWebGL2 || null !== o, a = {}, l = d(null);
            let c = l;

            function u(e) {
                return i.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e)
            }

            function h(e) {
                return i.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e)
            }

            function d(t) {
                const e = [], n = [], i = [];
                for (let t = 0; t < r; t++) e[t] = 0, n[t] = 0, i[t] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: n,
                    attributeDivisors: i,
                    object: t,
                    attributes: {},
                    index: null
                }
            }

            function p() {
                const t = c.newAttributes;
                for (let e = 0, n = t.length; e < n; e++) t[e] = 0
            }

            function f(t) {
                m(t, 0)
            }

            function m(n, r) {
                const o = c.newAttributes, s = c.enabledAttributes, a = c.attributeDivisors;
                if (o[n] = 1, 0 === s[n] && (t.enableVertexAttribArray(n), s[n] = 1), a[n] !== r) {
                    (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r
                }
            }

            function g() {
                const e = c.newAttributes, n = c.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0)
            }

            function v(e, n, r, o, s, a) {
                !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, o, s, a) : t.vertexAttribIPointer(e, n, r, s, a)
            }

            function y() {
                x(), c !== l && (c = l, u(c.object))
            }

            function x() {
                l.geometry = null, l.program = null, l.wireframe = !1
            }

            return {
                setup: function (r, l, h, y, x) {
                    let _ = !1;
                    if (s) {
                        const e = function (e, n, r) {
                            const s = !0 === r.wireframe;
                            let l = a[e.id];
                            void 0 === l && (l = {}, a[e.id] = l);
                            let c = l[n.id];
                            void 0 === c && (c = {}, l[n.id] = c);
                            let u = c[s];
                            void 0 === u && (u = d(i.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()), c[s] = u);
                            return u
                        }(y, h, l);
                        c !== e && (c = e, u(c.object)), _ = function (t, e) {
                            const n = c.attributes, i = t.attributes;
                            let r = 0;
                            for (const t in i) {
                                const e = n[t], o = i[t];
                                if (void 0 === e) return !0;
                                if (e.attribute !== o) return !0;
                                if (e.data !== o.data) return !0;
                                r++
                            }
                            return c.attributesNum !== r || c.index !== e
                        }(y, x), _ && function (t, e) {
                            const n = {}, i = t.attributes;
                            let r = 0;
                            for (const t in i) {
                                const e = i[t], o = {};
                                o.attribute = e, e.data && (o.data = e.data), n[t] = o, r++
                            }
                            c.attributes = n, c.attributesNum = r, c.index = e
                        }(y, x)
                    } else {
                        const t = !0 === l.wireframe;
                        c.geometry === y.id && c.program === h.id && c.wireframe === t || (c.geometry = y.id, c.program = h.id, c.wireframe = t, _ = !0)
                    }
                    !0 === r.isInstancedMesh && (_ = !0), null !== x && n.update(x, 34963), _ && (!function (r, o, s, a) {
                        if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                        p();
                        const l = a.attributes, c = s.getAttributes(), u = o.defaultAttributeValues;
                        for (const e in c) {
                            const i = c[e];
                            if (i.location >= 0) {
                                let o = l[e];
                                if (void 0 === o && ("instanceMatrix" === e && r.instanceMatrix && (o = r.instanceMatrix), "instanceColor" === e && r.instanceColor && (o = r.instanceColor)), void 0 !== o) {
                                    const e = o.normalized, s = o.itemSize, l = n.get(o);
                                    if (void 0 === l) continue;
                                    const c = l.buffer, u = l.type, h = l.bytesPerElement;
                                    if (o.isInterleavedBufferAttribute) {
                                        const n = o.data, l = n.stride, d = o.offset;
                                        if (n && n.isInstancedInterleavedBuffer) {
                                            for (let t = 0; t < i.locationSize; t++) m(i.location + t, n.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)
                                        } else for (let t = 0; t < i.locationSize; t++) f(i.location + t);
                                        t.bindBuffer(34962, c);
                                        for (let t = 0; t < i.locationSize; t++) v(i.location + t, s / i.locationSize, u, e, l * h, (d + s / i.locationSize * t) * h)
                                    } else {
                                        if (o.isInstancedBufferAttribute) {
                                            for (let t = 0; t < i.locationSize; t++) m(i.location + t, o.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)
                                        } else for (let t = 0; t < i.locationSize; t++) f(i.location + t);
                                        t.bindBuffer(34962, c);
                                        for (let t = 0; t < i.locationSize; t++) v(i.location + t, s / i.locationSize, u, e, s * h, s / i.locationSize * t * h)
                                    }
                                } else if (void 0 !== u) {
                                    const n = u[e];
                                    if (void 0 !== n) switch (n.length) {
                                        case 2:
                                            t.vertexAttrib2fv(i.location, n);
                                            break;
                                        case 3:
                                            t.vertexAttrib3fv(i.location, n);
                                            break;
                                        case 4:
                                            t.vertexAttrib4fv(i.location, n);
                                            break;
                                        default:
                                            t.vertexAttrib1fv(i.location, n)
                                    }
                                }
                            }
                        }
                        g()
                    }(r, l, h, y), null !== x && t.bindBuffer(34963, n.get(x).buffer))
                }, reset: y, resetDefaultState: x, dispose: function () {
                    y();
                    for (const t in a) {
                        const e = a[t];
                        for (const t in e) {
                            const n = e[t];
                            for (const t in n) h(n[t].object), delete n[t];
                            delete e[t]
                        }
                        delete a[t]
                    }
                }, releaseStatesOfGeometry: function (t) {
                    if (void 0 === a[t.id]) return;
                    const e = a[t.id];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n) h(n[t].object), delete n[t];
                        delete e[t]
                    }
                    delete a[t.id]
                }, releaseStatesOfProgram: function (t) {
                    for (const e in a) {
                        const n = a[e];
                        if (void 0 === n[t.id]) continue;
                        const i = n[t.id];
                        for (const t in i) h(i[t].object), delete i[t];
                        delete n[t.id]
                    }
                }, initAttributes: p, enableAttribute: f, disableUnusedAttributes: g
            }
        }

        function za(t, e, n, i) {
            const r = i.isWebGL2;
            let o;
            this.setMode = function (t) {
                o = t
            }, this.render = function (e, i) {
                t.drawArrays(o, e, i), n.update(i, o, 1)
            }, this.renderInstances = function (i, s, a) {
                if (0 === a) return;
                let l, c;
                if (r) l = t, c = "drawArraysInstanced"; else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                l[c](o, i, s, a), n.update(s, o, a)
            }
        }

        function ka(t, e, n) {
            let i;

            function r(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
            }

            const o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
            let s = void 0 !== n.precision ? n.precision : "highp";
            const a = r(s);
            a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a);
            const l = o || e.has("WEBGL_draw_buffers"), c = !0 === n.logarithmicDepthBuffer, u = t.getParameter(34930),
                h = t.getParameter(35660), d = t.getParameter(3379), p = t.getParameter(34076),
                f = t.getParameter(34921), m = t.getParameter(36347), g = t.getParameter(36348),
                v = t.getParameter(36349), y = h > 0, x = o || e.has("OES_texture_float");
            return {
                isWebGL2: o,
                drawBuffers: l,
                getMaxAnisotropy: function () {
                    if (void 0 !== i) return i;
                    if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                        const n = e.get("EXT_texture_filter_anisotropic");
                        i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else i = 0;
                    return i
                },
                getMaxPrecision: r,
                precision: s,
                logarithmicDepthBuffer: c,
                maxTextures: u,
                maxVertexTextures: h,
                maxTextureSize: d,
                maxCubemapSize: p,
                maxAttributes: f,
                maxVertexUniforms: m,
                maxVaryings: g,
                maxFragmentUniforms: v,
                vertexTextures: y,
                floatFragmentTextures: x,
                floatVertexTextures: y && x,
                maxSamples: o ? t.getParameter(36183) : 0
            }
        }

        function Na(t) {
            const e = this;
            let n = null, i = 0, r = !1, o = !1;
            const s = new Sa, a = new qr, l = {value: null, needsUpdate: !1};

            function c() {
                l.value !== n && (l.value = n, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0
            }

            function u(t, n, i, r) {
                const o = null !== t ? t.length : 0;
                let c = null;
                if (0 !== o) {
                    if (c = l.value, !0 !== r || null === c) {
                        const e = i + 4 * o, r = n.matrixWorldInverse;
                        a.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e));
                        for (let e = 0, n = i; e !== o; ++e, n += 4) s.copy(t[e]).applyMatrix4(r, a), s.normal.toArray(c, n), c[n + 3] = s.constant
                    }
                    l.value = c, l.needsUpdate = !0
                }
                return e.numPlanes = o, e.numIntersection = 0, c
            }

            this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e, o) {
                const s = 0 !== t.length || e || 0 !== i || r;
                return r = e, n = u(t, o, 0), i = t.length, s
            }, this.beginShadows = function () {
                o = !0, u(null)
            }, this.endShadows = function () {
                o = !1, c()
            }, this.setState = function (e, s, a) {
                const h = e.clippingPlanes, d = e.clipIntersection, p = e.clipShadows, f = t.get(e);
                if (!r || null === h || 0 === h.length || o && !p) o ? u(null) : c(); else {
                    const t = o ? 0 : i, e = 4 * t;
                    let r = f.clippingState || null;
                    l.value = r, r = u(h, s, e, a);
                    for (let t = 0; t !== e; ++t) r[t] = n[t];
                    f.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                }
            }
        }

        function Ba(t) {
            let e = new WeakMap;

            function n(t, e) {
                return e === Ki ? t.mapping = Zi : e === $i && (t.mapping = Qi), t
            }

            function i(t) {
                const n = t.target;
                n.removeEventListener("dispose", i);
                const r = e.get(n);
                void 0 !== r && (e.delete(n), r.dispose())
            }

            return {
                get: function (r) {
                    if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                        const o = r.mapping;
                        if (o === Ki || o === $i) {
                            if (e.has(r)) {
                                return n(e.get(r).texture, r.mapping)
                            }
                            {
                                const o = r.image;
                                if (o && o.height > 0) {
                                    const s = t.getRenderTarget(), a = new xa(o.height / 2);
                                    return a.fromEquirectangularTexture(t, r), e.set(r, a), t.setRenderTarget(s), r.addEventListener("dispose", i), n(a.texture, r.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return r
                }, dispose: function () {
                    e = new WeakMap
                }
            }
        }

        Ia.physical = {
            uniforms: ha([Ia.standard.uniforms, {
                clearcoat: {value: 0},
                clearcoatMap: {value: null},
                clearcoatRoughness: {value: 0},
                clearcoatRoughnessMap: {value: null},
                clearcoatNormalScale: {value: new jr(1, 1)},
                clearcoatNormalMap: {value: null},
                sheen: {value: 0},
                sheenColor: {value: new Ps(0)},
                sheenColorMap: {value: null},
                sheenRoughness: {value: 0},
                sheenRoughnessMap: {value: null},
                transmission: {value: 0},
                transmissionMap: {value: null},
                transmissionSamplerSize: {value: new jr},
                transmissionSamplerMap: {value: null},
                thickness: {value: 0},
                thicknessMap: {value: null},
                attenuationDistance: {value: 0},
                attenuationColor: {value: new Ps(0)},
                specularIntensity: {value: 0},
                specularIntensityMap: {value: null},
                specularColor: {value: new Ps(1, 1, 1)},
                specularColorMap: {value: null}
            }]), vertexShader: Ca.meshphysical_vert, fragmentShader: Ca.meshphysical_frag
        };

        class Fa extends fa {
            constructor(t = -1, e = 1, n = 1, i = -1, r = .1, o = 2e3) {
                super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = r, this.far = o, this.updateProjectionMatrix()
            }

            copy(t, e) {
                return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
            }

            setViewOffset(t, e, n, i, r, o) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
            }

            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }

            updateProjectionMatrix() {
                const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
                let r = n - t, o = n + t, s = i + e, a = i - e;
                if (null !== this.view && this.view.enabled) {
                    const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += t * this.view.offsetX, o = r + t * this.view.width, s -= e * this.view.offsetY, a = s - e * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, o, s, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }

            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
            }
        }

        Fa.prototype.isOrthographicCamera = !0;

        class Ua extends pa {
            constructor(t) {
                super(t), this.type = "RawShaderMaterial"
            }
        }

        Ua.prototype.isRawShaderMaterial = !0;
        const Ha = Math.pow(2, 8), Va = [.125, .215, .35, .446, .526, .582], Ga = 5 + Va.length, Wa = 20,
            ja = {[Ar]: 0, [Pr]: 1, [Cr]: 2, 3004: 3, 3005: 4, 3006: 5, [Lr]: 6}, qa = new Fa, {
                _lodPlanes: Xa,
                _sizeLods: Ya,
                _sigmas: Ja
            } = il(), Za = new Ps;
        let Qa = null;
        const Ka = (1 + Math.sqrt(5)) / 2, $a = 1 / Ka,
            tl = [new oo(1, 1, 1), new oo(-1, 1, 1), new oo(1, 1, -1), new oo(-1, 1, -1), new oo(0, Ka, $a), new oo(0, Ka, -$a), new oo($a, 0, Ka), new oo(-$a, 0, Ka), new oo(Ka, $a, 0), new oo(-Ka, $a, 0)];

        class el {
            constructor(t) {
                this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function (t) {
                    const e = new Float32Array(t), n = new oo(0, 1, 0);
                    return new Ua({
                        name: "SphericalGaussianBlur",
                        defines: {n: t},
                        uniforms: {
                            envMap: {value: null},
                            samples: {value: 1},
                            weights: {value: e},
                            latitudinal: {value: !1},
                            dTheta: {value: 0},
                            mipInt: {value: 0},
                            poleAxis: {value: n},
                            inputEncoding: {value: ja[3e3]},
                            outputEncoding: {value: ja[3e3]}
                        },
                        vertexShader: ll(),
                        fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${cl()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }(Wa), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
            }

            fromScene(t, e = 0, n = .1, i = 100) {
                Qa = this._renderer.getRenderTarget();
                const r = this._allocateTargets();
                return this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
            }

            fromEquirectangular(t) {
                return this._fromTexture(t)
            }

            fromCubemap(t) {
                return this._fromTexture(t)
            }

            compileCubemapShader() {
                null === this._cubemapShader && (this._cubemapShader = al(), this._compileMaterial(this._cubemapShader))
            }

            compileEquirectangularShader() {
                null === this._equirectShader && (this._equirectShader = sl(), this._compileMaterial(this._equirectShader))
            }

            dispose() {
                this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
                for (let t = 0; t < Xa.length; t++) Xa[t].dispose()
            }

            _cleanup(t) {
                this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Qa), t.scissorTest = !1, ol(t, 0, 0, t.width, t.height)
            }

            _fromTexture(t) {
                Qa = this._renderer.getRenderTarget();
                const e = this._allocateTargets(t);
                return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
            }

            _allocateTargets(t) {
                const e = {
                    magFilter: or,
                    minFilter: or,
                    generateMipmaps: !1,
                    type: ur,
                    format: 1023,
                    encoding: nl(t) ? t.encoding : Cr,
                    depthBuffer: !1
                }, n = rl(e);
                return n.depthBuffer = !t, this._pingPongRenderTarget = rl(e), n
            }

            _compileMaterial(t) {
                const e = new aa(Xa[0], t);
                this._renderer.compile(e, qa)
            }

            _sceneToCubeUV(t, e, n, i) {
                const r = new ma(90, 1, e, n), o = [1, -1, 1, 1, 1, 1], s = [1, 1, 1, -1, -1, -1], a = this._renderer,
                    l = a.autoClear, c = a.outputEncoding, u = a.toneMapping;
                a.getClearColor(Za), a.toneMapping = 0, a.outputEncoding = Ar, a.autoClear = !1;
                const h = new Ls({name: "PMREM.Background", side: 1, depthWrite: !1, depthTest: !1}),
                    d = new aa(new ca, h);
                let p = !1;
                const f = t.background;
                f ? f.isColor && (h.color.copy(f), t.background = null, p = !0) : (h.color.copy(Za), p = !0);
                for (let e = 0; e < 6; e++) {
                    const n = e % 3;
                    0 == n ? (r.up.set(0, o[e], 0), r.lookAt(s[e], 0, 0)) : 1 == n ? (r.up.set(0, 0, o[e]), r.lookAt(0, s[e], 0)) : (r.up.set(0, o[e], 0), r.lookAt(0, 0, s[e])), ol(i, n * Ha, e > 2 ? Ha : 0, Ha, Ha), a.setRenderTarget(i), p && a.render(d, r), a.render(t, r)
                }
                d.geometry.dispose(), d.material.dispose(), a.toneMapping = u, a.outputEncoding = c, a.autoClear = l, t.background = f
            }

            _setEncoding(t, e) {
                t.value = ja[e.encoding]
            }

            _textureToCubeUV(t, e) {
                const n = this._renderer, i = t.mapping === Zi || t.mapping === Qi;
                i ? null == this._cubemapShader && (this._cubemapShader = al()) : null == this._equirectShader && (this._equirectShader = sl());
                const r = i ? this._cubemapShader : this._equirectShader, o = new aa(Xa[0], r), s = r.uniforms;
                s.envMap.value = t, i || s.texelSize.value.set(1 / t.image.width, 1 / t.image.height), this._setEncoding(s.inputEncoding, t), this._setEncoding(s.outputEncoding, e.texture), ol(e, 0, 0, 3 * Ha, 2 * Ha), n.setRenderTarget(e), n.render(o, qa)
            }

            _applyPMREM(t) {
                const e = this._renderer, n = e.autoClear;
                e.autoClear = !1;
                for (let e = 1; e < Ga; e++) {
                    const n = Math.sqrt(Ja[e] * Ja[e] - Ja[e - 1] * Ja[e - 1]), i = tl[(e - 1) % tl.length];
                    this._blur(t, e - 1, e, n, i)
                }
                e.autoClear = n
            }

            _blur(t, e, n, i, r) {
                const o = this._pingPongRenderTarget;
                this._halfBlur(t, o, e, n, i, "latitudinal", r), this._halfBlur(o, t, n, n, i, "longitudinal", r)
            }

            _halfBlur(t, e, n, i, r, o, s) {
                const a = this._renderer, l = this._blurMaterial;
                "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
                const c = new aa(Xa[i], l), u = l.uniforms, h = Ya[n] - 1,
                    d = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39, p = r / d,
                    f = isFinite(r) ? 1 + Math.floor(3 * p) : Wa;
                f > Wa && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                const m = [];
                let g = 0;
                for (let t = 0; t < Wa; ++t) {
                    const e = t / p, n = Math.exp(-e * e / 2);
                    m.push(n), 0 == t ? g += n : t < f && (g += 2 * n)
                }
                for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
                u.envMap.value = t.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === o, s && (u.poleAxis.value = s), u.dTheta.value = d, u.mipInt.value = 8 - n, this._setEncoding(u.inputEncoding, t.texture), this._setEncoding(u.outputEncoding, t.texture);
                const v = Ya[i];
                ol(e, 3 * Math.max(0, Ha - 2 * v), (0 === i ? 0 : 2 * Ha) + 2 * v * (i > 4 ? i - 8 + 4 : 0), 3 * v, 2 * v), a.setRenderTarget(e), a.render(c, qa)
            }
        }

        function nl(t) {
            return void 0 !== t && t.type === ur && (t.encoding === Ar || t.encoding === Pr || t.encoding === Lr)
        }

        function il() {
            const t = [], e = [], n = [];
            let i = 8;
            for (let r = 0; r < Ga; r++) {
                const o = Math.pow(2, i);
                e.push(o);
                let s = 1 / o;
                r > 4 ? s = Va[r - 8 + 4 - 1] : 0 == r && (s = 0), n.push(s);
                const a = 1 / (o - 1), l = -a / 2, c = 1 + a / 2, u = [l, l, c, l, c, c, l, l, c, c, l, c], h = 6,
                    d = 6, p = 3, f = 2, m = 1, g = new Float32Array(p * d * h), v = new Float32Array(f * d * h),
                    y = new Float32Array(m * d * h);
                for (let t = 0; t < h; t++) {
                    const e = t % 3 * 2 / 3 - 1, n = t > 2 ? 0 : -1,
                        i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                    g.set(i, p * d * t), v.set(u, f * d * t);
                    const r = [t, t, t, t, t, t];
                    y.set(r, m * d * t)
                }
                const x = new Gs;
                x.setAttribute("position", new Is(g, p)), x.setAttribute("uv", new Is(v, f)), x.setAttribute("faceIndex", new Is(y, m)), t.push(x), i > 4 && i--
            }
            return {_lodPlanes: t, _sizeLods: e, _sigmas: n}
        }

        function rl(t) {
            const e = new no(3 * Ha, 3 * Ha, t);
            return e.texture.mapping = tr, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
        }

        function ol(t, e, n, i, r) {
            t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r)
        }

        function sl() {
            const t = new jr(1, 1);
            return new Ua({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {value: null},
                    texelSize: {value: t},
                    inputEncoding: {value: ja[3e3]},
                    outputEncoding: {value: ja[3e3]}
                },
                vertexShader: ll(),
                fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${cl()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function al() {
            return new Ua({
                name: "CubemapToCubeUV",
                uniforms: {envMap: {value: null}, inputEncoding: {value: ja[3e3]}, outputEncoding: {value: ja[3e3]}},
                vertexShader: ll(),
                fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${cl()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function ll() {
            return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
        }

        function cl() {
            return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"
        }

        function ul(t) {
            let e = new WeakMap, n = null;

            function i(t) {
                const n = t.target;
                n.removeEventListener("dispose", i);
                const r = e.get(n);
                void 0 !== r && (e.delete(n), r.dispose())
            }

            return {
                get: function (r) {
                    if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                        const o = r.mapping, s = o === Ki || o === $i, a = o === Zi || o === Qi;
                        if (s || a) {
                            if (e.has(r)) return e.get(r).texture;
                            {
                                const o = r.image;
                                if (s && o && o.height > 0 || a && o && function (t) {
                                    let e = 0;
                                    const n = 6;
                                    for (let i = 0; i < n; i++) void 0 !== t[i] && e++;
                                    return e === n
                                }(o)) {
                                    const o = t.getRenderTarget();
                                    null === n && (n = new el(t));
                                    const a = s ? n.fromEquirectangular(r) : n.fromCubemap(r);
                                    return e.set(r, a), t.setRenderTarget(o), r.addEventListener("dispose", i), a.texture
                                }
                                return null
                            }
                        }
                    }
                    return r
                }, dispose: function () {
                    e = new WeakMap, null !== n && (n.dispose(), n = null)
                }
            }
        }

        function hl(t) {
            const e = {};

            function n(n) {
                if (void 0 !== e[n]) return e[n];
                let i;
                switch (n) {
                    case"WEBGL_depth_texture":
                        i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case"EXT_texture_filter_anisotropic":
                        i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case"WEBGL_compressed_texture_s3tc":
                        i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case"WEBGL_compressed_texture_pvrtc":
                        i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        i = t.getExtension(n)
                }
                return e[n] = i, i
            }

            return {
                has: function (t) {
                    return null !== n(t)
                }, init: function (t) {
                    t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
                }, get: function (t) {
                    const e = n(t);
                    return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
                }
            }
        }

        function dl(t, e, n, i) {
            const r = {}, o = new WeakMap;

            function s(t) {
                const a = t.target;
                null !== a.index && e.remove(a.index);
                for (const t in a.attributes) e.remove(a.attributes[t]);
                a.removeEventListener("dispose", s), delete r[a.id];
                const l = o.get(a);
                l && (e.remove(l), o.delete(a)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
            }

            function a(t) {
                const n = [], i = t.index, r = t.attributes.position;
                let s = 0;
                if (null !== i) {
                    const t = i.array;
                    s = i.version;
                    for (let e = 0, i = t.length; e < i; e += 3) {
                        const i = t[e + 0], r = t[e + 1], o = t[e + 2];
                        n.push(i, r, r, o, o, i)
                    }
                } else {
                    const t = r.array;
                    s = r.version;
                    for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                        const t = e + 0, i = e + 1, r = e + 2;
                        n.push(t, i, i, r, r, t)
                    }
                }
                const a = new (Xr(n) > 65535 ? Ds : Os)(n, 1);
                a.version = s;
                const l = o.get(t);
                l && e.remove(l), o.set(t, a)
            }

            return {
                get: function (t, e) {
                    return !0 === r[e.id] || (e.addEventListener("dispose", s), r[e.id] = !0, n.memory.geometries++), e
                }, update: function (t) {
                    const n = t.attributes;
                    for (const t in n) e.update(n[t], 34962);
                    const i = t.morphAttributes;
                    for (const t in i) {
                        const n = i[t];
                        for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962)
                    }
                }, getWireframeAttribute: function (t) {
                    const e = o.get(t);
                    if (e) {
                        const n = t.index;
                        null !== n && e.version < n.version && a(t)
                    } else a(t);
                    return o.get(t)
                }
            }
        }

        function pl(t, e, n, i) {
            const r = i.isWebGL2;
            let o, s, a;
            this.setMode = function (t) {
                o = t
            }, this.setIndex = function (t) {
                s = t.type, a = t.bytesPerElement
            }, this.render = function (e, i) {
                t.drawElements(o, i, s, e * a), n.update(i, o, 1)
            }, this.renderInstances = function (i, l, c) {
                if (0 === c) return;
                let u, h;
                if (r) u = t, h = "drawElementsInstanced"; else if (u = e.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                u[h](o, l, s, i * a, c), n.update(l, o, c)
            }
        }

        function fl(t) {
            const e = {frame: 0, calls: 0, triangles: 0, points: 0, lines: 0};
            return {
                memory: {geometries: 0, textures: 0}, render: e, programs: null, autoReset: !0, reset: function () {
                    e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                }, update: function (t, n, i) {
                    switch (e.calls++, n) {
                        case 4:
                            e.triangles += i * (t / 3);
                            break;
                        case 1:
                            e.lines += i * (t / 2);
                            break;
                        case 3:
                            e.lines += i * (t - 1);
                            break;
                        case 2:
                            e.lines += i * t;
                            break;
                        case 0:
                            e.points += i * t;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                    }
                }
            }
        }

        class ml extends $r {
            constructor(t = null, e = 1, n = 1, i = 1) {
                super(null), this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                }, this.magFilter = or, this.minFilter = or, this.wrapR = ir, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
            }
        }

        function gl(t, e) {
            return t[0] - e[0]
        }

        function vl(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }

        function yl(t, e) {
            let n = 1;
            const i = e.isInterleavedBufferAttribute ? e.data.array : e.array;
            i instanceof Int8Array ? n = 127 : i instanceof Int16Array ? n = 32767 : i instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i), t.divideScalar(n)
        }

        function xl(t, e, n) {
            const i = {}, r = new Float32Array(8), o = new WeakMap, s = new oo, a = [];
            for (let t = 0; t < 8; t++) a[t] = [t, 0];
            return {
                update: function (l, c, u, h) {
                    const d = l.morphTargetInfluences;
                    if (!0 === e.isWebGL2) {
                        const i = c.morphAttributes.position.length;
                        let r = o.get(c);
                        if (void 0 === r || r.count !== i) {
                            void 0 !== r && r.texture.dispose();
                            const t = void 0 !== c.morphAttributes.normal, n = c.morphAttributes.position,
                                a = c.morphAttributes.normal || [], l = !0 === t ? 2 : 1;
                            let u = c.attributes.position.count * l, h = 1;
                            u > e.maxTextureSize && (h = Math.ceil(u / e.maxTextureSize), u = e.maxTextureSize);
                            const d = new Float32Array(u * h * 4 * i), p = new ml(d, u, h, i);
                            p.format = vr, p.type = pr;
                            const f = 4 * l;
                            for (let e = 0; e < i; e++) {
                                const i = n[e], r = a[e], o = u * h * 4 * e;
                                for (let e = 0; e < i.count; e++) {
                                    s.fromBufferAttribute(i, e), !0 === i.normalized && yl(s, i);
                                    const n = e * f;
                                    d[o + n + 0] = s.x, d[o + n + 1] = s.y, d[o + n + 2] = s.z, d[o + n + 3] = 0, !0 === t && (s.fromBufferAttribute(r, e), !0 === r.normalized && yl(s, r), d[o + n + 4] = s.x, d[o + n + 5] = s.y, d[o + n + 6] = s.z, d[o + n + 7] = 0)
                                }
                            }
                            r = {count: i, texture: p, size: new jr(u, h)}, o.set(c, r)
                        }
                        let a = 0;
                        for (let t = 0; t < d.length; t++) a += d[t];
                        const l = c.morphTargetsRelative ? 1 : 1 - a;
                        h.getUniforms().setValue(t, "morphTargetBaseInfluence", l), h.getUniforms().setValue(t, "morphTargetInfluences", d), h.getUniforms().setValue(t, "morphTargetsTexture", r.texture, n), h.getUniforms().setValue(t, "morphTargetsTextureSize", r.size)
                    } else {
                        const e = void 0 === d ? 0 : d.length;
                        let n = i[c.id];
                        if (void 0 === n || n.length !== e) {
                            n = [];
                            for (let t = 0; t < e; t++) n[t] = [t, 0];
                            i[c.id] = n
                        }
                        for (let t = 0; t < e; t++) {
                            const e = n[t];
                            e[0] = t, e[1] = d[t]
                        }
                        n.sort(vl);
                        for (let t = 0; t < 8; t++) t < e && n[t][1] ? (a[t][0] = n[t][0], a[t][1] = n[t][1]) : (a[t][0] = Number.MAX_SAFE_INTEGER, a[t][1] = 0);
                        a.sort(gl);
                        const o = c.morphAttributes.position, s = c.morphAttributes.normal;
                        let l = 0;
                        for (let t = 0; t < 8; t++) {
                            const e = a[t], n = e[0], i = e[1];
                            n !== Number.MAX_SAFE_INTEGER && i ? (o && c.getAttribute("morphTarget" + t) !== o[n] && c.setAttribute("morphTarget" + t, o[n]), s && c.getAttribute("morphNormal" + t) !== s[n] && c.setAttribute("morphNormal" + t, s[n]), r[t] = i, l += i) : (o && !0 === c.hasAttribute("morphTarget" + t) && c.deleteAttribute("morphTarget" + t), s && !0 === c.hasAttribute("morphNormal" + t) && c.deleteAttribute("morphNormal" + t), r[t] = 0)
                        }
                        const u = c.morphTargetsRelative ? 1 : 1 - l;
                        h.getUniforms().setValue(t, "morphTargetBaseInfluence", u), h.getUniforms().setValue(t, "morphTargetInfluences", r)
                    }
                }
            }
        }

        function _l(t, e, n, i) {
            let r = new WeakMap;

            function o(t) {
                const e = t.target;
                e.removeEventListener("dispose", o), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
            }

            return {
                update: function (t) {
                    const s = i.render.frame, a = t.geometry, l = e.get(t, a);
                    return r.get(l) !== s && (e.update(l), r.set(l, s)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", o) && t.addEventListener("dispose", o), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), l
                }, dispose: function () {
                    r = new WeakMap
                }
            }
        }

        ml.prototype.isDataTexture2DArray = !0;

        class bl extends $r {
            constructor(t = null, e = 1, n = 1, i = 1) {
                super(null), this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                }, this.magFilter = or, this.minFilter = or, this.wrapR = ir, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
            }
        }

        bl.prototype.isDataTexture3D = !0;
        const wl = new $r, Sl = new ml, Ml = new bl, Tl = new ya, El = [], Al = [], Pl = new Float32Array(16),
            Ll = new Float32Array(9), Cl = new Float32Array(4);

        function Rl(t, e, n) {
            const i = t[0];
            if (i <= 0 || i > 0) return t;
            const r = e * n;
            let o = El[r];
            if (void 0 === o && (o = new Float32Array(r), El[r] = o), 0 !== e) {
                i.toArray(o, 0);
                for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(o, r)
            }
            return o
        }

        function Il(t, e) {
            if (t.length !== e.length) return !1;
            for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
            return !0
        }

        function Ol(t, e) {
            for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
        }

        function Dl(t, e) {
            let n = Al[e];
            void 0 === n && (n = new Int32Array(e), Al[e] = n);
            for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
            return n
        }

        function zl(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
        }

        function kl(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y); else {
                if (Il(n, e)) return;
                t.uniform2fv(this.addr, e), Ol(n, e)
            }
        }

        function Nl(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z); else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b); else {
                if (Il(n, e)) return;
                t.uniform3fv(this.addr, e), Ol(n, e)
            }
        }

        function Bl(t, e) {
            const n = this.cache;
            if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w); else {
                if (Il(n, e)) return;
                t.uniform4fv(this.addr, e), Ol(n, e)
            }
        }

        function Fl(t, e) {
            const n = this.cache, i = e.elements;
            if (void 0 === i) {
                if (Il(n, e)) return;
                t.uniformMatrix2fv(this.addr, !1, e), Ol(n, e)
            } else {
                if (Il(n, i)) return;
                Cl.set(i), t.uniformMatrix2fv(this.addr, !1, Cl), Ol(n, i)
            }
        }

        function Ul(t, e) {
            const n = this.cache, i = e.elements;
            if (void 0 === i) {
                if (Il(n, e)) return;
                t.uniformMatrix3fv(this.addr, !1, e), Ol(n, e)
            } else {
                if (Il(n, i)) return;
                Ll.set(i), t.uniformMatrix3fv(this.addr, !1, Ll), Ol(n, i)
            }
        }

        function Hl(t, e) {
            const n = this.cache, i = e.elements;
            if (void 0 === i) {
                if (Il(n, e)) return;
                t.uniformMatrix4fv(this.addr, !1, e), Ol(n, e)
            } else {
                if (Il(n, i)) return;
                Pl.set(i), t.uniformMatrix4fv(this.addr, !1, Pl), Ol(n, i)
            }
        }

        function Vl(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
        }

        function Gl(t, e) {
            const n = this.cache;
            Il(n, e) || (t.uniform2iv(this.addr, e), Ol(n, e))
        }

        function Wl(t, e) {
            const n = this.cache;
            Il(n, e) || (t.uniform3iv(this.addr, e), Ol(n, e))
        }

        function jl(t, e) {
            const n = this.cache;
            Il(n, e) || (t.uniform4iv(this.addr, e), Ol(n, e))
        }

        function ql(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
        }

        function Xl(t, e) {
            const n = this.cache;
            Il(n, e) || (t.uniform2uiv(this.addr, e), Ol(n, e))
        }

        function Yl(t, e) {
            const n = this.cache;
            Il(n, e) || (t.uniform3uiv(this.addr, e), Ol(n, e))
        }

        function Jl(t, e) {
            const n = this.cache;
            Il(n, e) || (t.uniform4uiv(this.addr, e), Ol(n, e))
        }

        function Zl(t, e, n) {
            const i = this.cache, r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || wl, r)
        }

        function Ql(t, e, n) {
            const i = this.cache, r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || Ml, r)
        }

        function Kl(t, e, n) {
            const i = this.cache, r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || Tl, r)
        }

        function $l(t, e, n) {
            const i = this.cache, r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || Sl, r)
        }

        function tc(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function ec(t, e) {
            const n = Rl(e, this.size, 2);
            t.uniform2fv(this.addr, n)
        }

        function nc(t, e) {
            const n = Rl(e, this.size, 3);
            t.uniform3fv(this.addr, n)
        }

        function ic(t, e) {
            const n = Rl(e, this.size, 4);
            t.uniform4fv(this.addr, n)
        }

        function rc(t, e) {
            const n = Rl(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, n)
        }

        function oc(t, e) {
            const n = Rl(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, n)
        }

        function sc(t, e) {
            const n = Rl(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, n)
        }

        function ac(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function lc(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function cc(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function uc(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function hc(t, e) {
            t.uniform1uiv(this.addr, e)
        }

        function dc(t, e) {
            t.uniform2uiv(this.addr, e)
        }

        function pc(t, e) {
            t.uniform3uiv(this.addr, e)
        }

        function fc(t, e) {
            t.uniform4uiv(this.addr, e)
        }

        function mc(t, e, n) {
            const i = e.length, r = Dl(n, i);
            t.uniform1iv(this.addr, r);
            for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || wl, r[t])
        }

        function gc(t, e, n) {
            const i = e.length, r = Dl(n, i);
            t.uniform1iv(this.addr, r);
            for (let t = 0; t !== i; ++t) n.setTexture3D(e[t] || Ml, r[t])
        }

        function vc(t, e, n) {
            const i = e.length, r = Dl(n, i);
            t.uniform1iv(this.addr, r);
            for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || Tl, r[t])
        }

        function yc(t, e, n) {
            const i = e.length, r = Dl(n, i);
            t.uniform1iv(this.addr, r);
            for (let t = 0; t !== i; ++t) n.setTexture2DArray(e[t] || Sl, r[t])
        }

        function xc(t, e, n) {
            this.id = t, this.addr = n, this.cache = [], this.setValue = function (t) {
                switch (t) {
                    case 5126:
                        return zl;
                    case 35664:
                        return kl;
                    case 35665:
                        return Nl;
                    case 35666:
                        return Bl;
                    case 35674:
                        return Fl;
                    case 35675:
                        return Ul;
                    case 35676:
                        return Hl;
                    case 5124:
                    case 35670:
                        return Vl;
                    case 35667:
                    case 35671:
                        return Gl;
                    case 35668:
                    case 35672:
                        return Wl;
                    case 35669:
                    case 35673:
                        return jl;
                    case 5125:
                        return ql;
                    case 36294:
                        return Xl;
                    case 36295:
                        return Yl;
                    case 36296:
                        return Jl;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return Zl;
                    case 35679:
                    case 36299:
                    case 36307:
                        return Ql;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Kl;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return $l
                }
            }(e.type)
        }

        function _c(t, e, n) {
            this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function (t) {
                switch (t) {
                    case 5126:
                        return tc;
                    case 35664:
                        return ec;
                    case 35665:
                        return nc;
                    case 35666:
                        return ic;
                    case 35674:
                        return rc;
                    case 35675:
                        return oc;
                    case 35676:
                        return sc;
                    case 5124:
                    case 35670:
                        return ac;
                    case 35667:
                    case 35671:
                        return lc;
                    case 35668:
                    case 35672:
                        return cc;
                    case 35669:
                    case 35673:
                        return uc;
                    case 5125:
                        return hc;
                    case 36294:
                        return dc;
                    case 36295:
                        return pc;
                    case 36296:
                        return fc;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return mc;
                    case 35679:
                    case 36299:
                    case 36307:
                        return gc;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return vc;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return yc
                }
            }(e.type)
        }

        function bc(t) {
            this.id = t, this.seq = [], this.map = {}
        }

        _c.prototype.updateCache = function (t) {
            const e = this.cache;
            t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Ol(e, t)
        }, bc.prototype.setValue = function (t, e, n) {
            const i = this.seq;
            for (let r = 0, o = i.length; r !== o; ++r) {
                const o = i[r];
                o.setValue(t, e[o.id], n)
            }
        };
        const wc = /(\w+)(\])?(\[|\.)?/g;

        function Sc(t, e) {
            t.seq.push(e), t.map[e.id] = e
        }

        function Mc(t, e, n) {
            const i = t.name, r = i.length;
            for (wc.lastIndex = 0; ;) {
                const o = wc.exec(i), s = wc.lastIndex;
                let a = o[1];
                const l = "]" === o[2], c = o[3];
                if (l && (a |= 0), void 0 === c || "[" === c && s + 2 === r) {
                    Sc(n, void 0 === c ? new xc(a, t, e) : new _c(a, t, e));
                    break
                }
                {
                    let t = n.map[a];
                    void 0 === t && (t = new bc(a), Sc(n, t)), n = t
                }
            }
        }

        function Tc(t, e) {
            this.seq = [], this.map = {};
            const n = t.getProgramParameter(e, 35718);
            for (let i = 0; i < n; ++i) {
                const n = t.getActiveUniform(e, i);
                Mc(n, t.getUniformLocation(e, n.name), this)
            }
        }

        function Ec(t, e, n) {
            const i = t.createShader(e);
            return t.shaderSource(i, n), t.compileShader(i), i
        }

        Tc.prototype.setValue = function (t, e, n, i) {
            const r = this.map[e];
            void 0 !== r && r.setValue(t, n, i)
        }, Tc.prototype.setOptional = function (t, e, n) {
            const i = e[n];
            void 0 !== i && this.setValue(t, n, i)
        }, Tc.upload = function (t, e, n, i) {
            for (let r = 0, o = e.length; r !== o; ++r) {
                const o = e[r], s = n[o.id];
                !1 !== s.needsUpdate && o.setValue(t, s.value, i)
            }
        }, Tc.seqWithValue = function (t, e) {
            const n = [];
            for (let i = 0, r = t.length; i !== r; ++i) {
                const r = t[i];
                r.id in e && n.push(r)
            }
            return n
        };
        let Ac = 0;

        function Pc(t) {
            switch (t) {
                case Ar:
                    return ["Linear", "( value )"];
                case Pr:
                    return ["sRGB", "( value )"];
                case Cr:
                    return ["RGBE", "( value )"];
                case 3004:
                    return ["RGBM", "( value, 7.0 )"];
                case 3005:
                    return ["RGBM", "( value, 16.0 )"];
                case 3006:
                    return ["RGBD", "( value, 256.0 )"];
                case Lr:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                default:
                    return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
            }
        }

        function Lc(t, e, n) {
            const i = t.getShaderParameter(e, 35713), r = t.getShaderInfoLog(e).trim();
            return i && "" === r ? "" : n.toUpperCase() + "\n\n" + r + "\n\n" + function (t) {
                const e = t.split("\n");
                for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
                return e.join("\n")
            }(t.getShaderSource(e))
        }

        function Cc(t, e) {
            const n = Pc(e);
            return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
        }

        function Rc(t, e) {
            const n = Pc(e);
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        }

        function Ic(t, e) {
            let n;
            switch (e) {
                case 1:
                    n = "Linear";
                    break;
                case 2:
                    n = "Reinhard";
                    break;
                case 3:
                    n = "OptimizedCineon";
                    break;
                case 4:
                    n = "ACESFilmic";
                    break;
                case 5:
                    n = "Custom";
                    break;
                default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }

        function Oc(t) {
            return "" !== t
        }

        function Dc(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }

        function zc(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }

        const kc = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function Nc(t) {
            return t.replace(kc, Bc)
        }

        function Bc(t, e) {
            const n = Ca[e];
            if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
            return Nc(n)
        }

        const Fc = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
            Uc = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

        function Hc(t) {
            return t.replace(Uc, Gc).replace(Fc, Vc)
        }

        function Vc(t, e, n, i) {
            return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Gc(t, e, n, i)
        }

        function Gc(t, e, n, i) {
            let r = "";
            for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
            return r
        }

        function Wc(t) {
            let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
        }

        function jc(t, e, n, i) {
            const r = t.getContext(), o = n.defines;
            let s = n.vertexShader, a = n.fragmentShader;
            const l = function (t) {
                let e = "SHADOWMAP_TYPE_BASIC";
                return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
            }(n), c = function (t) {
                let e = "ENVMAP_TYPE_CUBE";
                if (t.envMap) switch (t.envMapMode) {
                    case Zi:
                    case Qi:
                        e = "ENVMAP_TYPE_CUBE";
                        break;
                    case tr:
                    case er:
                        e = "ENVMAP_TYPE_CUBE_UV"
                }
                return e
            }(n), u = function (t) {
                let e = "ENVMAP_MODE_REFLECTION";
                if (t.envMap) switch (t.envMapMode) {
                    case Qi:
                    case er:
                        e = "ENVMAP_MODE_REFRACTION"
                }
                return e
            }(n), h = function (t) {
                let e = "ENVMAP_BLENDING_NONE";
                if (t.envMap) switch (t.combine) {
                    case 0:
                        e = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case 1:
                        e = "ENVMAP_BLENDING_MIX";
                        break;
                    case 2:
                        e = "ENVMAP_BLENDING_ADD"
                }
                return e
            }(n), d = t.gammaFactor > 0 ? t.gammaFactor : 1, p = n.isWebGL2 ? "" : function (t) {
                return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Oc).join("\n")
            }(n), f = function (t) {
                const e = [];
                for (const n in t) {
                    const i = t[n];
                    !1 !== i && e.push("#define " + n + " " + i)
                }
                return e.join("\n")
            }(o), m = r.createProgram();
            let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (g = [f].filter(Oc).join("\n"), g.length > 0 && (g += "\n"), v = [p, f].filter(Oc).join("\n"), v.length > 0 && (v += "\n")) : (g = [Wc(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Oc).join("\n"), v = [p, Wc(n), "#define SHADER_NAME " + n.shaderName, f, "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Ca.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Ic("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.format === gr ? "#define OPAQUE" : "", Ca.encodings_pars_fragment, n.map ? Cc("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Cc("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Cc("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Cc("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.specularColorMap ? Cc("specularColorMapTexelToLinear", n.specularColorMapEncoding) : "", n.sheenColorMap ? Cc("sheenColorMapTexelToLinear", n.sheenColorMapEncoding) : "", n.lightMap ? Cc("lightMapTexelToLinear", n.lightMapEncoding) : "", Rc("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Oc).join("\n")), s = Nc(s), s = Dc(s, n), s = zc(s, n), a = Nc(a), a = Dc(a, n), a = zc(a, n), s = Hc(s), a = Hc(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", g = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", n.glslVersion === Dr ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === Dr ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
            const x = y + v + a, _ = Ec(r, 35633, y + g + s), b = Ec(r, 35632, x);
            if (r.attachShader(m, _), r.attachShader(m, b), void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), t.debug.checkShaderErrors) {
                const t = r.getProgramInfoLog(m).trim(), e = r.getShaderInfoLog(_).trim(),
                    n = r.getShaderInfoLog(b).trim();
                let i = !0, o = !0;
                if (!1 === r.getProgramParameter(m, 35714)) {
                    i = !1;
                    const e = Lc(r, _, "vertex"), n = Lc(r, b, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
                } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (o = !1);
                o && (this.diagnostics = {
                    runnable: i,
                    programLog: t,
                    vertexShader: {log: e, prefix: g},
                    fragmentShader: {log: n, prefix: v}
                })
            }
            let w, S;
            return r.deleteShader(_), r.deleteShader(b), this.getUniforms = function () {
                return void 0 === w && (w = new Tc(r, m)), w
            }, this.getAttributes = function () {
                return void 0 === S && (S = function (t, e) {
                    const n = {}, i = t.getProgramParameter(e, 35721);
                    for (let r = 0; r < i; r++) {
                        const i = t.getActiveAttrib(e, r), o = i.name;
                        let s = 1;
                        35674 === i.type && (s = 2), 35675 === i.type && (s = 3), 35676 === i.type && (s = 4), n[o] = {
                            type: i.type,
                            location: t.getAttribLocation(e, o),
                            locationSize: s
                        }
                    }
                    return n
                }(r, m)), S
            }, this.destroy = function () {
                i.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0
            }, this.name = n.shaderName, this.id = Ac++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = _, this.fragmentShader = b, this
        }

        function qc(t, e, n, i, r, o, s) {
            const a = [], l = r.isWebGL2, c = r.logarithmicDepthBuffer, u = r.floatVertexTextures,
                h = r.maxVertexUniforms, d = r.vertexTextures;
            let p = r.precision;
            const f = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "toon",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                },
                m = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoat", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", , "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "alphaTest", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "morphTargetsCount", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "format", "specularIntensityMap", "specularColorMap", "specularColorMapEncoding", "transmission", "transmissionMap", "thicknessMap", "sheen", "sheenColorMap", "sheenColorMapEncoding", "sheenRoughnessMap"];

            function g(t) {
                let e;
                return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = Ar, e
            }

            return {
                getParameters: function (o, a, m, v, y) {
                    const x = v.fog, _ = o.isMeshStandardMaterial ? v.environment : null,
                        b = (o.isMeshStandardMaterial ? n : e).get(o.envMap || _), w = f[o.type],
                        S = y.isSkinnedMesh ? function (t) {
                            const e = t.skeleton.bones;
                            if (u) return 1024;
                            {
                                const t = h, n = Math.floor((t - 20) / 4), i = Math.min(n, e.length);
                                return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i
                            }
                        }(y) : 0;
                    let M, T;
                    if (null !== o.precision && (p = r.getMaxPrecision(o.precision), p !== o.precision && console.warn("THREE.WebGLProgram.getParameters:", o.precision, "not supported, using", p, "instead.")), w) {
                        const t = Ia[w];
                        M = t.vertexShader, T = t.fragmentShader
                    } else M = o.vertexShader, T = o.fragmentShader;
                    const E = t.getRenderTarget(), A = o.alphaTest > 0, P = o.clearcoat > 0;
                    return {
                        isWebGL2: l,
                        shaderID: w,
                        shaderName: o.type,
                        vertexShader: M,
                        fragmentShader: T,
                        defines: o.defines,
                        isRawShaderMaterial: !0 === o.isRawShaderMaterial,
                        glslVersion: o.glslVersion,
                        precision: p,
                        instancing: !0 === y.isInstancedMesh,
                        instancingColor: !0 === y.isInstancedMesh && null !== y.instanceColor,
                        supportsVertexTextures: d,
                        outputEncoding: null !== E ? g(E.texture) : t.outputEncoding,
                        map: !!o.map,
                        mapEncoding: g(o.map),
                        matcap: !!o.matcap,
                        matcapEncoding: g(o.matcap),
                        envMap: !!b,
                        envMapMode: b && b.mapping,
                        envMapEncoding: g(b),
                        envMapCubeUV: !!b && (b.mapping === tr || b.mapping === er),
                        lightMap: !!o.lightMap,
                        lightMapEncoding: g(o.lightMap),
                        aoMap: !!o.aoMap,
                        emissiveMap: !!o.emissiveMap,
                        emissiveMapEncoding: g(o.emissiveMap),
                        bumpMap: !!o.bumpMap,
                        normalMap: !!o.normalMap,
                        objectSpaceNormalMap: 1 === o.normalMapType,
                        tangentSpaceNormalMap: 0 === o.normalMapType,
                        clearcoat: P,
                        clearcoatMap: P && !!o.clearcoatMap,
                        clearcoatRoughnessMap: P && !!o.clearcoatRoughnessMap,
                        clearcoatNormalMap: P && !!o.clearcoatNormalMap,
                        displacementMap: !!o.displacementMap,
                        roughnessMap: !!o.roughnessMap,
                        metalnessMap: !!o.metalnessMap,
                        specularMap: !!o.specularMap,
                        specularIntensityMap: !!o.specularIntensityMap,
                        specularColorMap: !!o.specularColorMap,
                        specularColorMapEncoding: g(o.specularColorMap),
                        alphaMap: !!o.alphaMap,
                        alphaTest: A,
                        gradientMap: !!o.gradientMap,
                        sheen: o.sheen > 0,
                        sheenColorMap: !!o.sheenColorMap,
                        sheenColorMapEncoding: g(o.sheenColorMap),
                        sheenRoughnessMap: !!o.sheenRoughnessMap,
                        transmission: o.transmission > 0,
                        transmissionMap: !!o.transmissionMap,
                        thicknessMap: !!o.thicknessMap,
                        combine: o.combine,
                        vertexTangents: !!o.normalMap && !!y.geometry && !!y.geometry.attributes.tangent,
                        vertexColors: o.vertexColors,
                        vertexAlphas: !0 === o.vertexColors && !!y.geometry && !!y.geometry.attributes.color && 4 === y.geometry.attributes.color.itemSize,
                        vertexUvs: !!o.map || !!o.bumpMap || !!o.normalMap || !!o.specularMap || !!o.alphaMap || !!o.emissiveMap || !!o.roughnessMap || !!o.metalnessMap || !!o.clearcoatMap || !!o.clearcoatRoughnessMap || !!o.clearcoatNormalMap || !!o.displacementMap || !!o.transmissionMap || !!o.thicknessMap || !!o.specularIntensityMap || !!o.specularColorMap || !!o.sheenColorMap || o.sheenRoughnessMap,
                        uvsVertexOnly: !(o.map || o.bumpMap || o.normalMap || o.specularMap || o.alphaMap || o.emissiveMap || o.roughnessMap || o.metalnessMap || o.clearcoatNormalMap || o.transmission > 0 || o.transmissionMap || o.thicknessMap || o.specularIntensityMap || o.specularColorMap || o.sheen > 0 || o.sheenColorMap || o.sheenRoughnessMap || !o.displacementMap),
                        fog: !!x,
                        useFog: o.fog,
                        fogExp2: x && x.isFogExp2,
                        flatShading: !!o.flatShading,
                        sizeAttenuation: o.sizeAttenuation,
                        logarithmicDepthBuffer: c,
                        skinning: !0 === y.isSkinnedMesh && S > 0,
                        maxBones: S,
                        useVertexTexture: u,
                        morphTargets: !!y.geometry && !!y.geometry.morphAttributes.position,
                        morphNormals: !!y.geometry && !!y.geometry.morphAttributes.normal,
                        morphTargetsCount: y.geometry && y.geometry.morphAttributes.position ? y.geometry.morphAttributes.position.length : 0,
                        numDirLights: a.directional.length,
                        numPointLights: a.point.length,
                        numSpotLights: a.spot.length,
                        numRectAreaLights: a.rectArea.length,
                        numHemiLights: a.hemi.length,
                        numDirLightShadows: a.directionalShadowMap.length,
                        numPointLightShadows: a.pointShadowMap.length,
                        numSpotLightShadows: a.spotShadowMap.length,
                        numClippingPlanes: s.numPlanes,
                        numClipIntersection: s.numIntersection,
                        format: o.format,
                        dithering: o.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && m.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: o.toneMapped ? t.toneMapping : 0,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: o.premultipliedAlpha,
                        doubleSided: 2 === o.side,
                        flipSided: 1 === o.side,
                        depthPacking: void 0 !== o.depthPacking && o.depthPacking,
                        index0AttributeName: o.index0AttributeName,
                        extensionDerivatives: o.extensions && o.extensions.derivatives,
                        extensionFragDepth: o.extensions && o.extensions.fragDepth,
                        extensionDrawBuffers: o.extensions && o.extensions.drawBuffers,
                        extensionShaderTextureLOD: o.extensions && o.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth: l || i.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: l || i.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: l || i.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: o.customProgramCacheKey()
                    }
                }, getProgramCacheKey: function (e) {
                    const n = [];
                    if (e.shaderID ? n.push(e.shaderID) : (n.push(Jr(e.fragmentShader)), n.push(Jr(e.vertexShader))), void 0 !== e.defines) for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                    if (!1 === e.isRawShaderMaterial) {
                        for (let t = 0; t < m.length; t++) n.push(e[m[t]]);
                        n.push(t.outputEncoding), n.push(t.gammaFactor)
                    }
                    return n.push(e.customProgramCacheKey), n.join()
                }, getUniforms: function (t) {
                    const e = f[t.type];
                    let n;
                    if (e) {
                        const t = Ia[e];
                        n = da.clone(t.uniforms)
                    } else n = t.uniforms;
                    return n
                }, acquireProgram: function (e, n) {
                    let i;
                    for (let t = 0, e = a.length; t < e; t++) {
                        const e = a[t];
                        if (e.cacheKey === n) {
                            i = e, ++i.usedTimes;
                            break
                        }
                    }
                    return void 0 === i && (i = new jc(t, n, e, o), a.push(i)), i
                }, releaseProgram: function (t) {
                    if (0 == --t.usedTimes) {
                        const e = a.indexOf(t);
                        a[e] = a[a.length - 1], a.pop(), t.destroy()
                    }
                }, programs: a
            }
        }

        function Xc() {
            let t = new WeakMap;
            return {
                get: function (e) {
                    let n = t.get(e);
                    return void 0 === n && (n = {}, t.set(e, n)), n
                }, remove: function (e) {
                    t.delete(e)
                }, update: function (e, n, i) {
                    t.get(e)[n] = i
                }, dispose: function () {
                    t = new WeakMap
                }
            }
        }

        function Yc(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function Jc(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function Zc(t) {
            const e = [];
            let n = 0;
            const i = [], r = [], o = [], s = {id: -1};

            function a(i, r, o, a, l, c) {
                let u = e[n];
                const h = t.get(o);
                return void 0 === u ? (u = {
                    id: i.id,
                    object: i,
                    geometry: r,
                    material: o,
                    program: h.program || s,
                    groupOrder: a,
                    renderOrder: i.renderOrder,
                    z: l,
                    group: c
                }, e[n] = u) : (u.id = i.id, u.object = i, u.geometry = r, u.material = o, u.program = h.program || s, u.groupOrder = a, u.renderOrder = i.renderOrder, u.z = l, u.group = c), n++, u
            }

            return {
                opaque: i, transmissive: r, transparent: o, init: function () {
                    n = 0, i.length = 0, r.length = 0, o.length = 0
                }, push: function (t, e, n, s, l, c) {
                    const u = a(t, e, n, s, l, c);
                    n.transmission > 0 ? r.push(u) : !0 === n.transparent ? o.push(u) : i.push(u)
                }, unshift: function (t, e, n, s, l, c) {
                    const u = a(t, e, n, s, l, c);
                    n.transmission > 0 ? r.unshift(u) : !0 === n.transparent ? o.unshift(u) : i.unshift(u)
                }, finish: function () {
                    for (let t = n, i = e.length; t < i; t++) {
                        const n = e[t];
                        if (null === n.id) break;
                        n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
                    }
                }, sort: function (t, e) {
                    i.length > 1 && i.sort(t || Yc), r.length > 1 && r.sort(e || Jc), o.length > 1 && o.sort(e || Jc)
                }
            }
        }

        function Qc(t) {
            let e = new WeakMap;
            return {
                get: function (n, i) {
                    let r;
                    return !1 === e.has(n) ? (r = new Zc(t), e.set(n, [r])) : i >= e.get(n).length ? (r = new Zc(t), e.get(n).push(r)) : r = e.get(n)[i], r
                }, dispose: function () {
                    e = new WeakMap
                }
            }
        }

        function Kc() {
            const t = {};
            return {
                get: function (e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    let n;
                    switch (e.type) {
                        case"DirectionalLight":
                            n = {direction: new oo, color: new Ps};
                            break;
                        case"SpotLight":
                            n = {
                                position: new oo,
                                direction: new oo,
                                color: new Ps,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case"PointLight":
                            n = {position: new oo, color: new Ps, distance: 0, decay: 0};
                            break;
                        case"HemisphereLight":
                            n = {direction: new oo, skyColor: new Ps, groundColor: new Ps};
                            break;
                        case"RectAreaLight":
                            n = {color: new Ps, position: new oo, halfWidth: new oo, halfHeight: new oo}
                    }
                    return t[e.id] = n, n
                }
            }
        }

        let $c = 0;

        function tu(t, e) {
            return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
        }

        function eu(t, e) {
            const n = new Kc, i = function () {
                const t = {};
                return {
                    get: function (e) {
                        if (void 0 !== t[e.id]) return t[e.id];
                        let n;
                        switch (e.type) {
                            case"DirectionalLight":
                            case"SpotLight":
                                n = {shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new jr};
                                break;
                            case"PointLight":
                                n = {
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new jr,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                }
                        }
                        return t[e.id] = n, n
                    }
                }
            }(), r = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadow: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            };
            for (let t = 0; t < 9; t++) r.probe.push(new oo);
            const o = new oo, s = new No, a = new No;
            return {
                setup: function (o, s) {
                    let a = 0, l = 0, c = 0;
                    for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                    let u = 0, h = 0, d = 0, p = 0, f = 0, m = 0, g = 0, v = 0;
                    o.sort(tu);
                    const y = !0 !== s ? Math.PI : 1;
                    for (let t = 0, e = o.length; t < e; t++) {
                        const e = o[t], s = e.color, x = e.intensity, _ = e.distance,
                            b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                        if (e.isAmbientLight) a += s.r * x * y, l += s.g * x * y, c += s.b * x * y; else if (e.isLightProbe) for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], x); else if (e.isDirectionalLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * y), e.castShadow) {
                                const t = e.shadow, n = i.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.directionalShadow[u] = n, r.directionalShadowMap[u] = b, r.directionalShadowMatrix[u] = e.shadow.matrix, m++
                            }
                            r.directional[u] = t, u++
                        } else if (e.isSpotLight) {
                            const t = n.get(e);
                            if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(s).multiplyScalar(x * y), t.distance = _, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) {
                                const t = e.shadow, n = i.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.spotShadow[d] = n, r.spotShadowMap[d] = b, r.spotShadowMatrix[d] = e.shadow.matrix, v++
                            }
                            r.spot[d] = t, d++
                        } else if (e.isRectAreaLight) {
                            const t = n.get(e);
                            t.color.copy(s).multiplyScalar(x), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), r.rectArea[p] = t, p++
                        } else if (e.isPointLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * y), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                                const t = e.shadow, n = i.get(e);
                                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, r.pointShadow[h] = n, r.pointShadowMap[h] = b, r.pointShadowMatrix[h] = e.shadow.matrix, g++
                            }
                            r.point[h] = t, h++
                        } else if (e.isHemisphereLight) {
                            const t = n.get(e);
                            t.skyColor.copy(e.color).multiplyScalar(x * y), t.groundColor.copy(e.groundColor).multiplyScalar(x * y), r.hemi[f] = t, f++
                        }
                    }
                    p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Ra.LTC_FLOAT_1, r.rectAreaLTC2 = Ra.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Ra.LTC_HALF_1, r.rectAreaLTC2 = Ra.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = a, r.ambient[1] = l, r.ambient[2] = c;
                    const x = r.hash;
                    x.directionalLength === u && x.pointLength === h && x.spotLength === d && x.rectAreaLength === p && x.hemiLength === f && x.numDirectionalShadows === m && x.numPointShadows === g && x.numSpotShadows === v || (r.directional.length = u, r.spot.length = d, r.rectArea.length = p, r.point.length = h, r.hemi.length = f, r.directionalShadow.length = m, r.directionalShadowMap.length = m, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = m, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = v, x.directionalLength = u, x.pointLength = h, x.spotLength = d, x.rectAreaLength = p, x.hemiLength = f, x.numDirectionalShadows = m, x.numPointShadows = g, x.numSpotShadows = v, r.version = $c++)
                }, setupView: function (t, e) {
                    let n = 0, i = 0, l = 0, c = 0, u = 0;
                    const h = e.matrixWorldInverse;
                    for (let e = 0, d = t.length; e < d; e++) {
                        const d = t[e];
                        if (d.isDirectionalLight) {
                            const t = r.directional[n];
                            t.direction.setFromMatrixPosition(d.matrixWorld), o.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(h), n++
                        } else if (d.isSpotLight) {
                            const t = r.spot[l];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), t.direction.setFromMatrixPosition(d.matrixWorld), o.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(h), l++
                        } else if (d.isRectAreaLight) {
                            const t = r.rectArea[c];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), a.identity(), s.copy(d.matrixWorld), s.premultiply(h), a.extractRotation(s), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), c++
                        } else if (d.isPointLight) {
                            const t = r.point[i];
                            t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), i++
                        } else if (d.isHemisphereLight) {
                            const t = r.hemi[u];
                            t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(h), t.direction.normalize(), u++
                        }
                    }
                }, state: r
            }
        }

        function nu(t, e) {
            const n = new eu(t, e), i = [], r = [];
            return {
                init: function () {
                    i.length = 0, r.length = 0
                }, state: {lightsArray: i, shadowsArray: r, lights: n}, setupLights: function (t) {
                    n.setup(i, t)
                }, setupLightsView: function (t) {
                    n.setupView(i, t)
                }, pushLight: function (t) {
                    i.push(t)
                }, pushShadow: function (t) {
                    r.push(t)
                }
            }
        }

        function iu(t, e) {
            let n = new WeakMap;
            return {
                get: function (i, r = 0) {
                    let o;
                    return !1 === n.has(i) ? (o = new nu(t, e), n.set(i, [o])) : r >= n.get(i).length ? (o = new nu(t, e), n.get(i).push(o)) : o = n.get(i)[r], o
                }, dispose: function () {
                    n = new WeakMap
                }
            }
        }

        class ru extends bs {
            constructor(t) {
                super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
            }

            copy(t) {
                return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
            }
        }

        ru.prototype.isMeshDepthMaterial = !0;

        class ou extends bs {
            constructor(t) {
                super(), this.type = "MeshDistanceMaterial", this.referencePosition = new oo, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
            }

            copy(t) {
                return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
            }
        }

        ou.prototype.isMeshDistanceMaterial = !0;

        function su(t, e, n) {
            let i = new Ea;
            const r = new jr, o = new jr, s = new eo, a = new ru({depthPacking: 3201}), l = new ou, c = {},
                u = n.maxTextureSize, h = {0: 1, 1: 0, 2: 2}, d = new pa({
                    defines: {VSM_SAMPLES: 8},
                    uniforms: {shadow_pass: {value: null}, resolution: {value: new jr}, radius: {value: 4}},
                    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                }), p = d.clone();
            p.defines.HORIZONTAL_PASS = 1;
            const f = new Gs;
            f.setAttribute("position", new Is(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            const m = new aa(f, d), g = this;

            function v(n, i) {
                const r = e.update(m);
                d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples, p.defines.VSM_SAMPLES = n.blurSamples, d.needsUpdate = !0, p.needsUpdate = !0), d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, d, m, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, p, m, null)
            }

            function y(e, n, i, r, o, s, u) {
                let d = null;
                const p = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                if (d = void 0 !== p ? p : !0 === r.isPointLight ? l : a, t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
                    const t = d.uuid, e = i.uuid;
                    let n = c[t];
                    void 0 === n && (n = {}, c[t] = n);
                    let r = n[e];
                    void 0 === r && (r = d.clone(), n[e] = r), d = r
                }
                return d.visible = i.visible, d.wireframe = i.wireframe, d.side = 3 === u ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : h[i.side], d.alphaMap = i.alphaMap, d.alphaTest = i.alphaTest, d.clipShadows = i.clipShadows, d.clippingPlanes = i.clippingPlanes, d.clipIntersection = i.clipIntersection, d.displacementMap = i.displacementMap, d.displacementScale = i.displacementScale, d.displacementBias = i.displacementBias, d.wireframeLinewidth = i.wireframeLinewidth, d.linewidth = i.linewidth, !0 === r.isPointLight && !0 === d.isMeshDistanceMaterial && (d.referencePosition.setFromMatrixPosition(r.matrixWorld), d.nearDistance = o, d.farDistance = s), d
            }

            function x(n, r, o, s, a) {
                if (!1 === n.visible) return;
                if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === a) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                    const i = e.update(n), r = n.material;
                    if (Array.isArray(r)) {
                        const e = i.groups;
                        for (let l = 0, c = e.length; l < c; l++) {
                            const c = e[l], u = r[c.materialIndex];
                            if (u && u.visible) {
                                const e = y(n, 0, u, s, o.near, o.far, a);
                                t.renderBufferDirect(o, null, i, e, n, c)
                            }
                        }
                    } else if (r.visible) {
                        const e = y(n, 0, r, s, o.near, o.far, a);
                        t.renderBufferDirect(o, null, i, e, n, null)
                    }
                }
                const l = n.children;
                for (let t = 0, e = l.length; t < e; t++) x(l[t], r, o, s, a)
            }

            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (e, n, a) {
                if (!1 === g.enabled) return;
                if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
                if (0 === e.length) return;
                const l = t.getRenderTarget(), c = t.getActiveCubeFace(), h = t.getActiveMipmapLevel(), d = t.state;
                d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                for (let l = 0, c = e.length; l < c; l++) {
                    const c = e[l], h = c.shadow;
                    if (void 0 === h) {
                        console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                        continue
                    }
                    if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
                    r.copy(h.mapSize);
                    const p = h.getFrameExtents();
                    if (r.multiply(p), o.copy(h.mapSize), (r.x > u || r.y > u) && (r.x > u && (o.x = Math.floor(u / p.x), r.x = o.x * p.x, h.mapSize.x = o.x), r.y > u && (o.y = Math.floor(u / p.y), r.y = o.y * p.y, h.mapSize.y = o.y)), null === h.map && !h.isPointLightShadow && 3 === this.type) {
                        const t = {minFilter: lr, magFilter: lr, format: vr};
                        h.map = new no(r.x, r.y, t), h.map.texture.name = c.name + ".shadowMap", h.mapPass = new no(r.x, r.y, t), h.camera.updateProjectionMatrix()
                    }
                    if (null === h.map) {
                        const t = {minFilter: or, magFilter: or, format: vr};
                        h.map = new no(r.x, r.y, t), h.map.texture.name = c.name + ".shadowMap", h.camera.updateProjectionMatrix()
                    }
                    t.setRenderTarget(h.map), t.clear();
                    const f = h.getViewportCount();
                    for (let t = 0; t < f; t++) {
                        const e = h.getViewport(t);
                        s.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w), d.viewport(s), h.updateMatrices(c, t), i = h.getFrustum(), x(n, a, h.camera, c, this.type)
                    }
                    h.isPointLightShadow || 3 !== this.type || v(h, a), h.needsUpdate = !1
                }
                g.needsUpdate = !1, t.setRenderTarget(l, c, h)
            }
        }

        function au(t, e, n) {
            const i = n.isWebGL2;
            const r = new function () {
                let e = !1;
                const n = new eo;
                let i = null;
                const r = new eo(0, 0, 0, 0);
                return {
                    setMask: function (n) {
                        i === n || e || (t.colorMask(n, n, n, n), i = n)
                    }, setLocked: function (t) {
                        e = t
                    }, setClear: function (e, i, o, s, a) {
                        !0 === a && (e *= s, i *= s, o *= s), n.set(e, i, o, s), !1 === r.equals(n) && (t.clearColor(e, i, o, s), r.copy(n))
                    }, reset: function () {
                        e = !1, i = null, r.set(-1, 0, 0, 0)
                    }
                }
            }, o = new function () {
                let e = !1, n = null, i = null, r = null;
                return {
                    setTest: function (t) {
                        t ? k(2929) : N(2929)
                    }, setMask: function (i) {
                        n === i || e || (t.depthMask(i), n = i)
                    }, setFunc: function (e) {
                        if (i !== e) {
                            if (e) switch (e) {
                                case 0:
                                    t.depthFunc(512);
                                    break;
                                case 1:
                                    t.depthFunc(519);
                                    break;
                                case 2:
                                    t.depthFunc(513);
                                    break;
                                case 3:
                                default:
                                    t.depthFunc(515);
                                    break;
                                case 4:
                                    t.depthFunc(514);
                                    break;
                                case 5:
                                    t.depthFunc(518);
                                    break;
                                case 6:
                                    t.depthFunc(516);
                                    break;
                                case 7:
                                    t.depthFunc(517)
                            } else t.depthFunc(515);
                            i = e
                        }
                    }, setLocked: function (t) {
                        e = t
                    }, setClear: function (e) {
                        r !== e && (t.clearDepth(e), r = e)
                    }, reset: function () {
                        e = !1, n = null, i = null, r = null
                    }
                }
            }, s = new function () {
                let e = !1, n = null, i = null, r = null, o = null, s = null, a = null, l = null, c = null;
                return {
                    setTest: function (t) {
                        e || (t ? k(2960) : N(2960))
                    }, setMask: function (i) {
                        n === i || e || (t.stencilMask(i), n = i)
                    }, setFunc: function (e, n, s) {
                        i === e && r === n && o === s || (t.stencilFunc(e, n, s), i = e, r = n, o = s)
                    }, setOp: function (e, n, i) {
                        s === e && a === n && l === i || (t.stencilOp(e, n, i), s = e, a = n, l = i)
                    }, setLocked: function (t) {
                        e = t
                    }, setClear: function (e) {
                        c !== e && (t.clearStencil(e), c = e)
                    }, reset: function () {
                        e = !1, n = null, i = null, r = null, o = null, s = null, a = null, l = null, c = null
                    }
                }
            };
            let a = {}, l = {}, c = null, u = !1, h = null, d = null, p = null, f = null, m = null, g = null, v = null,
                y = !1, x = null, _ = null, b = null, w = null, S = null;
            const M = t.getParameter(35661);
            let T = !1, E = 0;
            const A = t.getParameter(7938);
            -1 !== A.indexOf("WebGL") ? (E = parseFloat(/^WebGL (\d)/.exec(A)[1]), T = E >= 1) : -1 !== A.indexOf("OpenGL ES") && (E = parseFloat(/^OpenGL ES (\d)/.exec(A)[1]), T = E >= 2);
            let P = null, L = {};
            const C = t.getParameter(3088), R = t.getParameter(2978), I = (new eo).fromArray(C),
                O = (new eo).fromArray(R);

            function D(e, n, i) {
                const r = new Uint8Array(4), o = t.createTexture();
                t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
                return o
            }

            const z = {};

            function k(e) {
                !0 !== a[e] && (t.enable(e), a[e] = !0)
            }

            function N(e) {
                !1 !== a[e] && (t.disable(e), a[e] = !1)
            }

            z[3553] = D(3553, 3553, 1), z[34067] = D(34067, 34069, 6), r.setClear(0, 0, 0, 1), o.setClear(1), s.setClear(0), k(2929), o.setFunc(3), H(!1), V(1), k(2884), U(0);
            const B = {[Ji]: 32774, 101: 32778, 102: 32779};
            if (i) B[103] = 32775, B[104] = 32776; else {
                const t = e.get("EXT_blend_minmax");
                null !== t && (B[103] = t.MIN_EXT, B[104] = t.MAX_EXT)
            }
            const F = {
                200: 0,
                201: 1,
                202: 768,
                204: 770,
                210: 776,
                208: 774,
                206: 772,
                203: 769,
                205: 771,
                209: 775,
                207: 773
            };

            function U(e, n, i, r, o, s, a, l) {
                if (0 !== e) {
                    if (!1 === u && (k(3042), u = !0), 5 === e) o = o || n, s = s || i, a = a || r, n === d && o === m || (t.blendEquationSeparate(B[n], B[o]), d = n, m = o), i === p && r === f && s === g && a === v || (t.blendFuncSeparate(F[i], F[r], F[s], F[a]), p = i, f = r, g = s, v = a), h = e, y = null; else if (e !== h || l !== y) {
                        if (d === Ji && m === Ji || (t.blendEquation(32774), d = Ji, m = Ji), l) switch (e) {
                            case 1:
                                t.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case 2:
                                t.blendFunc(1, 1);
                                break;
                            case 3:
                                t.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case 4:
                                t.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        } else switch (e) {
                            case 1:
                                t.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case 2:
                                t.blendFunc(770, 1);
                                break;
                            case 3:
                                t.blendFunc(0, 769);
                                break;
                            case 4:
                                t.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                        p = null, f = null, g = null, v = null, h = e, y = l
                    }
                } else !0 === u && (N(3042), u = !1)
            }

            function H(e) {
                x !== e && (e ? t.frontFace(2304) : t.frontFace(2305), x = e)
            }

            function V(e) {
                0 !== e ? (k(2884), e !== _ && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : N(2884), _ = e
            }

            function G(e, n, i) {
                e ? (k(32823), w === n && S === i || (t.polygonOffset(n, i), w = n, S = i)) : N(32823)
            }

            function W(e) {
                void 0 === e && (e = 33984 + M - 1), P !== e && (t.activeTexture(e), P = e)
            }

            return {
                buffers: {color: r, depth: o, stencil: s}, enable: k, disable: N, bindFramebuffer: function (e, n) {
                    return l[e] !== n && (t.bindFramebuffer(e, n), l[e] = n, i && (36009 === e && (l[36160] = n), 36160 === e && (l[36009] = n)), !0)
                }, useProgram: function (e) {
                    return c !== e && (t.useProgram(e), c = e, !0)
                }, setBlending: U, setMaterial: function (t, e) {
                    2 === t.side ? N(2884) : k(2884);
                    let n = 1 === t.side;
                    e && (n = !n), H(n), 1 === t.blending && !1 === t.transparent ? U(0) : U(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), o.setFunc(t.depthFunc), o.setTest(t.depthTest), o.setMask(t.depthWrite), r.setMask(t.colorWrite);
                    const i = t.stencilWrite;
                    s.setTest(i), i && (s.setMask(t.stencilWriteMask), s.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), s.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), G(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? k(32926) : N(32926)
                }, setFlipSided: H, setCullFace: V, setLineWidth: function (e) {
                    e !== b && (T && t.lineWidth(e), b = e)
                }, setPolygonOffset: G, setScissorTest: function (t) {
                    t ? k(3089) : N(3089)
                }, activeTexture: W, bindTexture: function (e, n) {
                    null === P && W();
                    let i = L[P];
                    void 0 === i && (i = {
                        type: void 0,
                        texture: void 0
                    }, L[P] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || z[e]), i.type = e, i.texture = n)
                }, unbindTexture: function () {
                    const e = L[P];
                    void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                }, compressedTexImage2D: function () {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                }, texImage2D: function () {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                }, texImage3D: function () {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                }, texStorage2D: function () {
                    try {
                        t.texStorage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                }, texSubImage2D: function () {
                    try {
                        t.texSubImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                }, scissor: function (e) {
                    !1 === I.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), I.copy(e))
                }, viewport: function (e) {
                    !1 === O.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), O.copy(e))
                }, reset: function () {
                    t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === i && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), a = {}, P = null, L = {}, l = {}, c = null, u = !1, h = null, d = null, p = null, f = null, m = null, g = null, v = null, y = !1, x = null, _ = null, b = null, w = null, S = null, I.set(0, 0, t.canvas.width, t.canvas.height), O.set(0, 0, t.canvas.width, t.canvas.height), r.reset(), o.reset(), s.reset()
                }
            }
        }

        function lu(t, e, n, i, r, o, s) {
            const a = r.isWebGL2, l = r.maxTextures, c = r.maxCubemapSize, u = r.maxTextureSize, h = r.maxSamples,
                d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : void 0,
                p = new WeakMap;
            let f, m = !1;
            try {
                m = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
            } catch (t) {
            }

            function g(t, e) {
                return m ? new OffscreenCanvas(t, e) : Yr("canvas")
            }

            function v(t, e, n, i) {
                let r = 1;
                if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                        const i = e ? Wr : Math.floor, o = i(r * t.width), s = i(r * t.height);
                        void 0 === f && (f = g(o, s));
                        const a = n ? g(o, s) : f;
                        a.width = o, a.height = s;
                        return a.getContext("2d").drawImage(t, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + s + ")."), a
                    }
                    return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                }
                return t
            }

            function y(t) {
                return Gr(t.width) && Gr(t.height)
            }

            function x(t, e) {
                return t.generateMipmaps && e && t.minFilter !== or && t.minFilter !== lr
            }

            function _(e) {
                t.generateMipmap(e)
            }

            function b(n, i, r) {
                if (!1 === a) return i;
                if (null !== n) {
                    if (void 0 !== t[n]) return t[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let o = i;
                return 6403 === i && (5126 === r && (o = 33326), 5131 === r && (o = 33325), 5121 === r && (o = 33321)), 6407 === i && (5126 === r && (o = 34837), 5131 === r && (o = 34843), 5121 === r && (o = 32849)), 6408 === i && (5126 === r && (o = 34836), 5131 === r && (o = 34842), 5121 === r && (o = 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o
            }

            function w(t) {
                return t === or || t === sr || t === ar ? 9728 : 9729
            }

            function S(e) {
                const n = e.target;
                n.removeEventListener("dispose", S), function (e) {
                    const n = i.get(e);
                    if (void 0 === n.__webglInit) return;
                    t.deleteTexture(n.__webglTexture), i.remove(e)
                }(n), n.isVideoTexture && p.delete(n), s.memory.textures--
            }

            function M(e) {
                const n = e.target;
                n.removeEventListener("dispose", M), function (e) {
                    const n = e.texture, r = i.get(e), o = i.get(n);
                    if (!e) return;
                    void 0 !== o.__webglTexture && (t.deleteTexture(o.__webglTexture), s.memory.textures--);
                    e.depthTexture && e.depthTexture.dispose();
                    if (e.isWebGLCubeRenderTarget) for (let e = 0; e < 6; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]); else t.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                    if (e.isWebGLMultipleRenderTargets) for (let e = 0, r = n.length; e < r; e++) {
                        const r = i.get(n[e]);
                        r.__webglTexture && (t.deleteTexture(r.__webglTexture), s.memory.textures--), i.remove(n[e])
                    }
                    i.remove(n), i.remove(e)
                }(n)
            }

            let T = 0;

            function E(t, e) {
                const r = i.get(t);
                if (t.isVideoTexture && function (t) {
                    const e = s.render.frame;
                    p.get(t) !== e && (p.set(t, e), t.update())
                }(t), t.version > 0 && r.__version !== t.version) {
                    const n = t.image;
                    if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else {
                        if (!1 !== n.complete) return void I(r, t, e);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture)
            }

            function A(e, r) {
                const s = i.get(e);
                e.version > 0 && s.__version !== e.version ? function (e, i, r) {
                    if (6 !== i.image.length) return;
                    R(e, i), n.activeTexture(33984 + r), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
                    const s = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
                        l = i.image[0] && i.image[0].isDataTexture, u = [];
                    for (let t = 0; t < 6; t++) u[t] = s || l ? l ? i.image[t].image : i.image[t] : v(i.image[t], !1, !0, c);
                    const h = y(u[0]) || a, d = o.convert(i.format), p = o.convert(i.type),
                        f = b(i.internalFormat, d, p, i.encoding);
                    let m;
                    if (C(34067, i, h), s) for (let t = 0; t < 6; t++) {
                        m = u[t].mipmaps;
                        for (let e = 0; e < m.length; e++) {
                            const r = m[e];
                            i.format !== vr && i.format !== gr ? null !== d ? n.compressedTexImage2D(34069 + t, e, f, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, f, r.width, r.height, 0, d, p, r.data)
                        }
                    } else {
                        m = i.mipmaps;
                        for (let t = 0; t < 6; t++) if (l) {
                            n.texImage2D(34069 + t, 0, f, u[t].width, u[t].height, 0, d, p, u[t].data);
                            for (let e = 0; e < m.length; e++) {
                                const i = m[e].image[t].image;
                                n.texImage2D(34069 + t, e + 1, f, i.width, i.height, 0, d, p, i.data)
                            }
                        } else {
                            n.texImage2D(34069 + t, 0, f, d, p, u[t]);
                            for (let e = 0; e < m.length; e++) {
                                const i = m[e];
                                n.texImage2D(34069 + t, e + 1, f, d, p, i.image[t])
                            }
                        }
                    }
                    x(i, h) && _(34067);
                    e.__version = i.version, i.onUpdate && i.onUpdate(i)
                }(s, e, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, s.__webglTexture))
            }

            const P = {[nr]: 10497, [ir]: 33071, [rr]: 33648},
                L = {[or]: 9728, [sr]: 9984, [ar]: 9986, [lr]: 9729, 1007: 9985, [cr]: 9987};

            function C(n, o, s) {
                if (s ? (t.texParameteri(n, 10242, P[o.wrapS]), t.texParameteri(n, 10243, P[o.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, P[o.wrapR]), t.texParameteri(n, 10240, L[o.magFilter]), t.texParameteri(n, 10241, L[o.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), o.wrapS === ir && o.wrapT === ir || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, w(o.magFilter)), t.texParameteri(n, 10241, w(o.minFilter)), o.minFilter !== or && o.minFilter !== lr && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
                    const s = e.get("EXT_texture_filter_anisotropic");
                    if (o.type === pr && !1 === e.has("OES_texture_float_linear")) return;
                    if (!1 === a && o.type === fr && !1 === e.has("OES_texture_half_float_linear")) return;
                    (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (t.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), i.get(o).__currentAnisotropy = o.anisotropy)
                }
            }

            function R(e, n) {
                void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", S), e.__webglTexture = t.createTexture(), s.memory.textures++)
            }

            function I(e, i, r) {
                let s = 3553;
                i.isDataTexture2DArray && (s = 35866), i.isDataTexture3D && (s = 32879), R(e, i), n.activeTexture(33984 + r), n.bindTexture(s, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
                const l = function (t) {
                    return !a && (t.wrapS !== ir || t.wrapT !== ir || t.minFilter !== or && t.minFilter !== lr)
                }(i) && !1 === y(i.image), c = v(i.image, l, !1, u), h = y(c) || a, d = o.convert(i.format);
                let p, f = o.convert(i.type), m = b(i.internalFormat, d, f, i.encoding);
                C(s, i, h);
                const g = i.mipmaps;
                if (i.isDepthTexture) m = 6402, a ? m = i.type === pr ? 36012 : i.type === dr ? 33190 : i.type === mr ? 35056 : 33189 : i.type === pr && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === yr && 6402 === m && i.type !== hr && i.type !== dr && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = hr, f = o.convert(i.type)), i.format === xr && 6402 === m && (m = 34041, i.type !== mr && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = mr, f = o.convert(i.type))), n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null); else if (i.isDataTexture) if (g.length > 0 && h) {
                    for (let t = 0, e = g.length; t < e; t++) p = g[t], n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                    i.generateMipmaps = !1
                } else n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data); else if (i.isCompressedTexture) for (let t = 0, e = g.length; t < e; t++) p = g[t], i.format !== vr && i.format !== gr ? null !== d ? n.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data); else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, m, c.width, c.height, c.depth, 0, d, f, c.data); else if (i.isDataTexture3D) n.texImage3D(32879, 0, m, c.width, c.height, c.depth, 0, d, f, c.data); else {
                    const t = function (t, e, n) {
                        return !0 === x(t, n) ? Math.log2(Math.max(e.width, e.height)) + 1 : t.mipmaps.length > 0 ? t.mipmaps.length : 1
                    }(i, c, h), r = a && !0 !== i.isVideoTexture, o = void 0 === e.__version;
                    if (g.length > 0 && h) {
                        r && o && n.texStorage2D(3553, t, m, g[0].width, g[0].height);
                        for (let t = 0, e = g.length; t < e; t++) p = g[t], r ? n.texSubImage2D(3553, t, 0, 0, d, f, p) : n.texImage2D(3553, t, m, d, f, p);
                        i.generateMipmaps = !1
                    } else r ? (o && n.texStorage2D(3553, t, m, c.width, c.height), n.texSubImage2D(3553, 0, 0, 0, d, f, c)) : n.texImage2D(3553, 0, m, d, f, c)
                }
                x(i, h) && _(s), e.__version = i.version, i.onUpdate && i.onUpdate(i)
            }

            function O(e, r, s, a, l) {
                const c = o.convert(s.format), u = o.convert(s.type), h = b(s.internalFormat, c, u, s.encoding);
                i.get(r).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, h, r.width, r.height, r.depth, 0, c, u, null) : n.texImage2D(l, 0, h, r.width, r.height, 0, c, u, null)), n.bindFramebuffer(36160, e), r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, a, l, i.get(s).__webglTexture, 0, k(r)) : t.framebufferTexture2D(36160, a, l, i.get(s).__webglTexture, 0), n.bindFramebuffer(36160, null)
            }

            function D(e, n, i) {
                if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                    let r = 33189;
                    if (i || n.useRenderToTexture) {
                        const e = n.depthTexture;
                        e && e.isDepthTexture && (e.type === pr ? r = 36012 : e.type === dr && (r = 33190));
                        const i = k(n);
                        n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, i, r, n.width, n.height) : t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                    } else t.renderbufferStorage(36161, r, n.width, n.height);
                    t.framebufferRenderbuffer(36160, 36096, 36161, e)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    const r = k(n);
                    i && n.useRenderbuffer ? t.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height) : n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, r, 35056, n.width, n.height) : t.renderbufferStorage(36161, 34041, n.width, n.height), t.framebufferRenderbuffer(36160, 33306, 36161, e)
                } else {
                    const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture, r = o.convert(e.format),
                        s = o.convert(e.type), a = b(e.internalFormat, r, s, e.encoding), l = k(n);
                    i && n.useRenderbuffer ? t.renderbufferStorageMultisample(36161, l, a, n.width, n.height) : n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, l, a, n.width, n.height) : t.renderbufferStorage(36161, a, n.width, n.height)
                }
                t.bindRenderbuffer(36161, null)
            }

            function z(e) {
                const r = i.get(e), o = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                    if (o) throw new Error("target.depthTexture not supported in Cube render targets");
                    !function (e, r) {
                        if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(36160, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), E(r.depthTexture, 0);
                        const o = i.get(r.depthTexture).__webglTexture, s = k(r);
                        if (r.depthTexture.format === yr) r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, o, 0, s) : t.framebufferTexture2D(36160, 36096, 3553, o, 0); else {
                            if (r.depthTexture.format !== xr) throw new Error("Unknown depthTexture format");
                            r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, o, 0, s) : t.framebufferTexture2D(36160, 33306, 3553, o, 0)
                        }
                    }(r.__webglFramebuffer, e)
                } else if (o) {
                    r.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), D(r.__webglDepthbuffer[i], e, !1)
                } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), D(r.__webglDepthbuffer, e, !1);
                n.bindFramebuffer(36160, null)
            }

            function k(t) {
                return a && (t.useRenderbuffer || t.useRenderToTexture) ? Math.min(h, t.samples) : 0
            }

            let N = !1, B = !1;
            this.allocateTextureUnit = function () {
                const t = T;
                return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), T += 1, t
            }, this.resetTextureUnits = function () {
                T = 0
            }, this.setTexture2D = E, this.setTexture2DArray = function (t, e) {
                const r = i.get(t);
                t.version > 0 && r.__version !== t.version ? I(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture))
            }, this.setTexture3D = function (t, e) {
                const r = i.get(t);
                t.version > 0 && r.__version !== t.version ? I(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture))
            }, this.setTextureCube = A, this.rebindTextures = function (t, e, n) {
                const r = i.get(t);
                void 0 !== e && O(r.__webglFramebuffer, t, t.texture, 36064, 3553), void 0 !== n && z(t)
            }, this.setupRenderTarget = function (e) {
                const l = e.texture, c = i.get(e), u = i.get(l);
                e.addEventListener("dispose", M), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === u.__webglTexture && (u.__webglTexture = t.createTexture()), u.__version = l.version, s.memory.textures++);
                const h = !0 === e.isWebGLCubeRenderTarget, d = !0 === e.isWebGLMultipleRenderTargets,
                    p = l.isDataTexture3D || l.isDataTexture2DArray, f = y(e) || a;
                if (!a || l.format !== gr || l.type !== pr && l.type !== fr || (l.format = vr, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), h) {
                    c.__webglFramebuffer = [];
                    for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer()
                } else if (c.__webglFramebuffer = t.createFramebuffer(), d) if (r.drawBuffers) {
                    const n = e.texture;
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = i.get(n[e]);
                        void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(), s.memory.textures++)
                    }
                } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); else if (e.useRenderbuffer) if (a) {
                    c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                    const i = o.convert(l.format), r = o.convert(l.type), s = b(l.internalFormat, i, r, l.encoding),
                        a = k(e);
                    t.renderbufferStorageMultisample(36161, a, s, e.width, e.height), n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), D(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                if (h) {
                    n.bindTexture(34067, u.__webglTexture), C(34067, l, f);
                    for (let t = 0; t < 6; t++) O(c.__webglFramebuffer[t], e, l, 36064, 34069 + t);
                    x(l, f) && _(34067), n.unbindTexture()
                } else if (d) {
                    const t = e.texture;
                    for (let r = 0, o = t.length; r < o; r++) {
                        const o = t[r], s = i.get(o);
                        n.bindTexture(3553, s.__webglTexture), C(3553, o, f), O(c.__webglFramebuffer, e, o, 36064 + r, 3553), x(o, f) && _(3553)
                    }
                    n.unbindTexture()
                } else {
                    let t = 3553;
                    if (p) if (a) {
                        t = l.isDataTexture3D ? 32879 : 35866
                    } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
                    n.bindTexture(t, u.__webglTexture), C(t, l, f), O(c.__webglFramebuffer, e, l, 36064, t), x(l, f) && _(t), n.unbindTexture()
                }
                e.depthBuffer && z(e)
            }, this.updateRenderTargetMipmap = function (t) {
                const e = y(t) || a, r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                for (let o = 0, s = r.length; o < s; o++) {
                    const s = r[o];
                    if (x(s, e)) {
                        const e = t.isWebGLCubeRenderTarget ? 34067 : 3553, r = i.get(s).__webglTexture;
                        n.bindTexture(e, r), _(e), n.unbindTexture()
                    }
                }
            }, this.updateMultisampleRenderTarget = function (e) {
                if (e.useRenderbuffer) if (a) {
                    const r = e.width, o = e.height;
                    let s = 16384;
                    const a = [36064], l = e.stencilBuffer ? 33306 : 36096;
                    e.depthBuffer && a.push(l), e.ignoreDepthForMultisampleCopy || (e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024));
                    const c = i.get(e);
                    n.bindFramebuffer(36008, c.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, c.__webglFramebuffer), e.ignoreDepthForMultisampleCopy && (t.invalidateFramebuffer(36008, [l]), t.invalidateFramebuffer(36009, [l])), t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, s, 9728), t.invalidateFramebuffer(36008, a), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, c.__webglMultisampledFramebuffer)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
            }, this.setupDepthRenderbuffer = z, this.setupFrameBufferTexture = O, this.safeSetTexture2D = function (t, e) {
                t && t.isWebGLRenderTarget && (!1 === N && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), N = !0), t = t.texture), E(t, e)
            }, this.safeSetTextureCube = function (t, e) {
                t && t.isWebGLCubeRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), B = !0), t = t.texture), A(t, e)
            }
        }

        function cu(t, e, n) {
            const i = n.isWebGL2;
            return {
                convert: function (t) {
                    let n;
                    if (t === ur) return 5121;
                    if (1017 === t) return 32819;
                    if (1018 === t) return 32820;
                    if (1019 === t) return 33635;
                    if (1010 === t) return 5120;
                    if (1011 === t) return 5122;
                    if (t === hr) return 5123;
                    if (1013 === t) return 5124;
                    if (t === dr) return 5125;
                    if (t === pr) return 5126;
                    if (t === fr) return i ? 5131 : (n = e.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
                    if (1021 === t) return 6406;
                    if (t === gr) return 6407;
                    if (t === vr) return 6408;
                    if (1024 === t) return 6409;
                    if (1025 === t) return 6410;
                    if (t === yr) return 6402;
                    if (t === xr) return 34041;
                    if (1028 === t) return 6403;
                    if (1029 === t) return 36244;
                    if (1030 === t) return 33319;
                    if (1031 === t) return 33320;
                    if (1032 === t) return 36248;
                    if (1033 === t) return 36249;
                    if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
                        if (n = e.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
                        if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                        if (n = e.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
                        if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === t) return n = e.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if ((37492 === t || 37496 === t) && (n = e.get("WEBGL_compressed_texture_etc"), null !== n)) {
                        if (37492 === t) return n.COMPRESSED_RGB8_ETC2;
                        if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (n = e.get("WEBGL_compressed_texture_astc"), null !== n ? t : null) : 36492 === t ? (n = e.get("EXT_texture_compression_bptc"), null !== n ? t : null) : t === mr ? i ? 34042 : (n = e.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                }
            }
        }

        class uu extends ma {
            constructor(t = []) {
                super(), this.cameras = t
            }
        }

        uu.prototype.isArrayCamera = !0;

        class hu extends ls {
            constructor() {
                super(), this.type = "Group"
            }
        }

        hu.prototype.isGroup = !0;
        const du = {type: "move"};

        class pu {
            constructor() {
                this._targetRay = null, this._grip = null, this._hand = null
            }

            getHandSpace() {
                return null === this._hand && (this._hand = new hu, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {pinching: !1}), this._hand
            }

            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new hu, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new oo, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new oo), this._targetRay
            }

            getGripSpace() {
                return null === this._grip && (this._grip = new hu, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new oo, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new oo), this._grip
            }

            dispatchEvent(t) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
            }

            disconnect(t) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: t
                }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
            }

            update(t, e, n) {
                let i = null, r = null, o = null;
                const s = this._targetRay, a = this._grip, l = this._hand;
                if (t && "visible-blurred" !== e.session.visibilityState) if (null !== s && (i = e.getPose(t.targetRaySpace, n), null !== i && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1, this.dispatchEvent(du))), l && t.hand) {
                    o = !0;
                    for (const i of t.hand.values()) {
                        const t = e.getJointPose(i, n);
                        if (void 0 === l.joints[i.jointName]) {
                            const t = new hu;
                            t.matrixAutoUpdate = !1, t.visible = !1, l.joints[i.jointName] = t, l.add(t)
                        }
                        const r = l.joints[i.jointName];
                        null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t
                    }
                    const i = l.joints["index-finger-tip"], r = l.joints["thumb-tip"],
                        s = i.position.distanceTo(r.position), a = .02, c = .005;
                    l.inputState.pinching && s > a + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                        type: "pinchend",
                        handedness: t.handedness,
                        target: this
                    })) : !l.inputState.pinching && s <= a - c && (l.inputState.pinching = !0, this.dispatchEvent({
                        type: "pinchstart",
                        handedness: t.handedness,
                        target: this
                    }))
                } else null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1));
                return null !== s && (s.visible = null !== i), null !== a && (a.visible = null !== r), null !== l && (l.visible = null !== o), this
            }
        }

        class fu extends $r {
            constructor(t, e, n, i, r, o, s, a, l, c) {
                if ((c = void 0 !== c ? c : yr) !== yr && c !== xr) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === yr && (n = hr), void 0 === n && c === xr && (n = mr), super(null, i, r, o, s, a, c, n, l), this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== s ? s : or, this.minFilter = void 0 !== a ? a : or, this.flipY = !1, this.generateMipmaps = !1
            }
        }

        fu.prototype.isDepthTexture = !0;

        class mu extends zr {
            constructor(t, e) {
                super();
                const n = this;
                let i = null, r = 1, o = null, s = "local-floor";
                const a = t.extensions.has("WEBGL_multisampled_render_to_texture");
                let l = null, c = null, u = null, h = null, d = !1, p = null;
                const f = e.getContextAttributes();
                let m = null, g = null;
                const v = [], y = new Map, x = new ma;
                x.layers.enable(1), x.viewport = new eo;
                const _ = new ma;
                _.layers.enable(2), _.viewport = new eo;
                const b = [x, _], w = new uu;
                w.layers.enable(1), w.layers.enable(2);
                let S = null, M = null;

                function T(t) {
                    const e = y.get(t.inputSource);
                    e && e.dispatchEvent({type: t.type, data: t.inputSource})
                }

                function E() {
                    y.forEach((function (t, e) {
                        t.disconnect(e)
                    })), y.clear(), S = null, M = null, t.setRenderTarget(m), h = null, u = null, c = null, i = null, g = null, I.stop(), n.isPresenting = !1, n.dispatchEvent({type: "sessionend"})
                }

                function A(t) {
                    const e = i.inputSources;
                    for (let t = 0; t < v.length; t++) y.set(e[t], v[t]);
                    for (let e = 0; e < t.removed.length; e++) {
                        const n = t.removed[e], i = y.get(n);
                        i && (i.dispatchEvent({type: "disconnected", data: n}), y.delete(n))
                    }
                    for (let e = 0; e < t.added.length; e++) {
                        const n = t.added[e], i = y.get(n);
                        i && i.dispatchEvent({type: "connected", data: n})
                    }
                }

                this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (t) {
                    let e = v[t];
                    return void 0 === e && (e = new pu, v[t] = e), e.getTargetRaySpace()
                }, this.getControllerGrip = function (t) {
                    let e = v[t];
                    return void 0 === e && (e = new pu, v[t] = e), e.getGripSpace()
                }, this.getHand = function (t) {
                    let e = v[t];
                    return void 0 === e && (e = new pu, v[t] = e), e.getHandSpace()
                }, this.setFramebufferScaleFactor = function (t) {
                    r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }, this.setReferenceSpaceType = function (t) {
                    s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }, this.getReferenceSpace = function () {
                    return o
                }, this.getBaseLayer = function () {
                    return null !== u ? u : h
                }, this.getBinding = function () {
                    return c
                }, this.getFrame = function () {
                    return p
                }, this.getSession = function () {
                    return i
                }, this.setSession = async function (l) {
                    if (i = l, null !== i) {
                        if (m = t.getRenderTarget(), i.addEventListener("select", T), i.addEventListener("selectstart", T), i.addEventListener("selectend", T), i.addEventListener("squeeze", T), i.addEventListener("squeezestart", T), i.addEventListener("squeezeend", T), i.addEventListener("end", E), i.addEventListener("inputsourceschange", A), !0 !== f.xrCompatible && await e.makeXRCompatible(), void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2) {
                            const t = {
                                antialias: void 0 !== i.renderState.layers || f.antialias,
                                alpha: f.alpha,
                                depth: f.depth,
                                stencil: f.stencil,
                                framebufferScaleFactor: r
                            };
                            h = new XRWebGLLayer(i, e, t), i.updateRenderState({baseLayer: h}), g = new no(h.framebufferWidth, h.framebufferHeight)
                        } else {
                            d = f.antialias;
                            let t = null, n = null, o = null;
                            f.depth && (o = f.stencil ? 35056 : 33189, t = f.stencil ? xr : yr, n = f.stencil ? mr : hr);
                            const s = {colorFormat: f.alpha || d ? 32856 : 32849, depthFormat: o, scaleFactor: r};
                            c = new XRWebGLBinding(i, e), u = c.createProjectionLayer(s), i.updateRenderState({layers: [u]}), g = d ? new io(u.textureWidth, u.textureHeight, {
                                format: vr,
                                type: ur,
                                depthTexture: new fu(u.textureWidth, u.textureHeight, n, void 0, void 0, void 0, void 0, void 0, void 0, t),
                                stencilBuffer: f.stencil,
                                ignoreDepth: u.ignoreDepthValues,
                                useRenderToTexture: a
                            }) : new no(u.textureWidth, u.textureHeight, {
                                format: f.alpha ? vr : gr,
                                type: ur,
                                depthTexture: new fu(u.textureWidth, u.textureHeight, n, void 0, void 0, void 0, void 0, void 0, void 0, t),
                                stencilBuffer: f.stencil,
                                ignoreDepth: u.ignoreDepthValues
                            })
                        }
                        this.setFoveation(0), o = await i.requestReferenceSpace(s), I.setContext(i), I.start(), n.isPresenting = !0, n.dispatchEvent({type: "sessionstart"})
                    }
                };
                const P = new oo, L = new oo;

                function C(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                }

                this.updateCamera = function (t) {
                    if (null === i) return;
                    w.near = _.near = x.near = t.near, w.far = _.far = x.far = t.far, S === w.near && M === w.far || (i.updateRenderState({
                        depthNear: w.near,
                        depthFar: w.far
                    }), S = w.near, M = w.far);
                    const e = t.parent, n = w.cameras;
                    C(w, e);
                    for (let t = 0; t < n.length; t++) C(n[t], e);
                    w.matrixWorld.decompose(w.position, w.quaternion, w.scale), t.position.copy(w.position), t.quaternion.copy(w.quaternion), t.scale.copy(w.scale), t.matrix.copy(w.matrix), t.matrixWorld.copy(w.matrixWorld);
                    const r = t.children;
                    for (let t = 0, e = r.length; t < e; t++) r[t].updateMatrixWorld(!0);
                    2 === n.length ? function (t, e, n) {
                        P.setFromMatrixPosition(e.matrixWorld), L.setFromMatrixPosition(n.matrixWorld);
                        const i = P.distanceTo(L), r = e.projectionMatrix.elements, o = n.projectionMatrix.elements,
                            s = r[14] / (r[10] - 1), a = r[14] / (r[10] + 1), l = (r[9] + 1) / r[5],
                            c = (r[9] - 1) / r[5], u = (r[8] - 1) / r[0], h = (o[8] + 1) / o[0], d = s * u, p = s * h,
                            f = i / (-u + h), m = f * -u;
                        e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                        const g = s + f, v = a + f, y = d - m, x = p + (i - m), _ = l * a / v * g, b = c * a / v * g;
                        t.projectionMatrix.makePerspective(y, x, _, b, g, v)
                    }(w, x, _) : w.projectionMatrix.copy(x.projectionMatrix)
                }, this.getCamera = function () {
                    return w
                }, this.getFoveation = function () {
                    return null !== u ? u.fixedFoveation : null !== h ? h.fixedFoveation : void 0
                }, this.setFoveation = function (t) {
                    null !== u && (u.fixedFoveation = t), null !== h && void 0 !== h.fixedFoveation && (h.fixedFoveation = t)
                };
                let R = null;
                const I = new Aa;
                I.setAnimationLoop((function (e, n) {
                    if (l = n.getViewerPose(o), p = n, null !== l) {
                        const e = l.views;
                        null !== h && (t.setRenderTargetFramebuffer(g, h.framebuffer), t.setRenderTarget(g));
                        let n = !1;
                        e.length !== w.cameras.length && (w.cameras.length = 0, n = !0);
                        for (let i = 0; i < e.length; i++) {
                            const r = e[i];
                            let o = null;
                            if (null !== h) o = h.getViewport(r); else {
                                const e = c.getViewSubImage(u, r);
                                o = e.viewport, 0 === i && (t.setRenderTargetTextures(g, e.colorTexture, u.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(g))
                            }
                            const s = b[i];
                            s.matrix.fromArray(r.transform.matrix), s.projectionMatrix.fromArray(r.projectionMatrix), s.viewport.set(o.x, o.y, o.width, o.height), 0 === i && w.matrix.copy(s.matrix), !0 === n && w.cameras.push(s)
                        }
                    }
                    const r = i.inputSources;
                    for (let t = 0; t < v.length; t++) {
                        const e = v[t], i = r[t];
                        e.update(i, n, o)
                    }
                    R && R(e, n), p = null
                })), this.setAnimationLoop = function (t) {
                    R = t
                }, this.dispose = function () {
                }
            }
        }

        function gu(t) {
            function e(e, n) {
                e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap), n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
                const i = t.get(n).envMap;
                let r, o;
                i && (e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = n.reflectivity, e.ior.value = n.ior, e.refractionRatio.value = n.refractionRatio), n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? r = n.clearcoatRoughnessMap : n.specularIntensityMap ? r = n.specularIntensityMap : n.specularColorMap ? r = n.specularColorMap : n.transmissionMap ? r = n.transmissionMap : n.thicknessMap ? r = n.thicknessMap : n.sheenColorMap ? r = n.sheenColorMap : n.sheenRoughnessMap && (r = n.sheenRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), n.aoMap ? o = n.aoMap : n.lightMap && (o = n.lightMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), e.uv2Transform.value.copy(o.matrix))
            }

            function n(e, n) {
                e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, 1 === n.side && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), 1 === n.side && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias);
                t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
            }

            return {
                refreshFogUniforms: function (t, e) {
                    t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                }, refreshMaterialUniforms: function (t, i, r, o, s) {
                    i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function (t, e) {
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                    }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function (t, e) {
                        e.gradientMap && (t.gradientMap.value = e.gradientMap);
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function (t, e) {
                        t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshStandardMaterial ? (e(t, i), i.isMeshPhysicalMaterial ? function (t, e, i) {
                        n(t, e), t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap));
                        e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate()));
                        e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor));
                        t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap);
                        e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
                    }(t, i, s) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i), function (t, e) {
                        e.matcap && (t.matcap.value = e.matcap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function (t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function (t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                        t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                    }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function (t, e) {
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isLineBasicMaterial ? (function (t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                    }(t, i), i.isLineDashedMaterial && function (t, e) {
                        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                    }(t, i)) : i.isPointsMaterial ? function (t, e, n, i) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map);
                        e.alphaMap && (t.alphaMap.value = e.alphaMap);
                        e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                        let r;
                        e.map ? r = e.map : e.alphaMap && (r = e.alphaMap);
                        void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
                    }(t, i, r, o) : i.isSpriteMaterial ? function (t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
                        e.alphaMap && (t.alphaMap.value = e.alphaMap);
                        e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                        let n;
                        e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                        void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                    }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                }
            }
        }

        function vu(t = {}) {
            const e = void 0 !== t.canvas ? t.canvas : function () {
                    const t = Yr("canvas");
                    return t.style.display = "block", t
                }(), n = void 0 !== t.context ? t.context : null, i = void 0 !== t.alpha && t.alpha,
                r = void 0 === t.depth || t.depth, o = void 0 === t.stencil || t.stencil,
                s = void 0 !== t.antialias && t.antialias, a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                c = void 0 !== t.powerPreference ? t.powerPreference : "default",
                u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
            let h = null, d = null;
            const p = [], f = [];
            this.domElement = e, this.debug = {checkShaderErrors: !0}, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Ar, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
            const m = this;
            let g = !1, v = 0, y = 0, x = null, _ = -1, b = null;
            const w = new eo, S = new eo;
            let M = null, T = e.width, E = e.height, A = 1, P = null, L = null;
            const C = new eo(0, 0, T, E), R = new eo(0, 0, T, E);
            let I = !1;
            const O = [], D = new Ea;
            let z = !1, k = !1, N = null;
            const B = new No, F = new oo,
                U = {background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0};

            function H() {
                return null === x ? A : 1
            }

            let V, G, W, j, q, X, Y, J, Z, Q, K, $, tt, et, nt, it, rt, ot, st, at, lt, ct, ut, ht = n;

            function dt(t, n) {
                for (let i = 0; i < t.length; i++) {
                    const r = t[i], o = e.getContext(r, n);
                    if (null !== o) return o
                }
                return null
            }

            try {
                const t = {
                    alpha: i,
                    depth: r,
                    stencil: o,
                    antialias: s,
                    premultipliedAlpha: a,
                    preserveDrawingBuffer: l,
                    powerPreference: c,
                    failIfMajorPerformanceCaveat: u
                };
                if ("setAttribute" in e && e.setAttribute("data-engine", "three.js r135"), e.addEventListener("webglcontextlost", mt, !1), e.addEventListener("webglcontextrestored", gt, !1), null === ht) {
                    const e = ["webgl2", "webgl", "experimental-webgl"];
                    if (!0 === m.isWebGL1Renderer && e.shift(), ht = dt(e, t), null === ht) throw dt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                void 0 === ht.getShaderPrecisionFormat && (ht.getShaderPrecisionFormat = function () {
                    return {rangeMin: 1, rangeMax: 1, precision: 1}
                })
            } catch (t) {
                throw console.error("THREE.WebGLRenderer: " + t.message), t
            }

            function pt() {
                V = new hl(ht), G = new ka(ht, V, t), V.init(G), ct = new cu(ht, V, G), W = new au(ht, V, G), O[0] = 1029, j = new fl(ht), q = new Xc, X = new lu(ht, V, W, q, G, ct, j), Y = new Ba(m), J = new ul(m), Z = new Pa(ht, G), ut = new Da(ht, V, Z, G), Q = new dl(ht, Z, j, ut), K = new _l(ht, Q, Z, j), st = new xl(ht, G, X), it = new Na(q), $ = new qc(m, Y, J, V, G, ut, it), tt = new gu(q), et = new Qc(q), nt = new iu(V, G), ot = new Oa(m, Y, W, K, a), rt = new su(m, K, G), at = new za(ht, V, j, G), lt = new pl(ht, V, j, G), j.programs = $.programs, m.capabilities = G, m.extensions = V, m.properties = q, m.renderLists = et, m.shadowMap = rt, m.state = W, m.info = j
            }

            pt();
            const ft = new mu(m, ht);

            function mt(t) {
                t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0
            }

            function gt() {
                console.log("THREE.WebGLRenderer: Context Restored."), g = !1;
                const t = j.autoReset, e = rt.enabled, n = rt.autoUpdate, i = rt.needsUpdate, r = rt.type;
                pt(), j.autoReset = t, rt.enabled = e, rt.autoUpdate = n, rt.needsUpdate = i, rt.type = r
            }

            function vt(t) {
                const e = t.target;
                e.removeEventListener("dispose", vt), function (t) {
                    (function (t) {
                        const e = q.get(t).programs;
                        void 0 !== e && e.forEach((function (t) {
                            $.releaseProgram(t)
                        }))
                    })(t), q.remove(t)
                }(e)
            }

            this.xr = ft, this.getContext = function () {
                return ht
            }, this.getContextAttributes = function () {
                return ht.getContextAttributes()
            }, this.forceContextLoss = function () {
                const t = V.get("WEBGL_lose_context");
                t && t.loseContext()
            }, this.forceContextRestore = function () {
                const t = V.get("WEBGL_lose_context");
                t && t.restoreContext()
            }, this.getPixelRatio = function () {
                return A
            }, this.setPixelRatio = function (t) {
                void 0 !== t && (A = t, this.setSize(T, E, !1))
            }, this.getSize = function (t) {
                return t.set(T, E)
            }, this.setSize = function (t, n, i) {
                ft.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = t, E = n, e.width = Math.floor(t * A), e.height = Math.floor(n * A), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
            }, this.getDrawingBufferSize = function (t) {
                return t.set(T * A, E * A).floor()
            }, this.setDrawingBufferSize = function (t, n, i) {
                T = t, E = n, A = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
            }, this.getCurrentViewport = function (t) {
                return t.copy(w)
            }, this.getViewport = function (t) {
                return t.copy(C)
            }, this.setViewport = function (t, e, n, i) {
                t.isVector4 ? C.set(t.x, t.y, t.z, t.w) : C.set(t, e, n, i), W.viewport(w.copy(C).multiplyScalar(A).floor())
            }, this.getScissor = function (t) {
                return t.copy(R)
            }, this.setScissor = function (t, e, n, i) {
                t.isVector4 ? R.set(t.x, t.y, t.z, t.w) : R.set(t, e, n, i), W.scissor(S.copy(R).multiplyScalar(A).floor())
            }, this.getScissorTest = function () {
                return I
            }, this.setScissorTest = function (t) {
                W.setScissorTest(I = t)
            }, this.setOpaqueSort = function (t) {
                P = t
            }, this.setTransparentSort = function (t) {
                L = t
            }, this.getClearColor = function (t) {
                return t.copy(ot.getClearColor())
            }, this.setClearColor = function () {
                ot.setClearColor.apply(ot, arguments)
            }, this.getClearAlpha = function () {
                return ot.getClearAlpha()
            }, this.setClearAlpha = function () {
                ot.setClearAlpha.apply(ot, arguments)
            }, this.clear = function (t, e, n) {
                let i = 0;
                (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), ht.clear(i)
            }, this.clearColor = function () {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function () {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function () {
                this.clear(!1, !1, !0)
            }, this.dispose = function () {
                e.removeEventListener("webglcontextlost", mt, !1), e.removeEventListener("webglcontextrestored", gt, !1), et.dispose(), nt.dispose(), q.dispose(), Y.dispose(), J.dispose(), K.dispose(), ut.dispose(), ft.dispose(), ft.removeEventListener("sessionstart", xt), ft.removeEventListener("sessionend", _t), N && (N.dispose(), N = null), bt.stop()
            }, this.renderBufferDirect = function (t, e, n, i, r, o) {
                null === e && (e = U);
                const s = r.isMesh && r.matrixWorld.determinant() < 0, a = function (t, e, n, i, r) {
                    !0 !== e.isScene && (e = U);
                    X.resetTextureUnits();
                    const o = e.fog, s = i.isMeshStandardMaterial ? e.environment : null,
                        a = null === x ? m.outputEncoding : x.texture.encoding,
                        l = (i.isMeshStandardMaterial ? J : Y).get(i.envMap || s),
                        c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                        u = !!i.normalMap && !!n.attributes.tangent, h = !!n.morphAttributes.position,
                        p = !!n.morphAttributes.normal,
                        f = n.morphAttributes.position ? n.morphAttributes.position.length : 0, g = q.get(i),
                        v = d.state.lights;
                    if (!0 === z && (!0 === k || t !== b)) {
                        const e = t === b && i.id === _;
                        it.setState(i, t, e)
                    }
                    let y = !1;
                    i.version === g.__version ? g.needsLights && g.lightsStateVersion !== v.state.version || g.outputEncoding !== a || r.isInstancedMesh && !1 === g.instancing ? y = !0 : r.isInstancedMesh || !0 !== g.instancing ? r.isSkinnedMesh && !1 === g.skinning ? y = !0 : r.isSkinnedMesh || !0 !== g.skinning ? g.envMap !== l || i.fog && g.fog !== o ? y = !0 : void 0 === g.numClippingPlanes || g.numClippingPlanes === it.numPlanes && g.numIntersection === it.numIntersection ? (g.vertexAlphas !== c || g.vertexTangents !== u || g.morphTargets !== h || g.morphNormals !== p || !0 === G.isWebGL2 && g.morphTargetsCount !== f) && (y = !0) : y = !0 : y = !0 : y = !0 : (y = !0, g.__version = i.version);
                    let w = g.currentProgram;
                    !0 === y && (w = Et(i, e, r));
                    let S = !1, M = !1, T = !1;
                    const P = w.getUniforms(), L = g.uniforms;
                    W.useProgram(w.program) && (S = !0, M = !0, T = !0);
                    i.id !== _ && (_ = i.id, M = !0);
                    if (S || b !== t) {
                        if (P.setValue(ht, "projectionMatrix", t.projectionMatrix), G.logarithmicDepthBuffer && P.setValue(ht, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), b !== t && (b = t, M = !0, T = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
                            const e = P.map.cameraPosition;
                            void 0 !== e && e.setValue(ht, F.setFromMatrixPosition(t.matrixWorld))
                        }
                        (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && P.setValue(ht, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && P.setValue(ht, "viewMatrix", t.matrixWorldInverse)
                    }
                    if (r.isSkinnedMesh) {
                        P.setOptional(ht, r, "bindMatrix"), P.setOptional(ht, r, "bindMatrixInverse");
                        const t = r.skeleton;
                        t && (G.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), P.setValue(ht, "boneTexture", t.boneTexture, X), P.setValue(ht, "boneTextureSize", t.boneTextureSize)) : P.setOptional(ht, t, "boneMatrices"))
                    }
                    !n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || st.update(r, n, i, w);
                    (M || g.receiveShadow !== r.receiveShadow) && (g.receiveShadow = r.receiveShadow, P.setValue(ht, "receiveShadow", r.receiveShadow));
                    M && (P.setValue(ht, "toneMappingExposure", m.toneMappingExposure), g.needsLights && (R = T, (C = L).ambientLightColor.needsUpdate = R, C.lightProbe.needsUpdate = R, C.directionalLights.needsUpdate = R, C.directionalLightShadows.needsUpdate = R, C.pointLights.needsUpdate = R, C.pointLightShadows.needsUpdate = R, C.spotLights.needsUpdate = R, C.spotLightShadows.needsUpdate = R, C.rectAreaLights.needsUpdate = R, C.hemisphereLights.needsUpdate = R), o && i.fog && tt.refreshFogUniforms(L, o), tt.refreshMaterialUniforms(L, i, A, E, N), Tc.upload(ht, g.uniformsList, L, X));
                    var C, R;
                    i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Tc.upload(ht, g.uniformsList, L, X), i.uniformsNeedUpdate = !1);
                    i.isSpriteMaterial && P.setValue(ht, "center", r.center);
                    return P.setValue(ht, "modelViewMatrix", r.modelViewMatrix), P.setValue(ht, "normalMatrix", r.normalMatrix), P.setValue(ht, "modelMatrix", r.matrixWorld), w
                }(t, e, n, i, r);
                W.setMaterial(i, s);
                let l = n.index;
                const c = n.attributes.position;
                if (null === l) {
                    if (void 0 === c || 0 === c.count) return
                } else if (0 === l.count) return;
                let u, h = 1;
                !0 === i.wireframe && (l = Q.getWireframeAttribute(n), h = 2), ut.setup(r, i, a, n, l);
                let p = at;
                null !== l && (u = Z.get(l), p = lt, p.setIndex(u));
                const f = null !== l ? l.count : c.count, g = n.drawRange.start * h, v = n.drawRange.count * h,
                    y = null !== o ? o.start * h : 0, w = null !== o ? o.count * h : 1 / 0, S = Math.max(g, y),
                    M = Math.min(f, g + v, y + w) - 1, T = Math.max(0, M - S + 1);
                if (0 !== T) {
                    if (r.isMesh) !0 === i.wireframe ? (W.setLineWidth(i.wireframeLinewidth * H()), p.setMode(1)) : p.setMode(4); else if (r.isLine) {
                        let t = i.linewidth;
                        void 0 === t && (t = 1), W.setLineWidth(t * H()), r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3)
                    } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
                    if (r.isInstancedMesh) p.renderInstances(S, T, r.count); else if (n.isInstancedBufferGeometry) {
                        const t = Math.min(n.instanceCount, n._maxInstanceCount);
                        p.renderInstances(S, T, t)
                    } else p.render(S, T)
                }
            }, this.compile = function (t, e) {
                d = nt.get(t), d.init(), f.push(d), t.traverseVisible((function (t) {
                    t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t))
                })), d.setupLights(m.physicallyCorrectLights), t.traverse((function (e) {
                    const n = e.material;
                    if (n) if (Array.isArray(n)) for (let i = 0; i < n.length; i++) {
                        Et(n[i], t, e)
                    } else Et(n, t, e)
                })), f.pop(), d = null
            };
            let yt = null;

            function xt() {
                bt.stop()
            }

            function _t() {
                bt.start()
            }

            const bt = new Aa;

            function wt(t, e, n, i) {
                if (!1 === t.visible) return;
                if (t.layers.test(e.layers)) if (t.isGroup) n = t.renderOrder; else if (t.isLOD) !0 === t.autoUpdate && t.update(e); else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t); else if (t.isSprite) {
                    if (!t.frustumCulled || D.intersectsSprite(t)) {
                        i && F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B);
                        const e = K.update(t), r = t.material;
                        r.visible && h.push(t, e, r, n, F.z, null)
                    }
                } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== j.render.frame && (t.skeleton.update(), t.skeleton.frame = j.render.frame), !t.frustumCulled || D.intersectsObject(t))) {
                    i && F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B);
                    const e = K.update(t), r = t.material;
                    if (Array.isArray(r)) {
                        const i = e.groups;
                        for (let o = 0, s = i.length; o < s; o++) {
                            const s = i[o], a = r[s.materialIndex];
                            a && a.visible && h.push(t, e, a, n, F.z, s)
                        }
                    } else r.visible && h.push(t, e, r, n, F.z, null)
                }
                const r = t.children;
                for (let t = 0, o = r.length; t < o; t++) wt(r[t], e, n, i)
            }

            function St(t, e, n, i) {
                const r = t.opaque, o = t.transmissive, a = t.transparent;
                d.setupLightsView(n), o.length > 0 && function (t, e, n) {
                    if (null === N) {
                        const t = !0 === s && !0 === G.isWebGL2;
                        N = new (t ? io : no)(1024, 1024, {
                            generateMipmaps: !0,
                            type: null !== ct.convert(fr) ? fr : ur,
                            minFilter: cr,
                            magFilter: or,
                            wrapS: ir,
                            wrapT: ir,
                            useRenderToTexture: V.has("WEBGL_multisampled_render_to_texture")
                        })
                    }
                    const i = m.getRenderTarget();
                    m.setRenderTarget(N), m.clear();
                    const r = m.toneMapping;
                    m.toneMapping = 0, Mt(t, e, n), m.toneMapping = r, X.updateMultisampleRenderTarget(N), X.updateRenderTargetMipmap(N), m.setRenderTarget(i)
                }(r, e, n), i && W.viewport(w.copy(i)), r.length > 0 && Mt(r, e, n), o.length > 0 && Mt(o, e, n), a.length > 0 && Mt(a, e, n)
            }

            function Mt(t, e, n) {
                const i = !0 === e.isScene ? e.overrideMaterial : null;
                for (let r = 0, o = t.length; r < o; r++) {
                    const o = t[r], s = o.object, a = o.geometry, l = null === i ? o.material : i, c = o.group;
                    s.layers.test(n.layers) && Tt(s, e, n, a, l, c)
                }
            }

            function Tt(t, e, n, i, r, o) {
                t.onBeforeRender(m, e, n, i, r, o), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(m, e, n, i, t, o), !0 === r.transparent && 2 === r.side ? (r.side = 1, r.needsUpdate = !0, m.renderBufferDirect(n, e, i, r, t, o), r.side = 0, r.needsUpdate = !0, m.renderBufferDirect(n, e, i, r, t, o), r.side = 2) : m.renderBufferDirect(n, e, i, r, t, o), t.onAfterRender(m, e, n, i, r, o)
            }

            function Et(t, e, n) {
                !0 !== e.isScene && (e = U);
                const i = q.get(t), r = d.state.lights, o = d.state.shadowsArray, s = r.state.version,
                    a = $.getParameters(t, r.state, o, e, n), l = $.getProgramCacheKey(a);
                let c = i.programs;
                i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? J : Y).get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", vt), c = new Map, i.programs = c);
                let u = c.get(l);
                if (void 0 !== u) {
                    if (i.currentProgram === u && i.lightsStateVersion === s) return At(t, a), u
                } else a.uniforms = $.getUniforms(t), t.onBuild(n, a, m), t.onBeforeCompile(a, m), u = $.acquireProgram(a, l), c.set(l, u), i.uniforms = a.uniforms;
                const h = i.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (h.clippingPlanes = it.uniform), At(t, a), i.needsLights = function (t) {
                    return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                }(t), i.lightsStateVersion = s, i.needsLights && (h.ambientLightColor.value = r.state.ambient, h.lightProbe.value = r.state.probe, h.directionalLights.value = r.state.directional, h.directionalLightShadows.value = r.state.directionalShadow, h.spotLights.value = r.state.spot, h.spotLightShadows.value = r.state.spotShadow, h.rectAreaLights.value = r.state.rectArea, h.ltc_1.value = r.state.rectAreaLTC1, h.ltc_2.value = r.state.rectAreaLTC2, h.pointLights.value = r.state.point, h.pointLightShadows.value = r.state.pointShadow, h.hemisphereLights.value = r.state.hemi, h.directionalShadowMap.value = r.state.directionalShadowMap, h.directionalShadowMatrix.value = r.state.directionalShadowMatrix, h.spotShadowMap.value = r.state.spotShadowMap, h.spotShadowMatrix.value = r.state.spotShadowMatrix, h.pointShadowMap.value = r.state.pointShadowMap, h.pointShadowMatrix.value = r.state.pointShadowMatrix);
                const p = u.getUniforms(), f = Tc.seqWithValue(p.seq, h);
                return i.currentProgram = u, i.uniformsList = f, u
            }

            function At(t, e) {
                const n = q.get(t);
                n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents
            }

            bt.setAnimationLoop((function (t) {
                yt && yt(t)
            })), "undefined" != typeof window && bt.setContext(window), this.setAnimationLoop = function (t) {
                yt = t, ft.setAnimationLoop(t), null === t ? bt.stop() : bt.start()
            }, ft.addEventListener("sessionstart", xt), ft.addEventListener("sessionend", _t), this.render = function (t, e) {
                if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                if (!0 === g) return;
                !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === ft.enabled && !0 === ft.isPresenting && (!0 === ft.cameraAutoUpdate && ft.updateCamera(e), e = ft.getCamera()), !0 === t.isScene && t.onBeforeRender(m, t, e, x), d = nt.get(t, f.length), d.init(), f.push(d), B.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), D.setFromProjectionMatrix(B), k = this.localClippingEnabled, z = it.init(this.clippingPlanes, k, e), h = et.get(t, p.length), h.init(), p.push(h), wt(t, e, 0, m.sortObjects), h.finish(), !0 === m.sortObjects && h.sort(P, L), !0 === z && it.beginShadows();
                const n = d.state.shadowsArray;
                if (rt.render(n, t, e), !0 === z && it.endShadows(), !0 === this.info.autoReset && this.info.reset(), ot.render(h, t), d.setupLights(m.physicallyCorrectLights), e.isArrayCamera) {
                    const n = e.cameras;
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        St(h, t, i, i.viewport)
                    }
                } else St(h, t, e);
                null !== x && (X.updateMultisampleRenderTarget(x), X.updateRenderTargetMipmap(x)), !0 === t.isScene && t.onAfterRender(m, t, e), W.buffers.depth.setTest(!0), W.buffers.depth.setMask(!0), W.buffers.color.setMask(!0), W.setPolygonOffset(!1), ut.resetDefaultState(), _ = -1, b = null, f.pop(), d = f.length > 0 ? f[f.length - 1] : null, p.pop(), h = p.length > 0 ? p[p.length - 1] : null
            }, this.getActiveCubeFace = function () {
                return v
            }, this.getActiveMipmapLevel = function () {
                return y
            }, this.getRenderTarget = function () {
                return x
            }, this.setRenderTargetTextures = function (t, e, n) {
                q.get(t.texture).__webglTexture = e, q.get(t.depthTexture).__webglTexture = n;
                const i = q.get(t);
                i.__hasExternalTextures = !0, i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || t.useRenderToTexture && (console.warn("render-to-texture extension was disabled because an external texture was provided"), t.useRenderToTexture = !1, t.useRenderbuffer = !0))
            }, this.setRenderTargetFramebuffer = function (t, e) {
                const n = q.get(t);
                n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e
            }, this.setRenderTarget = function (t, e = 0, n = 0) {
                x = t, v = e, y = n;
                let i = !0;
                if (t) {
                    const e = q.get(t);
                    void 0 !== e.__useDefaultFramebuffer ? (W.bindFramebuffer(36160, null), i = !1) : void 0 === e.__webglFramebuffer ? X.setupRenderTarget(t) : e.__hasExternalTextures && X.rebindTextures(t, q.get(t.texture).__webglTexture, q.get(t.depthTexture).__webglTexture)
                }
                let r = null, o = !1, s = !1;
                if (t) {
                    const n = t.texture;
                    (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
                    const i = q.get(t).__webglFramebuffer;
                    t.isWebGLCubeRenderTarget ? (r = i[e], o = !0) : r = t.useRenderbuffer ? q.get(t).__webglMultisampledFramebuffer : i, w.copy(t.viewport), S.copy(t.scissor), M = t.scissorTest
                } else w.copy(C).multiplyScalar(A).floor(), S.copy(R).multiplyScalar(A).floor(), M = I;
                if (W.bindFramebuffer(36160, r) && G.drawBuffers && i) {
                    let e = !1;
                    if (t) if (t.isWebGLMultipleRenderTargets) {
                        const n = t.texture;
                        if (O.length !== n.length || 36064 !== O[0]) {
                            for (let t = 0, e = n.length; t < e; t++) O[t] = 36064 + t;
                            O.length = n.length, e = !0
                        }
                    } else 1 === O.length && 36064 === O[0] || (O[0] = 36064, O.length = 1, e = !0); else 1 === O.length && 1029 === O[0] || (O[0] = 1029, O.length = 1, e = !0);
                    e && (G.isWebGL2 ? ht.drawBuffers(O) : V.get("WEBGL_draw_buffers").drawBuffersWEBGL(O))
                }
                if (W.viewport(w), W.scissor(S), W.setScissorTest(M), o) {
                    const i = q.get(t.texture);
                    ht.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
                } else if (s) {
                    const i = q.get(t.texture), r = e || 0;
                    ht.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
                }
                _ = -1
            }, this.readRenderTargetPixels = function (t, e, n, i, r, o, s) {
                if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let a = q.get(t).__webglFramebuffer;
                if (t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a) {
                    W.bindFramebuffer(36160, a);
                    try {
                        const s = t.texture, a = s.format, l = s.type;
                        if (a !== vr && ct.convert(a) !== ht.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        const c = l === fr && (V.has("EXT_color_buffer_half_float") || G.isWebGL2 && V.has("EXT_color_buffer_float"));
                        if (!(l === ur || ct.convert(l) === ht.getParameter(35738) || l === pr && (G.isWebGL2 || V.has("OES_texture_float") || V.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        36053 === ht.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && ht.readPixels(e, n, i, r, ct.convert(a), ct.convert(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        const t = null !== x ? q.get(x).__webglFramebuffer : null;
                        W.bindFramebuffer(36160, t)
                    }
                }
            }, this.copyFramebufferToTexture = function (t, e, n = 0) {
                const i = Math.pow(2, -n), r = Math.floor(e.image.width * i), o = Math.floor(e.image.height * i);
                let s = ct.convert(e.format);
                G.isWebGL2 && (6407 === s && (s = 32849), 6408 === s && (s = 32856)), X.setTexture2D(e, 0), ht.copyTexImage2D(3553, n, s, t.x, t.y, r, o, 0), W.unbindTexture()
            }, this.copyTextureToTexture = function (t, e, n, i = 0) {
                const r = e.image.width, o = e.image.height, s = ct.convert(n.format), a = ct.convert(n.type);
                X.setTexture2D(n, 0), ht.pixelStorei(37440, n.flipY), ht.pixelStorei(37441, n.premultiplyAlpha), ht.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? ht.texSubImage2D(3553, i, t.x, t.y, r, o, s, a, e.image.data) : e.isCompressedTexture ? ht.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : ht.texSubImage2D(3553, i, t.x, t.y, s, a, e.image), 0 === i && n.generateMipmaps && ht.generateMipmap(3553), W.unbindTexture()
            }, this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
                if (m.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                const o = t.max.x - t.min.x + 1, s = t.max.y - t.min.y + 1, a = t.max.z - t.min.z + 1,
                    l = ct.convert(i.format), c = ct.convert(i.type);
                let u;
                if (i.isDataTexture3D) X.setTexture3D(i, 0), u = 32879; else {
                    if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                    X.setTexture2DArray(i, 0), u = 35866
                }
                ht.pixelStorei(37440, i.flipY), ht.pixelStorei(37441, i.premultiplyAlpha), ht.pixelStorei(3317, i.unpackAlignment);
                const h = ht.getParameter(3314), d = ht.getParameter(32878), p = ht.getParameter(3316),
                    f = ht.getParameter(3315), g = ht.getParameter(32877),
                    v = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                ht.pixelStorei(3314, v.width), ht.pixelStorei(32878, v.height), ht.pixelStorei(3316, t.min.x), ht.pixelStorei(3315, t.min.y), ht.pixelStorei(32877, t.min.z), n.isDataTexture || n.isDataTexture3D ? ht.texSubImage3D(u, r, e.x, e.y, e.z, o, s, a, l, c, v.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ht.compressedTexSubImage3D(u, r, e.x, e.y, e.z, o, s, a, l, v.data)) : ht.texSubImage3D(u, r, e.x, e.y, e.z, o, s, a, l, c, v), ht.pixelStorei(3314, h), ht.pixelStorei(32878, d), ht.pixelStorei(3316, p), ht.pixelStorei(3315, f), ht.pixelStorei(32877, g), 0 === r && i.generateMipmaps && ht.generateMipmap(u), W.unbindTexture()
            }, this.initTexture = function (t) {
                X.setTexture2D(t, 0), W.unbindTexture()
            }, this.resetState = function () {
                v = 0, y = 0, x = null, W.reset(), ut.reset()
            }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}))
        }

        vu.prototype.isWebGLRenderer = !0;
        (class extends vu {
        }).prototype.isWebGL1Renderer = !0;

        class yu {
            constructor(t, e = 25e-5) {
                this.name = "", this.color = new Ps(t), this.density = e
            }

            clone() {
                return new yu(this.color, this.density)
            }

            toJSON() {
                return {type: "FogExp2", color: this.color.getHex(), density: this.density}
            }
        }

        yu.prototype.isFogExp2 = !0;

        class xu {
            constructor(t, e = 1, n = 1e3) {
                this.name = "", this.color = new Ps(t), this.near = e, this.far = n
            }

            clone() {
                return new xu(this.color, this.near, this.far)
            }

            toJSON() {
                return {type: "Fog", color: this.color.getHex(), near: this.near, far: this.far}
            }
        }

        xu.prototype.isFog = !0;

        class _u extends ls {
            constructor() {
                super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}))
            }

            copy(t, e) {
                return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
            }

            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.fog && (e.object.fog = this.fog.toJSON()), e
            }
        }

        _u.prototype.isScene = !0;

        class bu {
            constructor(t, e) {
                this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = Ir, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0, this.uuid = Fr()
            }

            onUploadCallback() {
            }

            set needsUpdate(t) {
                !0 === t && this.version++
            }

            setUsage(t) {
                return this.usage = t, this
            }

            copy(t) {
                return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
            }

            copyAt(t, e, n) {
                t *= this.stride, n *= e.stride;
                for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                return this
            }

            set(t, e = 0) {
                return this.array.set(t, e), this
            }

            clone(t) {
                void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Fr()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                    n = new this.constructor(e, this.stride);
                return n.setUsage(this.usage), n
            }

            onUpload(t) {
                return this.onUploadCallback = t, this
            }

            toJSON(t) {
                return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Fr()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }

        bu.prototype.isInterleavedBuffer = !0;
        const wu = new oo;

        class Su {
            constructor(t, e, n, i = !1) {
                this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i
            }

            get count() {
                return this.data.count
            }

            get array() {
                return this.data.array
            }

            set needsUpdate(t) {
                this.data.needsUpdate = t
            }

            applyMatrix4(t) {
                for (let e = 0, n = this.data.count; e < n; e++) wu.x = this.getX(e), wu.y = this.getY(e), wu.z = this.getZ(e), wu.applyMatrix4(t), this.setXYZ(e, wu.x, wu.y, wu.z);
                return this
            }

            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++) wu.x = this.getX(e), wu.y = this.getY(e), wu.z = this.getZ(e), wu.applyNormalMatrix(t), this.setXYZ(e, wu.x, wu.y, wu.z);
                return this
            }

            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++) wu.x = this.getX(e), wu.y = this.getY(e), wu.z = this.getZ(e), wu.transformDirection(t), this.setXYZ(e, wu.x, wu.y, wu.z);
                return this
            }

            setX(t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e, this
            }

            setY(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e, this
            }

            setZ(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e, this
            }

            setW(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e, this
            }

            getX(t) {
                return this.data.array[t * this.data.stride + this.offset]
            }

            getY(t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            }

            getZ(t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            }

            getW(t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            }

            setXY(t, e, n) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
            }

            setXYZ(t, e, n, i) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
            }

            setXYZW(t, e, n, i, r) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this
            }

            clone(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                    }
                    return new Is(new this.array.constructor(t), this.itemSize, this.normalized)
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Su(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
            }

            toJSON(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: t,
                        normalized: this.normalized
                    }
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }

        Su.prototype.isInterleavedBufferAttribute = !0;

        class Mu extends bs {
            constructor(t) {
                super(), this.type = "SpriteMaterial", this.color = new Ps(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
            }

            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
            }
        }

        let Tu;
        Mu.prototype.isSpriteMaterial = !0;
        const Eu = new oo, Au = new oo, Pu = new oo, Lu = new jr, Cu = new jr, Ru = new No, Iu = new oo, Ou = new oo,
            Du = new oo, zu = new jr, ku = new jr, Nu = new jr;

        class Bu extends ls {
            constructor(t) {
                if (super(), this.type = "Sprite", void 0 === Tu) {
                    Tu = new Gs;
                    const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                        e = new bu(t, 5);
                    Tu.setIndex([0, 1, 2, 0, 2, 3]), Tu.setAttribute("position", new Su(e, 3, 0, !1)), Tu.setAttribute("uv", new Su(e, 2, 3, !1))
                }
                this.geometry = Tu, this.material = void 0 !== t ? t : new Mu, this.center = new jr(.5, .5)
            }

            raycast(t, e) {
                null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Au.setFromMatrixScale(this.matrixWorld), Ru.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Pu.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Au.multiplyScalar(-Pu.z);
                const n = this.material.rotation;
                let i, r;
                0 !== n && (r = Math.cos(n), i = Math.sin(n));
                const o = this.center;
                Fu(Iu.set(-.5, -.5, 0), Pu, o, Au, i, r), Fu(Ou.set(.5, -.5, 0), Pu, o, Au, i, r), Fu(Du.set(.5, .5, 0), Pu, o, Au, i, r), zu.set(0, 0), ku.set(1, 0), Nu.set(1, 1);
                let s = t.ray.intersectTriangle(Iu, Ou, Du, !1, Eu);
                if (null === s && (Fu(Ou.set(-.5, .5, 0), Pu, o, Au, i, r), ku.set(0, 1), s = t.ray.intersectTriangle(Iu, Du, Ou, !1, Eu), null === s)) return;
                const a = t.ray.origin.distanceTo(Eu);
                a < t.near || a > t.far || e.push({
                    distance: a,
                    point: Eu.clone(),
                    uv: xs.getUV(Eu, Iu, Ou, Du, zu, ku, Nu, new jr),
                    face: null,
                    object: this
                })
            }

            copy(t) {
                return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
            }
        }

        function Fu(t, e, n, i, r, o) {
            Lu.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (Cu.x = o * Lu.x - r * Lu.y, Cu.y = r * Lu.x + o * Lu.y) : Cu.copy(Lu), t.copy(e), t.x += Cu.x, t.y += Cu.y, t.applyMatrix4(Ru)
        }

        Bu.prototype.isSprite = !0;
        const Uu = new oo, Hu = new eo, Vu = new eo, Gu = new oo, Wu = new No;

        class ju extends aa {
            constructor(t, e) {
                super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new No, this.bindMatrixInverse = new No
            }

            copy(t) {
                return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
            }

            bind(t, e) {
                this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
            }

            pose() {
                this.skeleton.pose()
            }

            normalizeSkinWeights() {
                const t = new eo, e = this.geometry.attributes.skinWeight;
                for (let n = 0, i = e.count; n < i; n++) {
                    t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                    const i = 1 / t.manhattanLength();
                    i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                }
            }

            updateMatrixWorld(t) {
                super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }

            boneTransform(t, e) {
                const n = this.skeleton, i = this.geometry;
                Hu.fromBufferAttribute(i.attributes.skinIndex, t), Vu.fromBufferAttribute(i.attributes.skinWeight, t), Uu.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                for (let t = 0; t < 4; t++) {
                    const i = Vu.getComponent(t);
                    if (0 !== i) {
                        const r = Hu.getComponent(t);
                        Wu.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Gu.copy(Uu).applyMatrix4(Wu), i)
                    }
                }
                return e.applyMatrix4(this.bindMatrixInverse)
            }
        }

        ju.prototype.isSkinnedMesh = !0;

        class qu extends ls {
            constructor() {
                super(), this.type = "Bone"
            }
        }

        qu.prototype.isBone = !0;

        class Xu extends $r {
            constructor(t = null, e = 1, n = 1, i, r, o, s, a, l = 1003, c = 1003, u, h) {
                super(null, o, s, a, l, c, i, r, u, h), this.image = {
                    data: t,
                    width: e,
                    height: n
                }, this.magFilter = l, this.minFilter = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
            }
        }

        Xu.prototype.isDataTexture = !0;

        class Yu extends Is {
            constructor(t, e, n, i = 1) {
                "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = i
            }

            copy(t) {
                return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
            }

            toJSON() {
                const t = super.toJSON();
                return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
            }
        }

        Yu.prototype.isInstancedBufferAttribute = !0;
        const Ju = new No, Zu = new No, Qu = [], Ku = new aa;

        class $u extends aa {
            constructor(t, e, n) {
                super(t, e), this.instanceMatrix = new Yu(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
            }

            copy(t) {
                return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this
            }

            getColorAt(t, e) {
                e.fromArray(this.instanceColor.array, 3 * t)
            }

            getMatrixAt(t, e) {
                e.fromArray(this.instanceMatrix.array, 16 * t)
            }

            raycast(t, e) {
                const n = this.matrixWorld, i = this.count;
                if (Ku.geometry = this.geometry, Ku.material = this.material, void 0 !== Ku.material) for (let r = 0; r < i; r++) {
                    this.getMatrixAt(r, Ju), Zu.multiplyMatrices(n, Ju), Ku.matrixWorld = Zu, Ku.raycast(t, Qu);
                    for (let t = 0, n = Qu.length; t < n; t++) {
                        const n = Qu[t];
                        n.instanceId = r, n.object = this, e.push(n)
                    }
                    Qu.length = 0
                }
            }

            setColorAt(t, e) {
                null === this.instanceColor && (this.instanceColor = new Yu(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
            }

            setMatrixAt(t, e) {
                e.toArray(this.instanceMatrix.array, 16 * t)
            }

            updateMorphTargets() {
            }

            dispose() {
                this.dispatchEvent({type: "dispose"})
            }
        }

        $u.prototype.isInstancedMesh = !0;

        class th extends bs {
            constructor(t) {
                super(), this.type = "LineBasicMaterial", this.color = new Ps(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t)
            }

            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
            }
        }

        th.prototype.isLineBasicMaterial = !0;
        const eh = new oo, nh = new oo, ih = new No, rh = new ko, oh = new Po;

        class sh extends ls {
            constructor(t = new Gs, e = new th) {
                super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
            }

            copy(t) {
                return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
            }

            computeLineDistances() {
                const t = this.geometry;
                if (t.isBufferGeometry) if (null === t.index) {
                    const e = t.attributes.position, n = [0];
                    for (let t = 1, i = e.count; t < i; t++) eh.fromBufferAttribute(e, t - 1), nh.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += eh.distanceTo(nh);
                    t.setAttribute("lineDistance", new zs(n, 1))
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }

            raycast(t, e) {
                const n = this.geometry, i = this.matrixWorld, r = t.params.Line.threshold, o = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), oh.copy(n.boundingSphere), oh.applyMatrix4(i), oh.radius += r, !1 === t.ray.intersectsSphere(oh)) return;
                ih.copy(i).invert(), rh.copy(t.ray).applyMatrix4(ih);
                const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = s * s, l = new oo, c = new oo,
                    u = new oo, h = new oo, d = this.isLineSegments ? 2 : 1;
                if (n.isBufferGeometry) {
                    const i = n.index, r = n.attributes.position;
                    if (null !== i) {
                        for (let n = Math.max(0, o.start), s = Math.min(i.count, o.start + o.count) - 1; n < s; n += d) {
                            const o = i.getX(n), s = i.getX(n + 1);
                            l.fromBufferAttribute(r, o), c.fromBufferAttribute(r, s);
                            if (rh.distanceSqToSegment(l, c, h, u) > a) continue;
                            h.applyMatrix4(this.matrixWorld);
                            const d = t.ray.origin.distanceTo(h);
                            d < t.near || d > t.far || e.push({
                                distance: d,
                                point: u.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    } else {
                        for (let n = Math.max(0, o.start), i = Math.min(r.count, o.start + o.count) - 1; n < i; n += d) {
                            l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1);
                            if (rh.distanceSqToSegment(l, c, h, u) > a) continue;
                            h.applyMatrix4(this.matrixWorld);
                            const i = t.ray.origin.distanceTo(h);
                            i < t.near || i > t.far || e.push({
                                distance: i,
                                point: u.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    }
                } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }

            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes, n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        }

        sh.prototype.isLine = !0;
        const ah = new oo, lh = new oo;

        class ch extends sh {
            constructor(t, e) {
                super(t, e), this.type = "LineSegments"
            }

            computeLineDistances() {
                const t = this.geometry;
                if (t.isBufferGeometry) if (null === t.index) {
                    const e = t.attributes.position, n = [];
                    for (let t = 0, i = e.count; t < i; t += 2) ah.fromBufferAttribute(e, t), lh.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + ah.distanceTo(lh);
                    t.setAttribute("lineDistance", new zs(n, 1))
                } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }
        }

        ch.prototype.isLineSegments = !0;

        class uh extends sh {
            constructor(t, e) {
                super(t, e), this.type = "LineLoop"
            }
        }

        uh.prototype.isLineLoop = !0;

        class hh extends bs {
            constructor(t) {
                super(), this.type = "PointsMaterial", this.color = new Ps(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(t)
            }

            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this
            }
        }

        hh.prototype.isPointsMaterial = !0;
        const dh = new No, ph = new ko, fh = new Po, mh = new oo;

        class gh extends ls {
            constructor(t = new Gs, e = new hh) {
                super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
            }

            copy(t) {
                return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
            }

            raycast(t, e) {
                const n = this.geometry, i = this.matrixWorld, r = t.params.Points.threshold, o = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), fh.copy(n.boundingSphere), fh.applyMatrix4(i), fh.radius += r, !1 === t.ray.intersectsSphere(fh)) return;
                dh.copy(i).invert(), ph.copy(t.ray).applyMatrix4(dh);
                const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = s * s;
                if (n.isBufferGeometry) {
                    const r = n.index, s = n.attributes.position;
                    if (null !== r) {
                        for (let n = Math.max(0, o.start), l = Math.min(r.count, o.start + o.count); n < l; n++) {
                            const o = r.getX(n);
                            mh.fromBufferAttribute(s, o), vh(mh, o, a, i, t, e, this)
                        }
                    } else {
                        for (let n = Math.max(0, o.start), r = Math.min(s.count, o.start + o.count); n < r; n++) mh.fromBufferAttribute(s, n), vh(mh, n, a, i, t, e, this)
                    }
                } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }

            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes, n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        }

        function vh(t, e, n, i, r, o, s) {
            const a = ph.distanceSqToPoint(t);
            if (a < n) {
                const n = new oo;
                ph.closestPointToPoint(t, n), n.applyMatrix4(i);
                const l = r.ray.origin.distanceTo(n);
                if (l < r.near || l > r.far) return;
                o.push({distance: l, distanceToRay: Math.sqrt(a), point: n, index: e, face: null, object: s})
            }
        }

        gh.prototype.isPoints = !0;

        class yh extends $r {
            constructor(t, e, n, i, r, o, s, a, l) {
                super(t, e, n, i, r, o, s, a, l), this.format = void 0 !== s ? s : gr, this.minFilter = void 0 !== o ? o : lr, this.magFilter = void 0 !== r ? r : lr, this.generateMipmaps = !1;
                const c = this;
                "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
                    c.needsUpdate = !0, t.requestVideoFrameCallback(e)
                }))
            }

            clone() {
                return new this.constructor(this.image).copy(this)
            }

            update() {
                const t = this.image;
                !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }

        yh.prototype.isVideoTexture = !0;

        class xh extends $r {
            constructor(t, e, n, i, r, o, s, a, l, c, u, h) {
                super(null, o, s, a, l, c, i, r, u, h), this.image = {
                    width: e,
                    height: n
                }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
            }
        }

        xh.prototype.isCompressedTexture = !0;
        (class extends $r {
            constructor(t, e, n, i, r, o, s, a, l) {
                super(t, e, n, i, r, o, s, a, l), this.needsUpdate = !0
            }
        }).prototype.isCanvasTexture = !0;
        new oo, new oo, new oo, new xs;

        class _h {
            constructor() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }

            getPoint() {
                return console.warn("THREE.Curve: .getPoint() not implemented."), null
            }

            getPointAt(t, e) {
                const n = this.getUtoTmapping(t);
                return this.getPoint(n, e)
            }

            getPoints(t = 5) {
                const e = [];
                for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                return e
            }

            getSpacedPoints(t = 5) {
                const e = [];
                for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                return e
            }

            getLength() {
                const t = this.getLengths();
                return t[t.length - 1]
            }

            getLengths(t = this.arcLengthDivisions) {
                if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                const e = [];
                let n, i = this.getPoint(0), r = 0;
                e.push(0);
                for (let o = 1; o <= t; o++) n = this.getPoint(o / t), r += n.distanceTo(i), e.push(r), i = n;
                return this.cacheArcLengths = e, e
            }

            updateArcLengths() {
                this.needsUpdate = !0, this.getLengths()
            }

            getUtoTmapping(t, e) {
                const n = this.getLengths();
                let i = 0;
                const r = n.length;
                let o;
                o = e || t * n[r - 1];
                let s, a = 0, l = r - 1;
                for (; a <= l;) if (i = Math.floor(a + (l - a) / 2), s = n[i] - o, s < 0) a = i + 1; else {
                    if (!(s > 0)) {
                        l = i;
                        break
                    }
                    l = i - 1
                }
                if (i = l, n[i] === o) return i / (r - 1);
                const c = n[i];
                return (i + (o - c) / (n[i + 1] - c)) / (r - 1)
            }

            getTangent(t, e) {
                const n = 1e-4;
                let i = t - n, r = t + n;
                i < 0 && (i = 0), r > 1 && (r = 1);
                const o = this.getPoint(i), s = this.getPoint(r), a = e || (o.isVector2 ? new jr : new oo);
                return a.copy(s).sub(o).normalize(), a
            }

            getTangentAt(t, e) {
                const n = this.getUtoTmapping(t);
                return this.getTangent(n, e)
            }

            computeFrenetFrames(t, e) {
                const n = new oo, i = [], r = [], o = [], s = new oo, a = new No;
                for (let e = 0; e <= t; e++) {
                    const n = e / t;
                    i[e] = this.getTangentAt(n, new oo)
                }
                r[0] = new oo, o[0] = new oo;
                let l = Number.MAX_VALUE;
                const c = Math.abs(i[0].x), u = Math.abs(i[0].y), h = Math.abs(i[0].z);
                c <= l && (l = c, n.set(1, 0, 0)), u <= l && (l = u, n.set(0, 1, 0)), h <= l && n.set(0, 0, 1), s.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], s), o[0].crossVectors(i[0], r[0]);
                for (let e = 1; e <= t; e++) {
                    if (r[e] = r[e - 1].clone(), o[e] = o[e - 1].clone(), s.crossVectors(i[e - 1], i[e]), s.length() > Number.EPSILON) {
                        s.normalize();
                        const t = Math.acos(Ur(i[e - 1].dot(i[e]), -1, 1));
                        r[e].applyMatrix4(a.makeRotationAxis(s, t))
                    }
                    o[e].crossVectors(i[e], r[e])
                }
                if (!0 === e) {
                    let e = Math.acos(Ur(r[0].dot(r[t]), -1, 1));
                    e /= t, i[0].dot(s.crossVectors(r[0], r[t])) > 0 && (e = -e);
                    for (let n = 1; n <= t; n++) r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)), o[n].crossVectors(i[n], r[n])
                }
                return {tangents: i, normals: r, binormals: o}
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            copy(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            }

            toJSON() {
                const t = {metadata: {version: 4.5, type: "Curve", generator: "Curve.toJSON"}};
                return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
            }

            fromJSON(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            }
        }

        class bh extends _h {
            constructor(t = 0, e = 0, n = 1, i = 1, r = 0, o = 2 * Math.PI, s = !1, a = 0) {
                super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = o, this.aClockwise = s, this.aRotation = a
            }

            getPoint(t, e) {
                const n = e || new jr, i = 2 * Math.PI;
                let r = this.aEndAngle - this.aStartAngle;
                const o = Math.abs(r) < Number.EPSILON;
                for (; r < 0;) r += i;
                for (; r > i;) r -= i;
                r < Number.EPSILON && (r = o ? 0 : i), !0 !== this.aClockwise || o || (r === i ? r = -i : r -= i);
                const s = this.aStartAngle + t * r;
                let a = this.aX + this.xRadius * Math.cos(s), l = this.aY + this.yRadius * Math.sin(s);
                if (0 !== this.aRotation) {
                    const t = Math.cos(this.aRotation), e = Math.sin(this.aRotation), n = a - this.aX, i = l - this.aY;
                    a = n * t - i * e + this.aX, l = n * e + i * t + this.aY
                }
                return n.set(a, l)
            }

            copy(t) {
                return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }

            toJSON() {
                const t = super.toJSON();
                return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
            }

            fromJSON(t) {
                return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }
        }

        bh.prototype.isEllipseCurve = !0;

        class wh extends bh {
            constructor(t, e, n, i, r, o) {
                super(t, e, n, n, i, r, o), this.type = "ArcCurve"
            }
        }

        function Sh() {
            let t = 0, e = 0, n = 0, i = 0;

            function r(r, o, s, a) {
                t = r, e = s, n = -3 * r + 3 * o - 2 * s - a, i = 2 * r - 2 * o + s + a
            }

            return {
                initCatmullRom: function (t, e, n, i, o) {
                    r(e, n, o * (n - t), o * (i - e))
                }, initNonuniformCatmullRom: function (t, e, n, i, o, s, a) {
                    let l = (e - t) / o - (n - t) / (o + s) + (n - e) / s,
                        c = (n - e) / s - (i - e) / (s + a) + (i - n) / a;
                    l *= s, c *= s, r(e, n, l, c)
                }, calc: function (r) {
                    const o = r * r;
                    return t + e * r + n * o + i * (o * r)
                }
            }
        }

        wh.prototype.isArcCurve = !0;
        const Mh = new oo, Th = new Sh, Eh = new Sh, Ah = new Sh;

        class Ph extends _h {
            constructor(t = [], e = !1, n = "centripetal", i = .5) {
                super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = i
            }

            getPoint(t, e = new oo) {
                const n = e, i = this.points, r = i.length, o = (r - (this.closed ? 0 : 1)) * t;
                let s, a, l = Math.floor(o), c = o - l;
                this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? s = i[(l - 1) % r] : (Mh.subVectors(i[0], i[1]).add(i[0]), s = Mh);
                const u = i[l % r], h = i[(l + 1) % r];
                if (this.closed || l + 2 < r ? a = i[(l + 2) % r] : (Mh.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), a = Mh), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    const t = "chordal" === this.curveType ? .5 : .25;
                    let e = Math.pow(s.distanceToSquared(u), t), n = Math.pow(u.distanceToSquared(h), t),
                        i = Math.pow(h.distanceToSquared(a), t);
                    n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), Th.initNonuniformCatmullRom(s.x, u.x, h.x, a.x, e, n, i), Eh.initNonuniformCatmullRom(s.y, u.y, h.y, a.y, e, n, i), Ah.initNonuniformCatmullRom(s.z, u.z, h.z, a.z, e, n, i)
                } else "catmullrom" === this.curveType && (Th.initCatmullRom(s.x, u.x, h.x, a.x, this.tension), Eh.initCatmullRom(s.y, u.y, h.y, a.y, this.tension), Ah.initCatmullRom(s.z, u.z, h.z, a.z, this.tension));
                return n.set(Th.calc(c), Eh.calc(c), Ah.calc(c)), n
            }

            copy(t) {
                super.copy(t), this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push(n.clone())
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }

            toJSON() {
                const t = super.toJSON();
                t.points = [];
                for (let e = 0, n = this.points.length; e < n; e++) {
                    const n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
            }

            fromJSON(t) {
                super.fromJSON(t), this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push((new oo).fromArray(n))
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }
        }

        function Lh(t, e, n, i, r) {
            const o = .5 * (i - e), s = .5 * (r - n), a = t * t;
            return (2 * n - 2 * i + o + s) * (t * a) + (-3 * n + 3 * i - 2 * o - s) * a + o * t + n
        }

        function Ch(t, e, n, i) {
            return function (t, e) {
                const n = 1 - t;
                return n * n * e
            }(t, e) + function (t, e) {
                return 2 * (1 - t) * t * e
            }(t, n) + function (t, e) {
                return t * t * e
            }(t, i)
        }

        function Rh(t, e, n, i, r) {
            return function (t, e) {
                const n = 1 - t;
                return n * n * n * e
            }(t, e) + function (t, e) {
                const n = 1 - t;
                return 3 * n * n * t * e
            }(t, n) + function (t, e) {
                return 3 * (1 - t) * t * t * e
            }(t, i) + function (t, e) {
                return t * t * t * e
            }(t, r)
        }

        Ph.prototype.isCatmullRomCurve3 = !0;

        class Ih extends _h {
            constructor(t = new jr, e = new jr, n = new jr, i = new jr) {
                super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
            }

            getPoint(t, e = new jr) {
                const n = e, i = this.v0, r = this.v1, o = this.v2, s = this.v3;
                return n.set(Rh(t, i.x, r.x, o.x, s.x), Rh(t, i.y, r.y, o.y, s.y)), n
            }

            copy(t) {
                return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }

            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }

            fromJSON(t) {
                return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }
        }

        Ih.prototype.isCubicBezierCurve = !0;

        class Oh extends _h {
            constructor(t = new oo, e = new oo, n = new oo, i = new oo) {
                super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
            }

            getPoint(t, e = new oo) {
                const n = e, i = this.v0, r = this.v1, o = this.v2, s = this.v3;
                return n.set(Rh(t, i.x, r.x, o.x, s.x), Rh(t, i.y, r.y, o.y, s.y), Rh(t, i.z, r.z, o.z, s.z)), n
            }

            copy(t) {
                return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }

            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }

            fromJSON(t) {
                return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }
        }

        Oh.prototype.isCubicBezierCurve3 = !0;

        class Dh extends _h {
            constructor(t = new jr, e = new jr) {
                super(), this.type = "LineCurve", this.v1 = t, this.v2 = e
            }

            getPoint(t, e = new jr) {
                const n = e;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }

            getPointAt(t, e) {
                return this.getPoint(t, e)
            }

            getTangent(t, e) {
                const n = e || new jr;
                return n.copy(this.v2).sub(this.v1).normalize(), n
            }

            copy(t) {
                return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }

            toJSON() {
                const t = super.toJSON();
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }

            fromJSON(t) {
                return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }
        }

        Dh.prototype.isLineCurve = !0;

        class zh extends _h {
            constructor(t = new jr, e = new jr, n = new jr) {
                super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
            }

            getPoint(t, e = new jr) {
                const n = e, i = this.v0, r = this.v1, o = this.v2;
                return n.set(Ch(t, i.x, r.x, o.x), Ch(t, i.y, r.y, o.y)), n
            }

            copy(t) {
                return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }

            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }

            fromJSON(t) {
                return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }
        }

        zh.prototype.isQuadraticBezierCurve = !0;

        class kh extends _h {
            constructor(t = new oo, e = new oo, n = new oo) {
                super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
            }

            getPoint(t, e = new oo) {
                const n = e, i = this.v0, r = this.v1, o = this.v2;
                return n.set(Ch(t, i.x, r.x, o.x), Ch(t, i.y, r.y, o.y), Ch(t, i.z, r.z, o.z)), n
            }

            copy(t) {
                return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }

            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }

            fromJSON(t) {
                return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }
        }

        kh.prototype.isQuadraticBezierCurve3 = !0;

        class Nh extends _h {
            constructor(t = []) {
                super(), this.type = "SplineCurve", this.points = t
            }

            getPoint(t, e = new jr) {
                const n = e, i = this.points, r = (i.length - 1) * t, o = Math.floor(r), s = r - o,
                    a = i[0 === o ? o : o - 1], l = i[o], c = i[o > i.length - 2 ? i.length - 1 : o + 1],
                    u = i[o > i.length - 3 ? i.length - 1 : o + 2];
                return n.set(Lh(s, a.x, l.x, c.x, u.x), Lh(s, a.y, l.y, c.y, u.y)), n
            }

            copy(t) {
                super.copy(t), this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push(n.clone())
                }
                return this
            }

            toJSON() {
                const t = super.toJSON();
                t.points = [];
                for (let e = 0, n = this.points.length; e < n; e++) {
                    const n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t
            }

            fromJSON(t) {
                super.fromJSON(t), this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push((new jr).fromArray(n))
                }
                return this
            }
        }

        Nh.prototype.isSplineCurve = !0;
        var Bh = Object.freeze({
            __proto__: null,
            ArcCurve: wh,
            CatmullRomCurve3: Ph,
            CubicBezierCurve: Ih,
            CubicBezierCurve3: Oh,
            EllipseCurve: bh,
            LineCurve: Dh,
            LineCurve3: class extends _h {
                constructor(t = new oo, e = new oo) {
                    super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e
                }

                getPoint(t, e = new oo) {
                    const n = e;
                    return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                }

                getPointAt(t, e) {
                    return this.getPoint(t, e)
                }

                copy(t) {
                    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                }

                toJSON() {
                    const t = super.toJSON();
                    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                }

                fromJSON(t) {
                    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                }
            },
            QuadraticBezierCurve: zh,
            QuadraticBezierCurve3: kh,
            SplineCurve: Nh
        });

        class Fh extends _h {
            constructor() {
                super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }

            add(t) {
                this.curves.push(t)
            }

            closePath() {
                const t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new Dh(e, t))
            }

            getPoint(t, e) {
                const n = t * this.getLength(), i = this.getCurveLengths();
                let r = 0;
                for (; r < i.length;) {
                    if (i[r] >= n) {
                        const t = i[r] - n, o = this.curves[r], s = o.getLength(), a = 0 === s ? 0 : 1 - t / s;
                        return o.getPointAt(a, e)
                    }
                    r++
                }
                return null
            }

            getLength() {
                const t = this.getCurveLengths();
                return t[t.length - 1]
            }

            updateArcLengths() {
                this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
            }

            getCurveLengths() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                const t = [];
                let e = 0;
                for (let n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(), t.push(e);
                return this.cacheLengths = t, t
            }

            getSpacedPoints(t = 40) {
                const e = [];
                for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                return this.autoClose && e.push(e[0]), e
            }

            getPoints(t = 12) {
                const e = [];
                let n;
                for (let i = 0, r = this.curves; i < r.length; i++) {
                    const o = r[i],
                        s = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t,
                        a = o.getPoints(s);
                    for (let t = 0; t < a.length; t++) {
                        const i = a[t];
                        n && n.equals(i) || (e.push(i), n = i)
                    }
                }
                return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
            }

            copy(t) {
                super.copy(t), this.curves = [];
                for (let e = 0, n = t.curves.length; e < n; e++) {
                    const n = t.curves[e];
                    this.curves.push(n.clone())
                }
                return this.autoClose = t.autoClose, this
            }

            toJSON() {
                const t = super.toJSON();
                t.autoClose = this.autoClose, t.curves = [];
                for (let e = 0, n = this.curves.length; e < n; e++) {
                    const n = this.curves[e];
                    t.curves.push(n.toJSON())
                }
                return t
            }

            fromJSON(t) {
                super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                for (let e = 0, n = t.curves.length; e < n; e++) {
                    const n = t.curves[e];
                    this.curves.push((new Bh[n.type]).fromJSON(n))
                }
                return this
            }
        }

        class Uh extends Fh {
            constructor(t) {
                super(), this.type = "Path", this.currentPoint = new jr, t && this.setFromPoints(t)
            }

            setFromPoints(t) {
                this.moveTo(t[0].x, t[0].y);
                for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
                return this
            }

            moveTo(t, e) {
                return this.currentPoint.set(t, e), this
            }

            lineTo(t, e) {
                const n = new Dh(this.currentPoint.clone(), new jr(t, e));
                return this.curves.push(n), this.currentPoint.set(t, e), this
            }

            quadraticCurveTo(t, e, n, i) {
                const r = new zh(this.currentPoint.clone(), new jr(t, e), new jr(n, i));
                return this.curves.push(r), this.currentPoint.set(n, i), this
            }

            bezierCurveTo(t, e, n, i, r, o) {
                const s = new Ih(this.currentPoint.clone(), new jr(t, e), new jr(n, i), new jr(r, o));
                return this.curves.push(s), this.currentPoint.set(r, o), this
            }

            splineThru(t) {
                const e = [this.currentPoint.clone()].concat(t), n = new Nh(e);
                return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
            }

            arc(t, e, n, i, r, o) {
                const s = this.currentPoint.x, a = this.currentPoint.y;
                return this.absarc(t + s, e + a, n, i, r, o), this
            }

            absarc(t, e, n, i, r, o) {
                return this.absellipse(t, e, n, n, i, r, o), this
            }

            ellipse(t, e, n, i, r, o, s, a) {
                const l = this.currentPoint.x, c = this.currentPoint.y;
                return this.absellipse(t + l, e + c, n, i, r, o, s, a), this
            }

            absellipse(t, e, n, i, r, o, s, a) {
                const l = new bh(t, e, n, i, r, o, s, a);
                if (this.curves.length > 0) {
                    const t = l.getPoint(0);
                    t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                }
                this.curves.push(l);
                const c = l.getPoint(1);
                return this.currentPoint.copy(c), this
            }

            copy(t) {
                return super.copy(t), this.currentPoint.copy(t.currentPoint), this
            }

            toJSON() {
                const t = super.toJSON();
                return t.currentPoint = this.currentPoint.toArray(), t
            }

            fromJSON(t) {
                return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
            }
        }

        class Hh extends Uh {
            constructor(t) {
                super(t), this.uuid = Fr(), this.type = "Shape", this.holes = []
            }

            getPointsHoles(t) {
                const e = [];
                for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
                return e
            }

            extractPoints(t) {
                return {shape: this.getPoints(t), holes: this.getPointsHoles(t)}
            }

            copy(t) {
                super.copy(t), this.holes = [];
                for (let e = 0, n = t.holes.length; e < n; e++) {
                    const n = t.holes[e];
                    this.holes.push(n.clone())
                }
                return this
            }

            toJSON() {
                const t = super.toJSON();
                t.uuid = this.uuid, t.holes = [];
                for (let e = 0, n = this.holes.length; e < n; e++) {
                    const n = this.holes[e];
                    t.holes.push(n.toJSON())
                }
                return t
            }

            fromJSON(t) {
                super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                for (let e = 0, n = t.holes.length; e < n; e++) {
                    const n = t.holes[e];
                    this.holes.push((new Uh).fromJSON(n))
                }
                return this
            }
        }

        const Vh = function (t, e, n = 2) {
            const i = e && e.length, r = i ? e[0] * n : t.length;
            let o = Gh(t, 0, r, n, !0);
            const s = [];
            if (!o || o.next === o.prev) return s;
            let a, l, c, u, h, d, p;
            if (i && (o = function (t, e, n, i) {
                const r = [];
                let o, s, a, l, c;
                for (o = 0, s = e.length; o < s; o++) a = e[o] * i, l = o < s - 1 ? e[o + 1] * i : t.length, c = Gh(t, a, l, i, !1), c === c.next && (c.steiner = !0), r.push(td(c));
                for (r.sort(Zh), o = 0; o < r.length; o++) Qh(r[o], n), n = Wh(n, n.next);
                return n
            }(t, e, o, n)), t.length > 80 * n) {
                a = c = t[0], l = u = t[1];
                for (let e = n; e < r; e += n) h = t[e], d = t[e + 1], h < a && (a = h), d < l && (l = d), h > c && (c = h), d > u && (u = d);
                p = Math.max(c - a, u - l), p = 0 !== p ? 1 / p : 0
            }
            return jh(o, s, n, a, l, p), s
        };

        function Gh(t, e, n, i, r) {
            let o, s;
            if (r === function (t, e, n, i) {
                let r = 0;
                for (let o = e, s = n - i; o < n; o += i) r += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o;
                return r
            }(t, e, n, i) > 0) for (o = e; o < n; o += i) s = ud(o, t[o], t[o + 1], s); else for (o = n - i; o >= e; o -= i) s = ud(o, t[o], t[o + 1], s);
            return s && rd(s, s.next) && (hd(s), s = s.next), s
        }

        function Wh(t, e) {
            if (!t) return t;
            e || (e = t);
            let n, i = t;
            do {
                if (n = !1, i.steiner || !rd(i, i.next) && 0 !== id(i.prev, i, i.next)) i = i.next; else {
                    if (hd(i), i = e = i.prev, i === i.next) break;
                    n = !0
                }
            } while (n || i !== e);
            return e
        }

        function jh(t, e, n, i, r, o, s) {
            if (!t) return;
            !s && o && function (t, e, n, i) {
                let r = t;
                do {
                    null === r.z && (r.z = $h(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                } while (r !== t);
                r.prevZ.nextZ = null, r.prevZ = null, function (t) {
                    let e, n, i, r, o, s, a, l, c = 1;
                    do {
                        for (n = t, t = null, o = null, s = 0; n;) {
                            for (s++, i = n, a = 0, e = 0; e < c && (a++, i = i.nextZ, i); e++) ;
                            for (l = c; a > 0 || l > 0 && i;) 0 !== a && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, a--) : (r = i, i = i.nextZ, l--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r;
                            n = i
                        }
                        o.nextZ = null, c *= 2
                    } while (s > 1)
                }(r)
            }(t, i, r, o);
            let a, l, c = t;
            for (; t.prev !== t.next;) if (a = t.prev, l = t.next, o ? Xh(t, i, r, o) : qh(t)) e.push(a.i / n), e.push(t.i / n), e.push(l.i / n), hd(t), t = l.next, c = l.next; else if ((t = l) === c) {
                s ? 1 === s ? jh(t = Yh(Wh(t), e, n), e, n, i, r, o, 2) : 2 === s && Jh(t, e, n, i, r, o) : jh(Wh(t), e, n, i, r, o, 1);
                break
            }
        }

        function qh(t) {
            const e = t.prev, n = t, i = t.next;
            if (id(e, n, i) >= 0) return !1;
            let r = t.next.next;
            for (; r !== t.prev;) {
                if (ed(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && id(r.prev, r, r.next) >= 0) return !1;
                r = r.next
            }
            return !0
        }

        function Xh(t, e, n, i) {
            const r = t.prev, o = t, s = t.next;
            if (id(r, o, s) >= 0) return !1;
            const a = r.x < o.x ? r.x < s.x ? r.x : s.x : o.x < s.x ? o.x : s.x,
                l = r.y < o.y ? r.y < s.y ? r.y : s.y : o.y < s.y ? o.y : s.y,
                c = r.x > o.x ? r.x > s.x ? r.x : s.x : o.x > s.x ? o.x : s.x,
                u = r.y > o.y ? r.y > s.y ? r.y : s.y : o.y > s.y ? o.y : s.y, h = $h(a, l, e, n, i),
                d = $h(c, u, e, n, i);
            let p = t.prevZ, f = t.nextZ;
            for (; p && p.z >= h && f && f.z <= d;) {
                if (p !== t.prev && p !== t.next && ed(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) && id(p.prev, p, p.next) >= 0) return !1;
                if (p = p.prevZ, f !== t.prev && f !== t.next && ed(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && id(f.prev, f, f.next) >= 0) return !1;
                f = f.nextZ
            }
            for (; p && p.z >= h;) {
                if (p !== t.prev && p !== t.next && ed(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) && id(p.prev, p, p.next) >= 0) return !1;
                p = p.prevZ
            }
            for (; f && f.z <= d;) {
                if (f !== t.prev && f !== t.next && ed(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && id(f.prev, f, f.next) >= 0) return !1;
                f = f.nextZ
            }
            return !0
        }

        function Yh(t, e, n) {
            let i = t;
            do {
                const r = i.prev, o = i.next.next;
                !rd(r, o) && od(r, i, i.next, o) && ld(r, o) && ld(o, r) && (e.push(r.i / n), e.push(i.i / n), e.push(o.i / n), hd(i), hd(i.next), i = t = o), i = i.next
            } while (i !== t);
            return Wh(i)
        }

        function Jh(t, e, n, i, r, o) {
            let s = t;
            do {
                let t = s.next.next;
                for (; t !== s.prev;) {
                    if (s.i !== t.i && nd(s, t)) {
                        let a = cd(s, t);
                        return s = Wh(s, s.next), a = Wh(a, a.next), jh(s, e, n, i, r, o), void jh(a, e, n, i, r, o)
                    }
                    t = t.next
                }
                s = s.next
            } while (s !== t)
        }

        function Zh(t, e) {
            return t.x - e.x
        }

        function Qh(t, e) {
            if (e = function (t, e) {
                let n = e;
                const i = t.x, r = t.y;
                let o, s = -1 / 0;
                do {
                    if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                        const t = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                        if (t <= i && t > s) {
                            if (s = t, t === i) {
                                if (r === n.y) return n;
                                if (r === n.next.y) return n.next
                            }
                            o = n.x < n.next.x ? n : n.next
                        }
                    }
                    n = n.next
                } while (n !== e);
                if (!o) return null;
                if (i === s) return o;
                const a = o, l = o.x, c = o.y;
                let u, h = 1 / 0;
                n = o;
                do {
                    i >= n.x && n.x >= l && i !== n.x && ed(r < c ? i : s, r, l, c, r < c ? s : i, r, n.x, n.y) && (u = Math.abs(r - n.y) / (i - n.x), ld(n, t) && (u < h || u === h && (n.x > o.x || n.x === o.x && Kh(o, n))) && (o = n, h = u)), n = n.next
                } while (n !== a);
                return o
            }(t, e), e) {
                const n = cd(e, t);
                Wh(e, e.next), Wh(n, n.next)
            }
        }

        function Kh(t, e) {
            return id(t.prev, t, e.prev) < 0 && id(e.next, t, t.next) < 0
        }

        function $h(t, e, n, i, r) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }

        function td(t) {
            let e = t, n = t;
            do {
                (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
            } while (e !== t);
            return n
        }

        function ed(t, e, n, i, r, o, s, a) {
            return (r - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (i - a) - (n - s) * (e - a) >= 0 && (n - s) * (o - a) - (r - s) * (i - a) >= 0
        }

        function nd(t, e) {
            return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {
                let n = t;
                do {
                    if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && od(n, n.next, t, e)) return !0;
                    n = n.next
                } while (n !== t);
                return !1
            }(t, e) && (ld(t, e) && ld(e, t) && function (t, e) {
                let n = t, i = !1;
                const r = (t.x + e.x) / 2, o = (t.y + e.y) / 2;
                do {
                    n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                } while (n !== t);
                return i
            }(t, e) && (id(t.prev, t, e.prev) || id(t, e.prev, e)) || rd(t, e) && id(t.prev, t, t.next) > 0 && id(e.prev, e, e.next) > 0)
        }

        function id(t, e, n) {
            return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
        }

        function rd(t, e) {
            return t.x === e.x && t.y === e.y
        }

        function od(t, e, n, i) {
            const r = ad(id(t, e, n)), o = ad(id(t, e, i)), s = ad(id(n, i, t)), a = ad(id(n, i, e));
            return r !== o && s !== a || (!(0 !== r || !sd(t, n, e)) || (!(0 !== o || !sd(t, i, e)) || (!(0 !== s || !sd(n, t, i)) || !(0 !== a || !sd(n, e, i)))))
        }

        function sd(t, e, n) {
            return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
        }

        function ad(t) {
            return t > 0 ? 1 : t < 0 ? -1 : 0
        }

        function ld(t, e) {
            return id(t.prev, t, t.next) < 0 ? id(t, e, t.next) >= 0 && id(t, t.prev, e) >= 0 : id(t, e, t.prev) < 0 || id(t, t.next, e) < 0
        }

        function cd(t, e) {
            const n = new dd(t.i, t.x, t.y), i = new dd(e.i, e.x, e.y), r = t.next, o = e.prev;
            return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i
        }

        function ud(t, e, n, i) {
            const r = new dd(t, e, n);
            return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
        }

        function hd(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }

        function dd(t, e, n) {
            this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }

        class pd {
            static area(t) {
                const e = t.length;
                let n = 0;
                for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
                return .5 * n
            }

            static isClockWise(t) {
                return pd.area(t) < 0
            }

            static triangulateShape(t, e) {
                const n = [], i = [], r = [];
                fd(t), md(n, t);
                let o = t.length;
                e.forEach(fd);
                for (let t = 0; t < e.length; t++) i.push(o), o += e[t].length, md(n, e[t]);
                const s = Vh(n, i);
                for (let t = 0; t < s.length; t += 3) r.push(s.slice(t, t + 3));
                return r
            }
        }

        function fd(t) {
            const e = t.length;
            e > 2 && t[e - 1].equals(t[0]) && t.pop()
        }

        function md(t, e) {
            for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
        }

        class gd extends Gs {
            constructor(t = new Hh([new jr(.5, .5), new jr(-.5, .5), new jr(-.5, -.5), new jr(.5, -.5)]), e = {}) {
                super(), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: t,
                    options: e
                }, t = Array.isArray(t) ? t : [t];
                const n = this, i = [], r = [];
                for (let e = 0, n = t.length; e < n; e++) {
                    o(t[e])
                }

                function o(t) {
                    const o = [], s = void 0 !== e.curveSegments ? e.curveSegments : 12,
                        a = void 0 !== e.steps ? e.steps : 1;
                    let l = void 0 !== e.depth ? e.depth : 1, c = void 0 === e.bevelEnabled || e.bevelEnabled,
                        u = void 0 !== e.bevelThickness ? e.bevelThickness : .2,
                        h = void 0 !== e.bevelSize ? e.bevelSize : u - .1,
                        d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                        p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                    const f = e.extrudePath, m = void 0 !== e.UVGenerator ? e.UVGenerator : vd;
                    void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
                    let g, v, y, x, _, b = !1;
                    f && (g = f.getSpacedPoints(a), b = !0, c = !1, v = f.computeFrenetFrames(a, !1), y = new oo, x = new oo, _ = new oo), c || (p = 0, u = 0, h = 0, d = 0);
                    const w = t.extractPoints(s);
                    let S = w.shape;
                    const M = w.holes;
                    if (!pd.isClockWise(S)) {
                        S = S.reverse();
                        for (let t = 0, e = M.length; t < e; t++) {
                            const e = M[t];
                            pd.isClockWise(e) && (M[t] = e.reverse())
                        }
                    }
                    const T = pd.triangulateShape(S, M), E = S;
                    for (let t = 0, e = M.length; t < e; t++) {
                        const e = M[t];
                        S = S.concat(e)
                    }

                    function A(t, e, n) {
                        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
                    }

                    const P = S.length, L = T.length;

                    function C(t, e, n) {
                        let i, r, o;
                        const s = t.x - e.x, a = t.y - e.y, l = n.x - t.x, c = n.y - t.y, u = s * s + a * a,
                            h = s * c - a * l;
                        if (Math.abs(h) > Number.EPSILON) {
                            const h = Math.sqrt(u), d = Math.sqrt(l * l + c * c), p = e.x - a / h, f = e.y + s / h,
                                m = ((n.x - c / d - p) * c - (n.y + l / d - f) * l) / (s * c - a * l);
                            i = p + s * m - t.x, r = f + a * m - t.y;
                            const g = i * i + r * r;
                            if (g <= 2) return new jr(i, r);
                            o = Math.sqrt(g / 2)
                        } else {
                            let t = !1;
                            s > Number.EPSILON ? l > Number.EPSILON && (t = !0) : s < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(c) && (t = !0), t ? (i = -a, r = s, o = Math.sqrt(u)) : (i = s, r = a, o = Math.sqrt(u / 2))
                        }
                        return new jr(i / o, r / o)
                    }

                    const R = [];
                    for (let t = 0, e = E.length, n = e - 1, i = t + 1; t < e; t++, n++, i++) n === e && (n = 0), i === e && (i = 0), R[t] = C(E[t], E[n], E[i]);
                    const I = [];
                    let O, D = R.concat();
                    for (let t = 0, e = M.length; t < e; t++) {
                        const e = M[t];
                        O = [];
                        for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++, i++, r++) i === n && (i = 0), r === n && (r = 0), O[t] = C(e[t], e[i], e[r]);
                        I.push(O), D = D.concat(O)
                    }
                    for (let t = 0; t < p; t++) {
                        const e = t / p, n = u * Math.cos(e * Math.PI / 2), i = h * Math.sin(e * Math.PI / 2) + d;
                        for (let t = 0, e = E.length; t < e; t++) {
                            const e = A(E[t], R[t], i);
                            N(e.x, e.y, -n)
                        }
                        for (let t = 0, e = M.length; t < e; t++) {
                            const e = M[t];
                            O = I[t];
                            for (let t = 0, r = e.length; t < r; t++) {
                                const r = A(e[t], O[t], i);
                                N(r.x, r.y, -n)
                            }
                        }
                    }
                    const z = h + d;
                    for (let t = 0; t < P; t++) {
                        const e = c ? A(S[t], D[t], z) : S[t];
                        b ? (x.copy(v.normals[0]).multiplyScalar(e.x), y.copy(v.binormals[0]).multiplyScalar(e.y), _.copy(g[0]).add(x).add(y), N(_.x, _.y, _.z)) : N(e.x, e.y, 0)
                    }
                    for (let t = 1; t <= a; t++) for (let e = 0; e < P; e++) {
                        const n = c ? A(S[e], D[e], z) : S[e];
                        b ? (x.copy(v.normals[t]).multiplyScalar(n.x), y.copy(v.binormals[t]).multiplyScalar(n.y), _.copy(g[t]).add(x).add(y), N(_.x, _.y, _.z)) : N(n.x, n.y, l / a * t)
                    }
                    for (let t = p - 1; t >= 0; t--) {
                        const e = t / p, n = u * Math.cos(e * Math.PI / 2), i = h * Math.sin(e * Math.PI / 2) + d;
                        for (let t = 0, e = E.length; t < e; t++) {
                            const e = A(E[t], R[t], i);
                            N(e.x, e.y, l + n)
                        }
                        for (let t = 0, e = M.length; t < e; t++) {
                            const e = M[t];
                            O = I[t];
                            for (let t = 0, r = e.length; t < r; t++) {
                                const r = A(e[t], O[t], i);
                                b ? N(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : N(r.x, r.y, l + n)
                            }
                        }
                    }

                    function k(t, e) {
                        let n = t.length;
                        for (; --n >= 0;) {
                            const i = n;
                            let r = n - 1;
                            r < 0 && (r = t.length - 1);
                            for (let t = 0, n = a + 2 * p; t < n; t++) {
                                const n = P * t, o = P * (t + 1);
                                F(e + i + n, e + r + n, e + r + o, e + i + o)
                            }
                        }
                    }

                    function N(t, e, n) {
                        o.push(t), o.push(e), o.push(n)
                    }

                    function B(t, e, r) {
                        U(t), U(e), U(r);
                        const o = i.length / 3, s = m.generateTopUV(n, i, o - 3, o - 2, o - 1);
                        H(s[0]), H(s[1]), H(s[2])
                    }

                    function F(t, e, r, o) {
                        U(t), U(e), U(o), U(e), U(r), U(o);
                        const s = i.length / 3, a = m.generateSideWallUV(n, i, s - 6, s - 3, s - 2, s - 1);
                        H(a[0]), H(a[1]), H(a[3]), H(a[1]), H(a[2]), H(a[3])
                    }

                    function U(t) {
                        i.push(o[3 * t + 0]), i.push(o[3 * t + 1]), i.push(o[3 * t + 2])
                    }

                    function H(t) {
                        r.push(t.x), r.push(t.y)
                    }

                    !function () {
                        const t = i.length / 3;
                        if (c) {
                            let t = 0, e = P * t;
                            for (let t = 0; t < L; t++) {
                                const n = T[t];
                                B(n[2] + e, n[1] + e, n[0] + e)
                            }
                            t = a + 2 * p, e = P * t;
                            for (let t = 0; t < L; t++) {
                                const n = T[t];
                                B(n[0] + e, n[1] + e, n[2] + e)
                            }
                        } else {
                            for (let t = 0; t < L; t++) {
                                const e = T[t];
                                B(e[2], e[1], e[0])
                            }
                            for (let t = 0; t < L; t++) {
                                const e = T[t];
                                B(e[0] + P * a, e[1] + P * a, e[2] + P * a)
                            }
                        }
                        n.addGroup(t, i.length / 3 - t, 0)
                    }(), function () {
                        const t = i.length / 3;
                        let e = 0;
                        k(E, e), e += E.length;
                        for (let t = 0, n = M.length; t < n; t++) {
                            const n = M[t];
                            k(n, e), e += n.length
                        }
                        n.addGroup(t, i.length / 3 - t, 1)
                    }()
                }

                this.setAttribute("position", new zs(i, 3)), this.setAttribute("uv", new zs(r, 2)), this.computeVertexNormals()
            }

            toJSON() {
                const t = super.toJSON();
                return function (t, e, n) {
                    if (n.shapes = [], Array.isArray(t)) for (let e = 0, i = t.length; e < i; e++) {
                        const i = t[e];
                        n.shapes.push(i.uuid)
                    } else n.shapes.push(t.uuid);
                    void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON());
                    return n
                }(this.parameters.shapes, this.parameters.options, t)
            }

            static fromJSON(t, e) {
                const n = [];
                for (let i = 0, r = t.shapes.length; i < r; i++) {
                    const r = e[t.shapes[i]];
                    n.push(r)
                }
                const i = t.options.extrudePath;
                return void 0 !== i && (t.options.extrudePath = (new Bh[i.type]).fromJSON(i)), new gd(n, t.options)
            }
        }

        const vd = {
            generateTopUV: function (t, e, n, i, r) {
                const o = e[3 * n], s = e[3 * n + 1], a = e[3 * i], l = e[3 * i + 1], c = e[3 * r], u = e[3 * r + 1];
                return [new jr(o, s), new jr(a, l), new jr(c, u)]
            }, generateSideWallUV: function (t, e, n, i, r, o) {
                const s = e[3 * n], a = e[3 * n + 1], l = e[3 * n + 2], c = e[3 * i], u = e[3 * i + 1],
                    h = e[3 * i + 2], d = e[3 * r], p = e[3 * r + 1], f = e[3 * r + 2], m = e[3 * o], g = e[3 * o + 1],
                    v = e[3 * o + 2];
                return Math.abs(a - u) < Math.abs(s - c) ? [new jr(s, 1 - l), new jr(c, 1 - h), new jr(d, 1 - f), new jr(m, 1 - v)] : [new jr(a, 1 - l), new jr(u, 1 - h), new jr(p, 1 - f), new jr(g, 1 - v)]
            }
        };

        class yd extends Gs {
            constructor(t = new Hh([new jr(0, .5), new jr(-.5, -.5), new jr(.5, -.5)]), e = 12) {
                super(), this.type = "ShapeGeometry", this.parameters = {shapes: t, curveSegments: e};
                const n = [], i = [], r = [], o = [];
                let s = 0, a = 0;
                if (!1 === Array.isArray(t)) l(t); else for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(s, a, e), s += a, a = 0;

                function l(t) {
                    const s = i.length / 3, l = t.extractPoints(e);
                    let c = l.shape;
                    const u = l.holes;
                    !1 === pd.isClockWise(c) && (c = c.reverse());
                    for (let t = 0, e = u.length; t < e; t++) {
                        const e = u[t];
                        !0 === pd.isClockWise(e) && (u[t] = e.reverse())
                    }
                    const h = pd.triangulateShape(c, u);
                    for (let t = 0, e = u.length; t < e; t++) {
                        const e = u[t];
                        c = c.concat(e)
                    }
                    for (let t = 0, e = c.length; t < e; t++) {
                        const e = c[t];
                        i.push(e.x, e.y, 0), r.push(0, 0, 1), o.push(e.x, e.y)
                    }
                    for (let t = 0, e = h.length; t < e; t++) {
                        const e = h[t], i = e[0] + s, r = e[1] + s, o = e[2] + s;
                        n.push(i, r, o), a += 3
                    }
                }

                this.setIndex(n), this.setAttribute("position", new zs(i, 3)), this.setAttribute("normal", new zs(r, 3)), this.setAttribute("uv", new zs(o, 2))
            }

            toJSON() {
                const t = super.toJSON();
                return function (t, e) {
                    if (e.shapes = [], Array.isArray(t)) for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n];
                        e.shapes.push(i.uuid)
                    } else e.shapes.push(t.uuid);
                    return e
                }(this.parameters.shapes, t)
            }

            static fromJSON(t, e) {
                const n = [];
                for (let i = 0, r = t.shapes.length; i < r; i++) {
                    const r = e[t.shapes[i]];
                    n.push(r)
                }
                return new yd(n, t.curveSegments)
            }
        }

        class xd extends bs {
            constructor(t) {
                super(), this.type = "ShadowMaterial", this.color = new Ps(0), this.transparent = !0, this.setValues(t)
            }

            copy(t) {
                return super.copy(t), this.color.copy(t.color), this
            }
        }

        xd.prototype.isShadowMaterial = !0;

        class _d extends bs {
            constructor(t) {
                super(), this.defines = {STANDARD: ""}, this.type = "MeshStandardMaterial", this.color = new Ps(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ps(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new jr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
            }

            copy(t) {
                return super.copy(t), this.defines = {STANDARD: ""}, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
            }
        }

        _d.prototype.isMeshStandardMaterial = !0;

        class bd extends _d {
            constructor(t) {
                super(), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new jr(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                    get: function () {
                        return Ur(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    }, set: function (t) {
                        this.ior = (1 + .4 * t) / (1 - .4 * t)
                    }
                }), this.sheenColor = new Ps(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Ps(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ps(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t)
            }

            get sheen() {
                return this._sheen
            }

            set sheen(t) {
                this._sheen > 0 != t > 0 && this.version++, this._sheen = t
            }

            get clearcoat() {
                return this._clearcoat
            }

            set clearcoat(t) {
                this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t
            }

            get transmission() {
                return this._transmission
            }

            set transmission(t) {
                this._transmission > 0 != t > 0 && this.version++, this._transmission = t
            }

            copy(t) {
                return super.copy(t), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this
            }
        }

        bd.prototype.isMeshPhysicalMaterial = !0;

        class wd extends bs {
            constructor(t) {
                super(), this.type = "MeshPhongMaterial", this.color = new Ps(16777215), this.specular = new Ps(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ps(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new jr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
            }

            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
            }
        }

        wd.prototype.isMeshPhongMaterial = !0;

        class Sd extends bs {
            constructor(t) {
                super(), this.defines = {TOON: ""}, this.type = "MeshToonMaterial", this.color = new Ps(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ps(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new jr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
            }

            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
            }
        }

        Sd.prototype.isMeshToonMaterial = !0;

        class Md extends bs {
            constructor(t) {
                super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new jr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(t)
            }

            copy(t) {
                return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this
            }
        }

        Md.prototype.isMeshNormalMaterial = !0;

        class Td extends bs {
            constructor(t) {
                super(), this.type = "MeshLambertMaterial", this.color = new Ps(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ps(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
            }

            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
            }
        }

        Td.prototype.isMeshLambertMaterial = !0;

        class Ed extends bs {
            constructor(t) {
                super(), this.defines = {MATCAP: ""}, this.type = "MeshMatcapMaterial", this.color = new Ps(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new jr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(t)
            }

            copy(t) {
                return super.copy(t), this.defines = {MATCAP: ""}, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this
            }
        }

        Ed.prototype.isMeshMatcapMaterial = !0;

        class Ad extends th {
            constructor(t) {
                super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
            }

            copy(t) {
                return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
            }
        }

        Ad.prototype.isLineDashedMaterial = !0;
        const Pd = {
            arraySlice: function (t, e, n) {
                return Pd.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
            }, convertArray: function (t, e, n) {
                return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            }, isTypedArray: function (t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            }, getKeyframeOrder: function (t) {
                const e = t.length, n = new Array(e);
                for (let t = 0; t !== e; ++t) n[t] = t;
                return n.sort((function (e, n) {
                    return t[e] - t[n]
                })), n
            }, sortedArray: function (t, e, n) {
                const i = t.length, r = new t.constructor(i);
                for (let o = 0, s = 0; s !== i; ++o) {
                    const i = n[o] * e;
                    for (let n = 0; n !== e; ++n) r[s++] = t[i + n]
                }
                return r
            }, flattenJSON: function (t, e, n, i) {
                let r = 1, o = t[0];
                for (; void 0 !== o && void 0 === o[i];) o = t[r++];
                if (void 0 === o) return;
                let s = o[i];
                if (void 0 !== s) if (Array.isArray(s)) do {
                    s = o[i], void 0 !== s && (e.push(o.time), n.push.apply(n, s)), o = t[r++]
                } while (void 0 !== o); else if (void 0 !== s.toArray) do {
                    s = o[i], void 0 !== s && (e.push(o.time), s.toArray(n, n.length)), o = t[r++]
                } while (void 0 !== o); else do {
                    s = o[i], void 0 !== s && (e.push(o.time), n.push(s)), o = t[r++]
                } while (void 0 !== o)
            }, subclip: function (t, e, n, i, r = 30) {
                const o = t.clone();
                o.name = e;
                const s = [];
                for (let t = 0; t < o.tracks.length; ++t) {
                    const e = o.tracks[t], a = e.getValueSize(), l = [], c = [];
                    for (let t = 0; t < e.times.length; ++t) {
                        const o = e.times[t] * r;
                        if (!(o < n || o >= i)) {
                            l.push(e.times[t]);
                            for (let n = 0; n < a; ++n) c.push(e.values[t * a + n])
                        }
                    }
                    0 !== l.length && (e.times = Pd.convertArray(l, e.times.constructor), e.values = Pd.convertArray(c, e.values.constructor), s.push(e))
                }
                o.tracks = s;
                let a = 1 / 0;
                for (let t = 0; t < o.tracks.length; ++t) a > o.tracks[t].times[0] && (a = o.tracks[t].times[0]);
                for (let t = 0; t < o.tracks.length; ++t) o.tracks[t].shift(-1 * a);
                return o.resetDuration(), o
            }, makeClipAdditive: function (t, e = 0, n = t, i = 30) {
                i <= 0 && (i = 30);
                const r = n.tracks.length, o = e / i;
                for (let e = 0; e < r; ++e) {
                    const i = n.tracks[e], r = i.ValueTypeName;
                    if ("bool" === r || "string" === r) continue;
                    const s = t.tracks.find((function (t) {
                        return t.name === i.name && t.ValueTypeName === r
                    }));
                    if (void 0 === s) continue;
                    let a = 0;
                    const l = i.getValueSize();
                    i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
                    let c = 0;
                    const u = s.getValueSize();
                    s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
                    const h = i.times.length - 1;
                    let d;
                    if (o <= i.times[0]) {
                        const t = a, e = l - a;
                        d = Pd.arraySlice(i.values, t, e)
                    } else if (o >= i.times[h]) {
                        const t = h * l + a, e = t + l - a;
                        d = Pd.arraySlice(i.values, t, e)
                    } else {
                        const t = i.createInterpolant(), e = a, n = l - a;
                        t.evaluate(o), d = Pd.arraySlice(t.resultBuffer, e, n)
                    }
                    if ("quaternion" === r) {
                        (new ro).fromArray(d).normalize().conjugate().toArray(d)
                    }
                    const p = s.times.length;
                    for (let t = 0; t < p; ++t) {
                        const e = t * u + c;
                        if ("quaternion" === r) ro.multiplyQuaternionsFlat(s.values, e, d, 0, s.values, e); else {
                            const t = u - 2 * c;
                            for (let n = 0; n < t; ++n) s.values[e + n] -= d[n]
                        }
                    }
                }
                return t.blendMode = 2501, t
            }
        };

        class Ld {
            constructor(t, e, n, i) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
            }

            evaluate(t) {
                const e = this.parameterPositions;
                let n = this._cachedIndex, i = e[n], r = e[n - 1];
                t:{
                    e:{
                        let o;
                        n:{
                            i:if (!(t < i)) {
                                for (let o = n + 2; ;) {
                                    if (void 0 === i) {
                                        if (t < r) break i;
                                        return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r)
                                    }
                                    if (n === o) break;
                                    if (r = i, i = e[++n], t < i) break e
                                }
                                o = e.length;
                                break n
                            }
                            if (t >= r) break t;
                            {
                                const s = e[1];
                                t < s && (n = 2, r = s);
                                for (let o = n - 2; ;) {
                                    if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                    if (n === o) break;
                                    if (i = r, r = e[--n - 1], t >= r) break e
                                }
                                o = n, n = 0
                            }
                        }
                        for (; n < o;) {
                            const i = n + o >>> 1;
                            t < e[i] ? o = i : n = i + 1
                        }
                        if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                        if (void 0 === i) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t)
                    }
                    this._cachedIndex = n, this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, t, i)
            }

            getSettings_() {
                return this.settings || this.DefaultSettings_
            }

            copySampleValue_(t) {
                const e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i;
                for (let t = 0; t !== i; ++t) e[t] = n[r + t];
                return e
            }

            interpolate_() {
                throw new Error("call to abstract method")
            }

            intervalChanged_() {
            }
        }

        Ld.prototype.beforeStart_ = Ld.prototype.copySampleValue_, Ld.prototype.afterEnd_ = Ld.prototype.copySampleValue_;

        class Cd extends Ld {
            constructor(t, e, n, i) {
                super(t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                    endingStart: Sr,
                    endingEnd: Sr
                }
            }

            intervalChanged_(t, e, n) {
                const i = this.parameterPositions;
                let r = t - 2, o = t + 1, s = i[r], a = i[o];
                if (void 0 === s) switch (this.getSettings_().endingStart) {
                    case Mr:
                        r = t, s = 2 * e - n;
                        break;
                    case Tr:
                        r = i.length - 2, s = e + i[r] - i[r + 1];
                        break;
                    default:
                        r = t, s = n
                }
                if (void 0 === a) switch (this.getSettings_().endingEnd) {
                    case Mr:
                        o = t, a = 2 * n - e;
                        break;
                    case Tr:
                        o = 1, a = n + i[1] - i[0];
                        break;
                    default:
                        o = t - 1, a = e
                }
                const l = .5 * (n - e), c = this.valueSize;
                this._weightPrev = l / (e - s), this._weightNext = l / (a - n), this._offsetPrev = r * c, this._offsetNext = o * c
            }

            interpolate_(t, e, n, i) {
                const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = t * s, l = a - s,
                    c = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext,
                    p = (n - e) / (i - e), f = p * p, m = f * p, g = -h * m + 2 * h * f - h * p,
                    v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p,
                    x = d * m - d * f;
                for (let t = 0; t !== s; ++t) r[t] = g * o[c + t] + v * o[l + t] + y * o[a + t] + x * o[u + t];
                return r
            }
        }

        class Rd extends Ld {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }

            interpolate_(t, e, n, i) {
                const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = t * s, l = a - s,
                    c = (n - e) / (i - e), u = 1 - c;
                for (let t = 0; t !== s; ++t) r[t] = o[l + t] * u + o[a + t] * c;
                return r
            }
        }

        class Id extends Ld {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }

            interpolate_(t) {
                return this.copySampleValue_(t - 1)
            }
        }

        class Od {
            constructor(t, e, n, i) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = Pd.convertArray(e, this.TimeBufferType), this.values = Pd.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
            }

            static toJSON(t) {
                const e = t.constructor;
                let n;
                if (e.toJSON !== this.toJSON) n = e.toJSON(t); else {
                    n = {
                        name: t.name,
                        times: Pd.convertArray(t.times, Array),
                        values: Pd.convertArray(t.values, Array)
                    };
                    const e = t.getInterpolation();
                    e !== t.DefaultInterpolation && (n.interpolation = e)
                }
                return n.type = t.ValueTypeName, n
            }

            InterpolantFactoryMethodDiscrete(t) {
                return new Id(this.times, this.values, this.getValueSize(), t)
            }

            InterpolantFactoryMethodLinear(t) {
                return new Rd(this.times, this.values, this.getValueSize(), t)
            }

            InterpolantFactoryMethodSmooth(t) {
                return new Cd(this.times, this.values, this.getValueSize(), t)
            }

            setInterpolation(t) {
                let e;
                switch (t) {
                    case _r:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case br:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case wr:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", e), this
                }
                return this.createInterpolant = e, this
            }

            getInterpolation() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return _r;
                    case this.InterpolantFactoryMethodLinear:
                        return br;
                    case this.InterpolantFactoryMethodSmooth:
                        return wr
                }
            }

            getValueSize() {
                return this.values.length / this.times.length
            }

            shift(t) {
                if (0 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n) e[n] += t
                }
                return this
            }

            scale(t) {
                if (1 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t
                }
                return this
            }

            trim(t, e) {
                const n = this.times, i = n.length;
                let r = 0, o = i - 1;
                for (; r !== i && n[r] < t;) ++r;
                for (; -1 !== o && n[o] > e;) --o;
                if (++o, 0 !== r || o !== i) {
                    r >= o && (o = Math.max(o, 1), r = o - 1);
                    const t = this.getValueSize();
                    this.times = Pd.arraySlice(n, r, o), this.values = Pd.arraySlice(this.values, r * t, o * t)
                }
                return this
            }

            validate() {
                let t = !0;
                const e = this.getValueSize();
                e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                const n = this.times, i = this.values, r = n.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                let o = null;
                for (let e = 0; e !== r; e++) {
                    const i = n[e];
                    if ("number" == typeof i && isNaN(i)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i), t = !1;
                        break
                    }
                    if (null !== o && o > i) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, o), t = !1;
                        break
                    }
                    o = i
                }
                if (void 0 !== i && Pd.isTypedArray(i)) for (let e = 0, n = i.length; e !== n; ++e) {
                    const n = i[e];
                    if (isNaN(n)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1;
                        break
                    }
                }
                return t
            }

            optimize() {
                const t = Pd.arraySlice(this.times), e = Pd.arraySlice(this.values), n = this.getValueSize(),
                    i = this.getInterpolation() === wr, r = t.length - 1;
                let o = 1;
                for (let s = 1; s < r; ++s) {
                    let r = !1;
                    const a = t[s];
                    if (a !== t[s + 1] && (1 !== s || a !== t[0])) if (i) r = !0; else {
                        const t = s * n, i = t - n, o = t + n;
                        for (let s = 0; s !== n; ++s) {
                            const n = e[t + s];
                            if (n !== e[i + s] || n !== e[o + s]) {
                                r = !0;
                                break
                            }
                        }
                    }
                    if (r) {
                        if (s !== o) {
                            t[o] = t[s];
                            const i = s * n, r = o * n;
                            for (let t = 0; t !== n; ++t) e[r + t] = e[i + t]
                        }
                        ++o
                    }
                }
                if (r > 0) {
                    t[o] = t[r];
                    for (let t = r * n, i = o * n, s = 0; s !== n; ++s) e[i + s] = e[t + s];
                    ++o
                }
                return o !== t.length ? (this.times = Pd.arraySlice(t, 0, o), this.values = Pd.arraySlice(e, 0, o * n)) : (this.times = t, this.values = e), this
            }

            clone() {
                const t = Pd.arraySlice(this.times, 0), e = Pd.arraySlice(this.values, 0),
                    n = new (0, this.constructor)(this.name, t, e);
                return n.createInterpolant = this.createInterpolant, n
            }
        }

        Od.prototype.TimeBufferType = Float32Array, Od.prototype.ValueBufferType = Float32Array, Od.prototype.DefaultInterpolation = br;

        class Dd extends Od {
        }

        Dd.prototype.ValueTypeName = "bool", Dd.prototype.ValueBufferType = Array, Dd.prototype.DefaultInterpolation = _r, Dd.prototype.InterpolantFactoryMethodLinear = void 0, Dd.prototype.InterpolantFactoryMethodSmooth = void 0;

        class zd extends Od {
        }

        zd.prototype.ValueTypeName = "color";

        class kd extends Od {
        }

        kd.prototype.ValueTypeName = "number";

        class Nd extends Ld {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }

            interpolate_(t, e, n, i) {
                const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = (n - e) / (i - e);
                let l = t * s;
                for (let t = l + s; l !== t; l += 4) ro.slerpFlat(r, 0, o, l - s, o, l, a);
                return r
            }
        }

        class Bd extends Od {
            InterpolantFactoryMethodLinear(t) {
                return new Nd(this.times, this.values, this.getValueSize(), t)
            }
        }

        Bd.prototype.ValueTypeName = "quaternion", Bd.prototype.DefaultInterpolation = br, Bd.prototype.InterpolantFactoryMethodSmooth = void 0;

        class Fd extends Od {
        }

        Fd.prototype.ValueTypeName = "string", Fd.prototype.ValueBufferType = Array, Fd.prototype.DefaultInterpolation = _r, Fd.prototype.InterpolantFactoryMethodLinear = void 0, Fd.prototype.InterpolantFactoryMethodSmooth = void 0;

        class Ud extends Od {
        }

        Ud.prototype.ValueTypeName = "vector";

        class Hd {
            constructor(t, e = -1, n, i = 2500) {
                this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = Fr(), this.duration < 0 && this.resetDuration()
            }

            static parse(t) {
                const e = [], n = t.tracks, i = 1 / (t.fps || 1);
                for (let t = 0, r = n.length; t !== r; ++t) e.push(Vd(n[t]).scale(i));
                const r = new this(t.name, t.duration, e, t.blendMode);
                return r.uuid = t.uuid, r
            }

            static toJSON(t) {
                const e = [], n = t.tracks,
                    i = {name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode};
                for (let t = 0, i = n.length; t !== i; ++t) e.push(Od.toJSON(n[t]));
                return i
            }

            static CreateFromMorphTargetSequence(t, e, n, i) {
                const r = e.length, o = [];
                for (let t = 0; t < r; t++) {
                    let s = [], a = [];
                    s.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
                    const l = Pd.getKeyframeOrder(s);
                    s = Pd.sortedArray(s, 1, l), a = Pd.sortedArray(a, 1, l), i || 0 !== s[0] || (s.push(r), a.push(a[0])), o.push(new kd(".morphTargetInfluences[" + e[t].name + "]", s, a).scale(1 / n))
                }
                return new this(t, -1, o)
            }

            static findByName(t, e) {
                let n = t;
                if (!Array.isArray(t)) {
                    const e = t;
                    n = e.geometry && e.geometry.animations || e.animations
                }
                for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];
                return null
            }

            static CreateClipsFromMorphTargetSequences(t, e, n) {
                const i = {}, r = /^([\w-]*?)([\d]+)$/;
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e], o = n.name.match(r);
                    if (o && o.length > 1) {
                        const t = o[1];
                        let e = i[t];
                        e || (i[t] = e = []), e.push(n)
                    }
                }
                const o = [];
                for (const t in i) o.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
                return o
            }

            static parseAnimation(t, e) {
                if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                const n = function (t, e, n, i, r) {
                    if (0 !== n.length) {
                        const o = [], s = [];
                        Pd.flattenJSON(n, o, s, i), 0 !== o.length && r.push(new t(e, o, s))
                    }
                }, i = [], r = t.name || "default", o = t.fps || 30, s = t.blendMode;
                let a = t.length || -1;
                const l = t.hierarchy || [];
                for (let t = 0; t < l.length; t++) {
                    const r = l[t].keys;
                    if (r && 0 !== r.length) if (r[0].morphTargets) {
                        const t = {};
                        let e;
                        for (e = 0; e < r.length; e++) if (r[e].morphTargets) for (let n = 0; n < r[e].morphTargets.length; n++) t[r[e].morphTargets[n]] = -1;
                        for (const n in t) {
                            const t = [], o = [];
                            for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                const i = r[e];
                                t.push(i.time), o.push(i.morphTarget === n ? 1 : 0)
                            }
                            i.push(new kd(".morphTargetInfluence[" + n + "]", t, o))
                        }
                        a = t.length * (o || 1)
                    } else {
                        const o = ".bones[" + e[t].name + "]";
                        n(Ud, o + ".position", r, "pos", i), n(Bd, o + ".quaternion", r, "rot", i), n(Ud, o + ".scale", r, "scl", i)
                    }
                }
                if (0 === i.length) return null;
                return new this(r, a, i, s)
            }

            resetDuration() {
                let t = 0;
                for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                    const n = this.tracks[e];
                    t = Math.max(t, n.times[n.times.length - 1])
                }
                return this.duration = t, this
            }

            trim() {
                for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                return this
            }

            validate() {
                let t = !0;
                for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                return t
            }

            optimize() {
                for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                return this
            }

            clone() {
                const t = [];
                for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                return new this.constructor(this.name, this.duration, t, this.blendMode)
            }

            toJSON() {
                return this.constructor.toJSON(this)
            }
        }

        function Vd(t) {
            if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const e = function (t) {
                switch (t.toLowerCase()) {
                    case"scalar":
                    case"double":
                    case"float":
                    case"number":
                    case"integer":
                        return kd;
                    case"vector":
                    case"vector2":
                    case"vector3":
                    case"vector4":
                        return Ud;
                    case"color":
                        return zd;
                    case"quaternion":
                        return Bd;
                    case"bool":
                    case"boolean":
                        return Dd;
                    case"string":
                        return Fd
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }(t.type);
            if (void 0 === t.times) {
                const e = [], n = [];
                Pd.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
        }

        const Gd = {
            enabled: !1, files: {}, add: function (t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            }, get: function (t) {
                if (!1 !== this.enabled) return this.files[t]
            }, remove: function (t) {
                delete this.files[t]
            }, clear: function () {
                this.files = {}
            }
        };

        class Wd {
            constructor(t, e, n) {
                const i = this;
                let r, o = !1, s = 0, a = 0;
                const l = [];
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) {
                    a++, !1 === o && void 0 !== i.onStart && i.onStart(t, s, a), o = !0
                }, this.itemEnd = function (t) {
                    s++, void 0 !== i.onProgress && i.onProgress(t, s, a), s === a && (o = !1, void 0 !== i.onLoad && i.onLoad())
                }, this.itemError = function (t) {
                    void 0 !== i.onError && i.onError(t)
                }, this.resolveURL = function (t) {
                    return r ? r(t) : t
                }, this.setURLModifier = function (t) {
                    return r = t, this
                }, this.addHandler = function (t, e) {
                    return l.push(t, e), this
                }, this.removeHandler = function (t) {
                    const e = l.indexOf(t);
                    return -1 !== e && l.splice(e, 2), this
                }, this.getHandler = function (t) {
                    for (let e = 0, n = l.length; e < n; e += 2) {
                        const n = l[e], i = l[e + 1];
                        if (n.global && (n.lastIndex = 0), n.test(t)) return i
                    }
                    return null
                }
            }
        }

        const jd = new Wd;

        class qd {
            constructor(t) {
                this.manager = void 0 !== t ? t : jd, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
            }

            load() {
            }

            loadAsync(t, e) {
                const n = this;
                return new Promise((function (i, r) {
                    n.load(t, i, e, r)
                }))
            }

            parse() {
            }

            setCrossOrigin(t) {
                return this.crossOrigin = t, this
            }

            setWithCredentials(t) {
                return this.withCredentials = t, this
            }

            setPath(t) {
                return this.path = t, this
            }

            setResourcePath(t) {
                return this.resourcePath = t, this
            }

            setRequestHeader(t) {
                return this.requestHeader = t, this
            }
        }

        const Xd = {};

        class Yd extends qd {
            constructor(t) {
                super(t)
            }

            load(t, e, n, i) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const r = Gd.get(t);
                if (void 0 !== r) return this.manager.itemStart(t), setTimeout((() => {
                    e && e(r), this.manager.itemEnd(t)
                }), 0), r;
                if (void 0 !== Xd[t]) return void Xd[t].push({onLoad: e, onProgress: n, onError: i});
                Xd[t] = [], Xd[t].push({onLoad: e, onProgress: n, onError: i});
                const o = new Request(t, {
                    headers: new Headers(this.requestHeader),
                    credentials: this.withCredentials ? "include" : "same-origin"
                });
                fetch(o).then((e => {
                    if (200 === e.status || 0 === e.status) {
                        0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                        const n = Xd[t], i = e.body.getReader(), r = e.headers.get("Content-Length"),
                            o = r ? parseInt(r) : 0, s = 0 !== o;
                        let a = 0;
                        return new ReadableStream({
                            start(t) {
                                !function e() {
                                    i.read().then((({done: i, value: r}) => {
                                        if (i) t.close(); else {
                                            a += r.byteLength;
                                            const i = new ProgressEvent("progress", {
                                                lengthComputable: s,
                                                loaded: a,
                                                total: o
                                            });
                                            for (let t = 0, e = n.length; t < e; t++) {
                                                const e = n[t];
                                                e.onProgress && e.onProgress(i)
                                            }
                                            t.enqueue(r), e()
                                        }
                                    }))
                                }()
                            }
                        })
                    }
                    throw Error(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`)
                })).then((t => {
                    const e = new Response(t);
                    switch (this.responseType) {
                        case"arraybuffer":
                            return e.arrayBuffer();
                        case"blob":
                            return e.blob();
                        case"document":
                            return e.text().then((t => (new DOMParser).parseFromString(t, this.mimeType)));
                        case"json":
                            return e.json();
                        default:
                            return e.text()
                    }
                })).then((e => {
                    Gd.add(t, e);
                    const n = Xd[t];
                    delete Xd[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onLoad && i.onLoad(e)
                    }
                    this.manager.itemEnd(t)
                })).catch((e => {
                    const n = Xd[t];
                    delete Xd[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onError && i.onError(e)
                    }
                    this.manager.itemError(t), this.manager.itemEnd(t)
                })), this.manager.itemStart(t)
            }

            setResponseType(t) {
                return this.responseType = t, this
            }

            setMimeType(t) {
                return this.mimeType = t, this
            }
        }

        class Jd extends qd {
            constructor(t) {
                super(t)
            }

            load(t, e, n, i) {
                void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const r = this, o = Gd.get(t);
                if (void 0 !== o) return r.manager.itemStart(t), setTimeout((function () {
                    e && e(o), r.manager.itemEnd(t)
                }), 0), o;
                const s = Yr("img");

                function a() {
                    c(), Gd.add(t, this), e && e(this), r.manager.itemEnd(t)
                }

                function l(e) {
                    c(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                }

                function c() {
                    s.removeEventListener("load", a, !1), s.removeEventListener("error", l, !1)
                }

                return s.addEventListener("load", a, !1), s.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(t), s.src = t, s
            }
        }

        class Zd extends qd {
            constructor(t) {
                super(t)
            }

            load(t, e, n, i) {
                const r = new ya, o = new Jd(this.manager);
                o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                let s = 0;

                function a(n) {
                    o.load(t[n], (function (t) {
                        r.images[n] = t, s++, 6 === s && (r.needsUpdate = !0, e && e(r))
                    }), void 0, i)
                }

                for (let e = 0; e < t.length; ++e) a(e);
                return r
            }
        }

        class Qd extends qd {
            constructor(t) {
                super(t)
            }

            load(t, e, n, i) {
                const r = new $r, o = new Jd(this.manager);
                return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, (function (t) {
                    r.image = t, r.needsUpdate = !0, void 0 !== e && e(r)
                }), n, i), r
            }
        }

        class Kd extends ls {
            constructor(t, e = 1) {
                super(), this.type = "Light", this.color = new Ps(t), this.intensity = e
            }

            dispose() {
            }

            copy(t) {
                return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this
            }

            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
            }
        }

        Kd.prototype.isLight = !0;

        class $d extends Kd {
            constructor(t, e, n) {
                super(t, n), this.type = "HemisphereLight", this.position.copy(ls.DefaultUp), this.updateMatrix(), this.groundColor = new Ps(e)
            }

            copy(t) {
                return Kd.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
            }
        }

        $d.prototype.isHemisphereLight = !0;
        const tp = new No, ep = new oo, np = new oo;

        class ip {
            constructor(t) {
                this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new jr(512, 512), this.map = null, this.mapPass = null, this.matrix = new No, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Ea, this._frameExtents = new jr(1, 1), this._viewportCount = 1, this._viewports = [new eo(0, 0, 1, 1)]
            }

            getViewportCount() {
                return this._viewportCount
            }

            getFrustum() {
                return this._frustum
            }

            updateMatrices(t) {
                const e = this.camera, n = this.matrix;
                ep.setFromMatrixPosition(t.matrixWorld), e.position.copy(ep), np.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(np), e.updateMatrixWorld(), tp.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(tp), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
            }

            getViewport(t) {
                return this._viewports[t]
            }

            getFrameExtents() {
                return this._frameExtents
            }

            dispose() {
                this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
            }

            copy(t) {
                return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            toJSON() {
                const t = {};
                return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
            }
        }

        class rp extends ip {
            constructor() {
                super(new ma(50, 1, .5, 500)), this.focus = 1
            }

            updateMatrices(t) {
                const e = this.camera, n = 2 * Br * t.angle * this.focus, i = this.mapSize.width / this.mapSize.height,
                    r = t.distance || e.far;
                n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
            }

            copy(t) {
                return super.copy(t), this.focus = t.focus, this
            }
        }

        rp.prototype.isSpotLightShadow = !0;

        class op extends Kd {
            constructor(t, e, n = 0, i = Math.PI / 3, r = 0, o = 1) {
                super(t, e), this.type = "SpotLight", this.position.copy(ls.DefaultUp), this.updateMatrix(), this.target = new ls, this.distance = n, this.angle = i, this.penumbra = r, this.decay = o, this.shadow = new rp
            }

            get power() {
                return this.intensity * Math.PI
            }

            set power(t) {
                this.intensity = t / Math.PI
            }

            dispose() {
                this.shadow.dispose()
            }

            copy(t) {
                return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }

        op.prototype.isSpotLight = !0;
        const sp = new No, ap = new oo, lp = new oo;

        class cp extends ip {
            constructor() {
                super(new ma(90, 1, .5, 500)), this._frameExtents = new jr(4, 2), this._viewportCount = 6, this._viewports = [new eo(2, 1, 1, 1), new eo(0, 1, 1, 1), new eo(3, 1, 1, 1), new eo(1, 1, 1, 1), new eo(3, 0, 1, 1), new eo(1, 0, 1, 1)], this._cubeDirections = [new oo(1, 0, 0), new oo(-1, 0, 0), new oo(0, 0, 1), new oo(0, 0, -1), new oo(0, 1, 0), new oo(0, -1, 0)], this._cubeUps = [new oo(0, 1, 0), new oo(0, 1, 0), new oo(0, 1, 0), new oo(0, 1, 0), new oo(0, 0, 1), new oo(0, 0, -1)]
            }

            updateMatrices(t, e = 0) {
                const n = this.camera, i = this.matrix, r = t.distance || n.far;
                r !== n.far && (n.far = r, n.updateProjectionMatrix()), ap.setFromMatrixPosition(t.matrixWorld), n.position.copy(ap), lp.copy(n.position), lp.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(lp), n.updateMatrixWorld(), i.makeTranslation(-ap.x, -ap.y, -ap.z), sp.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(sp)
            }
        }

        cp.prototype.isPointLightShadow = !0;

        class up extends Kd {
            constructor(t, e, n = 0, i = 1) {
                super(t, e), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new cp
            }

            get power() {
                return 4 * this.intensity * Math.PI
            }

            set power(t) {
                this.intensity = t / (4 * Math.PI)
            }

            dispose() {
                this.shadow.dispose()
            }

            copy(t) {
                return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
            }
        }

        up.prototype.isPointLight = !0;

        class hp extends ip {
            constructor() {
                super(new Fa(-5, 5, 5, -5, .5, 500))
            }
        }

        hp.prototype.isDirectionalLightShadow = !0;

        class dp extends Kd {
            constructor(t, e) {
                super(t, e), this.type = "DirectionalLight", this.position.copy(ls.DefaultUp), this.updateMatrix(), this.target = new ls, this.shadow = new hp
            }

            dispose() {
                this.shadow.dispose()
            }

            copy(t) {
                return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }

        dp.prototype.isDirectionalLight = !0;

        class pp extends Kd {
            constructor(t, e) {
                super(t, e), this.type = "AmbientLight"
            }
        }

        pp.prototype.isAmbientLight = !0;

        class fp extends Kd {
            constructor(t, e, n = 10, i = 10) {
                super(t, e), this.type = "RectAreaLight", this.width = n, this.height = i
            }

            get power() {
                return this.intensity * this.width * this.height * Math.PI
            }

            set power(t) {
                this.intensity = t / (this.width * this.height * Math.PI)
            }

            copy(t) {
                return super.copy(t), this.width = t.width, this.height = t.height, this
            }

            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.width = this.width, e.object.height = this.height, e
            }
        }

        fp.prototype.isRectAreaLight = !0;

        class mp {
            constructor() {
                this.coefficients = [];
                for (let t = 0; t < 9; t++) this.coefficients.push(new oo)
            }

            set(t) {
                for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                return this
            }

            zero() {
                for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                return this
            }

            getAt(t, e) {
                const n = t.x, i = t.y, r = t.z, o = this.coefficients;
                return e.copy(o[0]).multiplyScalar(.282095), e.addScaledVector(o[1], .488603 * i), e.addScaledVector(o[2], .488603 * r), e.addScaledVector(o[3], .488603 * n), e.addScaledVector(o[4], n * i * 1.092548), e.addScaledVector(o[5], i * r * 1.092548), e.addScaledVector(o[6], .315392 * (3 * r * r - 1)), e.addScaledVector(o[7], n * r * 1.092548), e.addScaledVector(o[8], .546274 * (n * n - i * i)), e
            }

            getIrradianceAt(t, e) {
                const n = t.x, i = t.y, r = t.z, o = this.coefficients;
                return e.copy(o[0]).multiplyScalar(.886227), e.addScaledVector(o[1], 1.023328 * i), e.addScaledVector(o[2], 1.023328 * r), e.addScaledVector(o[3], 1.023328 * n), e.addScaledVector(o[4], .858086 * n * i), e.addScaledVector(o[5], .858086 * i * r), e.addScaledVector(o[6], .743125 * r * r - .247708), e.addScaledVector(o[7], .858086 * n * r), e.addScaledVector(o[8], .429043 * (n * n - i * i)), e
            }

            add(t) {
                for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                return this
            }

            addScaledSH(t, e) {
                for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
                return this
            }

            scale(t) {
                for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                return this
            }

            lerp(t, e) {
                for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
                return this
            }

            equals(t) {
                for (let e = 0; e < 9; e++) if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                return !0
            }

            copy(t) {
                return this.set(t.coefficients)
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            fromArray(t, e = 0) {
                const n = this.coefficients;
                for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
                return this
            }

            toArray(t = [], e = 0) {
                const n = this.coefficients;
                for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
                return t
            }

            static getBasisAt(t, e) {
                const n = t.x, i = t.y, r = t.z;
                e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i)
            }
        }

        mp.prototype.isSphericalHarmonics3 = !0;

        class gp extends Kd {
            constructor(t = new mp, e = 1) {
                super(void 0, e), this.sh = t
            }

            copy(t) {
                return super.copy(t), this.sh.copy(t.sh), this
            }

            fromJSON(t) {
                return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
            }

            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.sh = this.sh.toArray(), e
            }
        }

        gp.prototype.isLightProbe = !0;

        class vp {
            static decodeText(t) {
                if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                let e = "";
                for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
                try {
                    return decodeURIComponent(escape(e))
                } catch (t) {
                    return e
                }
            }

            static extractUrlBase(t) {
                const e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.substr(0, e + 1)
            }

            static resolveURL(t, e) {
                return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
            }
        }

        class yp extends Gs {
            constructor() {
                super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
            }

            copy(t) {
                return super.copy(t), this.instanceCount = t.instanceCount, this
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            toJSON() {
                const t = super.toJSON(this);
                return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
            }
        }

        yp.prototype.isInstancedBufferGeometry = !0;
        let xp;
        (class extends qd {
            constructor(t) {
                super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {premultiplyAlpha: "none"}
            }

            setOptions(t) {
                return this.options = t, this
            }

            load(t, e, n, i) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                const r = this, o = Gd.get(t);
                if (void 0 !== o) return r.manager.itemStart(t), setTimeout((function () {
                    e && e(o), r.manager.itemEnd(t)
                }), 0), o;
                const s = {};
                s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s.headers = this.requestHeader, fetch(t, s).then((function (t) {
                    return t.blob()
                })).then((function (t) {
                    return createImageBitmap(t, Object.assign(r.options, {colorSpaceConversion: "none"}))
                })).then((function (n) {
                    Gd.add(t, n), e && e(n), r.manager.itemEnd(t)
                })).catch((function (e) {
                    i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                })), r.manager.itemStart(t)
            }
        }).prototype.isImageBitmapLoader = !0;
        const _p = function () {
            return void 0 === xp && (xp = new (window.AudioContext || window.webkitAudioContext)), xp
        };

        class bp extends qd {
            constructor(t) {
                super(t)
            }

            load(t, e, n, i) {
                const r = this, o = new Yd(this.manager);
                o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, (function (n) {
                    try {
                        const t = n.slice(0);
                        _p().decodeAudioData(t, (function (t) {
                            e(t)
                        }))
                    } catch (e) {
                        i ? i(e) : console.error(e), r.manager.itemError(t)
                    }
                }), n, i)
            }
        }

        (class extends gp {
            constructor(t, e, n = 1) {
                super(void 0, n);
                const i = (new Ps).set(t), r = (new Ps).set(e), o = new oo(i.r, i.g, i.b), s = new oo(r.r, r.g, r.b),
                    a = Math.sqrt(Math.PI), l = a * Math.sqrt(.75);
                this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a), this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(l)
            }
        }).prototype.isHemisphereLightProbe = !0;
        (class extends gp {
            constructor(t, e = 1) {
                super(void 0, e);
                const n = (new Ps).set(t);
                this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
            }
        }).prototype.isAmbientLightProbe = !0;

        class wp {
            constructor(t = !0) {
                this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }

            start() {
                this.startTime = Sp(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            }

            stop() {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            }

            getElapsedTime() {
                return this.getDelta(), this.elapsedTime
            }

            getDelta() {
                let t = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    const e = Sp();
                    t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                }
                return t
            }
        }

        function Sp() {
            return ("undefined" == typeof performance ? Date : performance).now()
        }

        class Mp extends ls {
            constructor(t) {
                super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
            }

            getOutput() {
                return this.gain
            }

            setNodeSource(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
            }

            setMediaElementSource(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
            }

            setMediaStreamSource(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
            }

            setBuffer(t) {
                return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
            }

            play(t = 0) {
                if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                this._startedAt = this.context.currentTime + t;
                const e = this.context.createBufferSource();
                return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
            }

            pause() {
                if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }

            stop() {
                if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }

            connect() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this._connected = !0, this
            }

            disconnect() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this._connected = !1, this
            }

            getFilters() {
                return this.filters
            }

            setFilters(t) {
                return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
            }

            setDetune(t) {
                if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
            }

            getDetune() {
                return this.detune
            }

            getFilter() {
                return this.getFilters()[0]
            }

            setFilter(t) {
                return this.setFilters(t ? [t] : [])
            }

            setPlaybackRate(t) {
                if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }

            getPlaybackRate() {
                return this.playbackRate
            }

            onEnded() {
                this.isPlaying = !1
            }

            getLoop() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            }

            setLoop(t) {
                if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }

            setLoopStart(t) {
                return this.loopStart = t, this
            }

            setLoopEnd(t) {
                return this.loopEnd = t, this
            }

            getVolume() {
                return this.gain.gain.value
            }

            setVolume(t) {
                return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
            }
        }

        class Tp {
            constructor(t, e, n) {
                let i, r, o;
                switch (this.binding = t, this.valueSize = n, e) {
                    case"quaternion":
                        i = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                        break;
                    case"string":
                    case"bool":
                        i = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                        break;
                    default:
                        i = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                }
                this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
            }

            accumulate(t, e) {
                const n = this.buffer, i = this.valueSize, r = t * i + i;
                let o = this.cumulativeWeight;
                if (0 === o) {
                    for (let t = 0; t !== i; ++t) n[r + t] = n[t];
                    o = e
                } else {
                    o += e;
                    const t = e / o;
                    this._mixBufferRegion(n, r, 0, t, i)
                }
                this.cumulativeWeight = o
            }

            accumulateAdditive(t) {
                const e = this.buffer, n = this.valueSize, i = n * this._addIndex;
                0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), this.cumulativeWeightAdditive += t
            }

            apply(t) {
                const e = this.valueSize, n = this.buffer, i = t * e + e, r = this.cumulativeWeight,
                    o = this.cumulativeWeightAdditive, s = this.binding;
                if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                    const t = e * this._origIndex;
                    this._mixBufferRegion(n, i, t, 1 - r, e)
                }
                o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
                for (let t = e, r = e + e; t !== r; ++t) if (n[t] !== n[t + e]) {
                    s.setValue(n, i);
                    break
                }
            }

            saveOriginalState() {
                const t = this.binding, e = this.buffer, n = this.valueSize, i = n * this._origIndex;
                t.getValue(e, i);
                for (let t = n, r = i; t !== r; ++t) e[t] = e[i + t % n];
                this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
            }

            restoreOriginalState() {
                const t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            }

            _setAdditiveIdentityNumeric() {
                const t = this._addIndex * this.valueSize, e = t + this.valueSize;
                for (let n = t; n < e; n++) this.buffer[n] = 0
            }

            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
            }

            _setAdditiveIdentityOther() {
                const t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize;
                for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
            }

            _select(t, e, n, i, r) {
                if (i >= .5) for (let i = 0; i !== r; ++i) t[e + i] = t[n + i]
            }

            _slerp(t, e, n, i) {
                ro.slerpFlat(t, e, t, e, t, n, i)
            }

            _slerpAdditive(t, e, n, i, r) {
                const o = this._workIndex * r;
                ro.multiplyQuaternionsFlat(t, o, t, e, t, n), ro.slerpFlat(t, e, t, e, t, o, i)
            }

            _lerp(t, e, n, i, r) {
                const o = 1 - i;
                for (let s = 0; s !== r; ++s) {
                    const r = e + s;
                    t[r] = t[r] * o + t[n + s] * i
                }
            }

            _lerpAdditive(t, e, n, i, r) {
                for (let o = 0; o !== r; ++o) {
                    const r = e + o;
                    t[r] = t[r] + t[n + o] * i
                }
            }
        }

        const Ep = "\\[\\]\\.:\\/", Ap = new RegExp("[\\[\\]\\.:\\/]", "g"), Pp = "[^\\[\\]\\.:\\/]",
            Lp = "[^" + Ep.replace("\\.", "") + "]", Cp = /((?:WC+[\/:])*)/.source.replace("WC", Pp),
            Rp = /(WCOD+)?/.source.replace("WCOD", Lp), Ip = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Pp),
            Op = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Pp), Dp = new RegExp("^" + Cp + Rp + Ip + Op + "$"),
            zp = ["material", "materials", "bones"];

        class kp {
            constructor(t, e, n) {
                this.path = e, this.parsedPath = n || kp.parseTrackName(e), this.node = kp.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }

            static create(t, e, n) {
                return t && t.isAnimationObjectGroup ? new kp.Composite(t, e, n) : new kp(t, e, n)
            }

            static sanitizeNodeName(t) {
                return t.replace(/\s/g, "_").replace(Ap, "")
            }

            static parseTrackName(t) {
                const e = Dp.exec(t);
                if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                const n = {
                    nodeName: e[2],
                    objectName: e[3],
                    objectIndex: e[4],
                    propertyName: e[5],
                    propertyIndex: e[6]
                }, i = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    const t = n.nodeName.substring(i + 1);
                    -1 !== zp.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
                }
                if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return n
            }

            static findNode(t, e) {
                if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                if (t.skeleton) {
                    const n = t.skeleton.getBoneByName(e);
                    if (void 0 !== n) return n
                }
                if (t.children) {
                    const n = function (t) {
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i];
                            if (r.name === e || r.uuid === e) return r;
                            const o = n(r.children);
                            if (o) return o
                        }
                        return null
                    }, i = n(t.children);
                    if (i) return i
                }
                return null
            }

            _getValue_unavailable() {
            }

            _setValue_unavailable() {
            }

            _getValue_direct(t, e) {
                t[e] = this.targetObject[this.propertyName]
            }

            _getValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
            }

            _getValue_arrayElement(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }

            _getValue_toArray(t, e) {
                this.resolvedProperty.toArray(t, e)
            }

            _setValue_direct(t, e) {
                this.targetObject[this.propertyName] = t[e]
            }

            _setValue_direct_setNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
            }

            _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }

            _setValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
            }

            _setValue_array_setNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.needsUpdate = !0
            }

            _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }

            _setValue_arrayElement(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }

            _setValue_arrayElement_setNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
            }

            _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }

            _setValue_fromArray(t, e) {
                this.resolvedProperty.fromArray(t, e)
            }

            _setValue_fromArray_setNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
            }

            _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
            }

            _getValue_unbound(t, e) {
                this.bind(), this.getValue(t, e)
            }

            _setValue_unbound(t, e) {
                this.bind(), this.setValue(t, e)
            }

            bind() {
                let t = this.node;
                const e = this.parsedPath, n = e.objectName, i = e.propertyName;
                let r = e.propertyIndex;
                if (t || (t = kp.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                if (n) {
                    let i = e.objectIndex;
                    switch (n) {
                        case"materials":
                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            t = t.material.materials;
                            break;
                        case"bones":
                            if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            t = t.skeleton.bones;
                            for (let e = 0; e < t.length; e++) if (t[e].name === i) {
                                i = e;
                                break
                            }
                            break;
                        default:
                            if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            t = t[n]
                    }
                    if (void 0 !== i) {
                        if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[i]
                    }
                }
                const o = t[i];
                if (void 0 === o) {
                    const n = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t)
                }
                let s = this.Versioning.None;
                this.targetObject = t, void 0 !== t.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
                let a = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === i) {
                        if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                        if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                    }
                    a = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
                } else void 0 !== o.fromArray && void 0 !== o.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (a = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][s]
            }

            unbind() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }

        kp.Composite = class {
            constructor(t, e, n) {
                const i = n || kp.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, i)
            }

            getValue(t, e) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_, i = this._bindings[n];
                void 0 !== i && i.getValue(t, e)
            }

            setValue(t, e) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
            }

            bind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
            }

            unbind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
            }
        }, kp.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        }, kp.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        }, kp.prototype.GetterByBindingType = [kp.prototype._getValue_direct, kp.prototype._getValue_array, kp.prototype._getValue_arrayElement, kp.prototype._getValue_toArray], kp.prototype.SetterByBindingTypeAndVersioning = [[kp.prototype._setValue_direct, kp.prototype._setValue_direct_setNeedsUpdate, kp.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [kp.prototype._setValue_array, kp.prototype._setValue_array_setNeedsUpdate, kp.prototype._setValue_array_setMatrixWorldNeedsUpdate], [kp.prototype._setValue_arrayElement, kp.prototype._setValue_arrayElement_setNeedsUpdate, kp.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [kp.prototype._setValue_fromArray, kp.prototype._setValue_fromArray_setNeedsUpdate, kp.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];

        class Np {
            constructor(t, e, n = null, i = e.blendMode) {
                this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = i;
                const r = e.tracks, o = r.length, s = new Array(o), a = {endingStart: Sr, endingEnd: Sr};
                for (let t = 0; t !== o; ++t) {
                    const e = r[t].createInterpolant(null);
                    s[t] = e, e.settings = a
                }
                this._interpolantSettings = a, this._interpolants = s, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }

            play() {
                return this._mixer._activateAction(this), this
            }

            stop() {
                return this._mixer._deactivateAction(this), this.reset()
            }

            reset() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            }

            isRunning() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }

            isScheduled() {
                return this._mixer._isActiveAction(this)
            }

            startAt(t) {
                return this._startTime = t, this
            }

            setLoop(t, e) {
                return this.loop = t, this.repetitions = e, this
            }

            setEffectiveWeight(t) {
                return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
            }

            getEffectiveWeight() {
                return this._effectiveWeight
            }

            fadeIn(t) {
                return this._scheduleFading(t, 0, 1)
            }

            fadeOut(t) {
                return this._scheduleFading(t, 1, 0)
            }

            crossFadeFrom(t, e, n) {
                if (t.fadeOut(e), this.fadeIn(e), n) {
                    const n = this._clip.duration, i = t._clip.duration, r = i / n, o = n / i;
                    t.warp(1, r, e), this.warp(o, 1, e)
                }
                return this
            }

            crossFadeTo(t, e, n) {
                return t.crossFadeFrom(this, e, n)
            }

            stopFading() {
                const t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            }

            setEffectiveTimeScale(t) {
                return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
            }

            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }

            setDuration(t) {
                return this.timeScale = this._clip.duration / t, this.stopWarping()
            }

            syncWith(t) {
                return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
            }

            halt(t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            }

            warp(t, e, n) {
                const i = this._mixer, r = i.time, o = this.timeScale;
                let s = this._timeScaleInterpolant;
                null === s && (s = i._lendControlInterpolant(), this._timeScaleInterpolant = s);
                const a = s.parameterPositions, l = s.sampleValues;
                return a[0] = r, a[1] = r + n, l[0] = t / o, l[1] = e / o, this
            }

            stopWarping() {
                const t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            }

            getMixer() {
                return this._mixer
            }

            getClip() {
                return this._clip
            }

            getRoot() {
                return this._localRoot || this._mixer._root
            }

            _update(t, e, n, i) {
                if (!this.enabled) return void this._updateWeight(t);
                const r = this._startTime;
                if (null !== r) {
                    const i = (t - r) * n;
                    if (i < 0 || 0 === n) return;
                    this._startTime = null, e = n * i
                }
                e *= this._updateTimeScale(t);
                const o = this._updateTime(e), s = this._updateWeight(t);
                if (s > 0) {
                    const t = this._interpolants, e = this._propertyBindings;
                    if (2501 === this.blendMode) for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(o), e[n].accumulateAdditive(s); else for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(o), e[n].accumulate(i, s)
                }
            }

            _updateWeight(t) {
                let e = 0;
                if (this.enabled) {
                    e = this.weight;
                    const n = this._weightInterpolant;
                    if (null !== n) {
                        const i = n.evaluate(t)[0];
                        e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e, e
            }

            _updateTimeScale(t) {
                let e = 0;
                if (!this.paused) {
                    e = this.timeScale;
                    const n = this._timeScaleInterpolant;
                    if (null !== n) {
                        e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                    }
                }
                return this._effectiveTimeScale = e, e
            }

            _updateTime(t) {
                const e = this._clip.duration, n = this.loop;
                let i = this.time + t, r = this._loopCount;
                const o = 2202 === n;
                if (0 === t) return -1 === r ? i : o && 1 == (1 & r) ? e - i : i;
                if (2200 === n) {
                    -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    t:{
                        if (i >= e) i = e; else {
                            if (!(i < 0)) {
                                this.time = i;
                                break t
                            }
                            i = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), i >= e || i < 0) {
                        const n = Math.floor(i / e);
                        i -= e * n, r += Math.abs(n);
                        const s = this.repetitions - r;
                        if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = t > 0 ? e : 0, this.time = i, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t > 0 ? 1 : -1
                        }); else {
                            if (1 === s) {
                                const e = t < 0;
                                this._setEndings(e, !e, o)
                            } else this._setEndings(!1, !1, o);
                            this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: n
                            })
                        }
                    } else this.time = i;
                    if (o && 1 == (1 & r)) return e - i
                }
                return i
            }

            _setEndings(t, e, n) {
                const i = this._interpolantSettings;
                n ? (i.endingStart = Mr, i.endingEnd = Mr) : (i.endingStart = t ? this.zeroSlopeAtStart ? Mr : Sr : Tr, i.endingEnd = e ? this.zeroSlopeAtEnd ? Mr : Sr : Tr)
            }

            _scheduleFading(t, e, n) {
                const i = this._mixer, r = i.time;
                let o = this._weightInterpolant;
                null === o && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
                const s = o.parameterPositions, a = o.sampleValues;
                return s[0] = r, a[0] = e, s[1] = r + t, a[1] = n, this
            }
        }

        (class extends zr {
            constructor(t) {
                super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }

            _bindAction(t, e) {
                const n = t._localRoot || this._root, i = t._clip.tracks, r = i.length, o = t._propertyBindings,
                    s = t._interpolants, a = n.uuid, l = this._bindingsByRootAndName;
                let c = l[a];
                void 0 === c && (c = {}, l[a] = c);
                for (let t = 0; t !== r; ++t) {
                    const r = i[t], l = r.name;
                    let u = c[l];
                    if (void 0 !== u) o[t] = u; else {
                        if (u = o[t], void 0 !== u) {
                            null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, a, l));
                            continue
                        }
                        const i = e && e._propertyBindings[t].binding.parsedPath;
                        u = new Tp(kp.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++u.referenceCount, this._addInactiveBinding(u, a, l), o[t] = u
                    }
                    s[t].resultBuffer = u.buffer
                }
            }

            _activateAction(t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        const e = (t._localRoot || this._root).uuid, n = t._clip.uuid, i = this._actionsByClip[n];
                        this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
                    }
                    const e = t._propertyBindings;
                    for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            }

            _deactivateAction(t) {
                if (this._isActiveAction(t)) {
                    const e = t._propertyBindings;
                    for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                    }
                    this._takeBackAction(t)
                }
            }

            _initMemoryManager() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                const t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        }, get inUse() {
                            return t._nActiveActions
                        }
                    }, bindings: {
                        get total() {
                            return t._bindings.length
                        }, get inUse() {
                            return t._nActiveBindings
                        }
                    }, controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        }, get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            }

            _isActiveAction(t) {
                const e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            }

            _addInactiveAction(t, e, n) {
                const i = this._actions, r = this._actionsByClip;
                let o = r[e];
                if (void 0 === o) o = {knownActions: [t], actionByRoot: {}}, t._byClipCacheIndex = 0, r[e] = o; else {
                    const e = o.knownActions;
                    t._byClipCacheIndex = e.length, e.push(t)
                }
                t._cacheIndex = i.length, i.push(t), o.actionByRoot[n] = t
            }

            _removeInactiveAction(t) {
                const e = this._actions, n = e[e.length - 1], i = t._cacheIndex;
                n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
                const r = t._clip.uuid, o = this._actionsByClip, s = o[r], a = s.knownActions, l = a[a.length - 1],
                    c = t._byClipCacheIndex;
                l._byClipCacheIndex = c, a[c] = l, a.pop(), t._byClipCacheIndex = null;
                delete s.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete o[r], this._removeInactiveBindingsForAction(t)
            }

            _removeInactiveBindingsForAction(t) {
                const e = t._propertyBindings;
                for (let t = 0, n = e.length; t !== n; ++t) {
                    const n = e[t];
                    0 == --n.referenceCount && this._removeInactiveBinding(n)
                }
            }

            _lendAction(t) {
                const e = this._actions, n = t._cacheIndex, i = this._nActiveActions++, r = e[i];
                t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
            }

            _takeBackAction(t) {
                const e = this._actions, n = t._cacheIndex, i = --this._nActiveActions, r = e[i];
                t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
            }

            _addInactiveBinding(t, e, n) {
                const i = this._bindingsByRootAndName, r = this._bindings;
                let o = i[e];
                void 0 === o && (o = {}, i[e] = o), o[n] = t, t._cacheIndex = r.length, r.push(t)
            }

            _removeInactiveBinding(t) {
                const e = this._bindings, n = t.binding, i = n.rootNode.uuid, r = n.path,
                    o = this._bindingsByRootAndName, s = o[i], a = e[e.length - 1], l = t._cacheIndex;
                a._cacheIndex = l, e[l] = a, e.pop(), delete s[r], 0 === Object.keys(s).length && delete o[i]
            }

            _lendBinding(t) {
                const e = this._bindings, n = t._cacheIndex, i = this._nActiveBindings++, r = e[i];
                t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
            }

            _takeBackBinding(t) {
                const e = this._bindings, n = t._cacheIndex, i = --this._nActiveBindings, r = e[i];
                t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
            }

            _lendControlInterpolant() {
                const t = this._controlInterpolants, e = this._nActiveControlInterpolants++;
                let n = t[e];
                return void 0 === n && (n = new Rd(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
            }

            _takeBackControlInterpolant(t) {
                const e = this._controlInterpolants, n = t.__cacheIndex, i = --this._nActiveControlInterpolants,
                    r = e[i];
                t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
            }

            clipAction(t, e, n) {
                const i = e || this._root, r = i.uuid;
                let o = "string" == typeof t ? Hd.findByName(i, t) : t;
                const s = null !== o ? o.uuid : t, a = this._actionsByClip[s];
                let l = null;
                if (void 0 === n && (n = null !== o ? o.blendMode : Er), void 0 !== a) {
                    const t = a.actionByRoot[r];
                    if (void 0 !== t && t.blendMode === n) return t;
                    l = a.knownActions[0], null === o && (o = l._clip)
                }
                if (null === o) return null;
                const c = new Np(this, o, e, n);
                return this._bindAction(c, l), this._addInactiveAction(c, s, r), c
            }

            existingAction(t, e) {
                const n = e || this._root, i = n.uuid, r = "string" == typeof t ? Hd.findByName(n, t) : t,
                    o = r ? r.uuid : t, s = this._actionsByClip[o];
                return void 0 !== s && s.actionByRoot[i] || null
            }

            stopAllAction() {
                const t = this._actions;
                for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
                return this
            }

            update(t) {
                t *= this.timeScale;
                const e = this._actions, n = this._nActiveActions, i = this.time += t, r = Math.sign(t),
                    o = this._accuIndex ^= 1;
                for (let s = 0; s !== n; ++s) {
                    e[s]._update(i, t, r, o)
                }
                const s = this._bindings, a = this._nActiveBindings;
                for (let t = 0; t !== a; ++t) s[t].apply(o);
                return this
            }

            setTime(t) {
                this.time = 0;
                for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                return this.update(t)
            }

            getRoot() {
                return this._root
            }

            uncacheClip(t) {
                const e = this._actions, n = t.uuid, i = this._actionsByClip, r = i[n];
                if (void 0 !== r) {
                    const t = r.knownActions;
                    for (let n = 0, i = t.length; n !== i; ++n) {
                        const i = t[n];
                        this._deactivateAction(i);
                        const r = i._cacheIndex, o = e[e.length - 1];
                        i._cacheIndex = null, i._byClipCacheIndex = null, o._cacheIndex = r, e[r] = o, e.pop(), this._removeInactiveBindingsForAction(i)
                    }
                    delete i[n]
                }
            }

            uncacheRoot(t) {
                const e = t.uuid, n = this._actionsByClip;
                for (const t in n) {
                    const i = n[t].actionByRoot[e];
                    void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                }
                const i = this._bindingsByRootAndName[e];
                if (void 0 !== i) for (const t in i) {
                    const e = i[t];
                    e.restoreOriginalState(), this._removeInactiveBinding(e)
                }
            }

            uncacheAction(t, e) {
                const n = this.existingAction(t, e);
                null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
            }
        }).prototype._controlInterpolantsResultBuffer = new Float32Array(1);

        class Bp {
            constructor(t) {
                "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
            }

            clone() {
                return new Bp(void 0 === this.value.clone ? this.value : this.value.clone())
            }
        }

        (class extends bu {
            constructor(t, e, n = 1) {
                super(t, e), this.meshPerAttribute = n
            }

            copy(t) {
                return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
            }

            clone(t) {
                const e = super.clone(t);
                return e.meshPerAttribute = this.meshPerAttribute, e
            }

            toJSON(t) {
                const e = super.toJSON(t);
                return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
            }
        }).prototype.isInstancedInterleavedBuffer = !0;

        class Fp {
            constructor(t, e, n = 0, i = 1 / 0) {
                this.ray = new ko(t, e), this.near = n, this.far = i, this.camera = null, this.layers = new Yo, this.params = {
                    Mesh: {},
                    Line: {threshold: 1},
                    LOD: {},
                    Points: {threshold: 1},
                    Sprite: {}
                }
            }

            set(t, e) {
                this.ray.set(t, e)
            }

            setFromCamera(t, e) {
                e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
            }

            intersectObject(t, e = !0, n = []) {
                return Hp(t, this, n, e), n.sort(Up), n
            }

            intersectObjects(t, e = !0, n = []) {
                for (let i = 0, r = t.length; i < r; i++) Hp(t[i], this, n, e);
                return n.sort(Up), n
            }
        }

        function Up(t, e) {
            return t.distance - e.distance
        }

        function Hp(t, e, n, i) {
            if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) {
                const i = t.children;
                for (let t = 0, r = i.length; t < r; t++) Hp(i[t], e, n, !0)
            }
        }

        const Vp = new jr;

        class Gp {
            constructor(t = new jr(1 / 0, 1 / 0), e = new jr(-1 / 0, -1 / 0)) {
                this.min = t, this.max = e
            }

            set(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }

            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                return this
            }

            setFromCenterAndSize(t, e) {
                const n = Vp.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
            }

            clone() {
                return (new this.constructor).copy(this)
            }

            copy(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }

            makeEmpty() {
                return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
            }

            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }

            getCenter(t) {
                return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }

            getSize(t) {
                return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            }

            expandByPoint(t) {
                return this.min.min(t), this.max.max(t), this
            }

            expandByVector(t) {
                return this.min.sub(t), this.max.add(t), this
            }

            expandByScalar(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }

            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            }

            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            }

            getParameter(t, e) {
                return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            }

            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            }

            clampPoint(t, e) {
                return e.copy(t).clamp(this.min, this.max)
            }

            distanceToPoint(t) {
                return Vp.copy(t).clamp(this.min, this.max).sub(t).length()
            }

            intersect(t) {
                return this.min.max(t.min), this.max.min(t.max), this
            }

            union(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }

            translate(t) {
                return this.min.add(t), this.max.add(t), this
            }

            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }

        Gp.prototype.isBox2 = !0;
        const Wp = new oo, jp = new No, qp = new No;

        function Xp(t) {
            const e = [];
            t && t.isBone && e.push(t);
            for (let n = 0; n < t.children.length; n++) e.push.apply(e, Xp(t.children[n]));
            return e
        }

        const Yp = new Float32Array(1);
        new Int32Array(Yp.buffer);
        _h.create = function (t, e) {
            return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(_h.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
        }, Uh.prototype.fromPoints = function (t) {
            return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
        }, class extends ch {
            constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
                n = new Ps(n), i = new Ps(i);
                const r = e / 2, o = t / e, s = t / 2, a = [], l = [];
                for (let t = 0, c = 0, u = -s; t <= e; t++, u += o) {
                    a.push(-s, 0, u, s, 0, u), a.push(u, 0, -s, u, 0, s);
                    const e = t === r ? n : i;
                    e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3
                }
                const c = new Gs;
                c.setAttribute("position", new zs(a, 3)), c.setAttribute("color", new zs(l, 3));
                super(c, new th({vertexColors: !0, toneMapped: !1})), this.type = "GridHelper"
            }
        }.prototype.setColors = function () {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }, class extends ch {
            constructor(t) {
                const e = Xp(t), n = new Gs, i = [], r = [], o = new Ps(0, 0, 1), s = new Ps(0, 1, 0);
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(s.r, s.g, s.b))
                }
                n.setAttribute("position", new zs(i, 3)), n.setAttribute("color", new zs(r, 3));
                super(n, new th({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
            }

            updateMatrixWorld(t) {
                const e = this.bones, n = this.geometry, i = n.getAttribute("position");
                qp.copy(this.root.matrixWorld).invert();
                for (let t = 0, n = 0; t < e.length; t++) {
                    const r = e[t];
                    r.parent && r.parent.isBone && (jp.multiplyMatrices(qp, r.matrixWorld), Wp.setFromMatrixPosition(jp), i.setXYZ(n, Wp.x, Wp.y, Wp.z), jp.multiplyMatrices(qp, r.parent.matrixWorld), Wp.setFromMatrixPosition(jp), i.setXYZ(n + 1, Wp.x, Wp.y, Wp.z), n += 2)
                }
                n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
            }
        }.prototype.update = function () {
            console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
        }, qd.prototype.extractUrlBase = function (t) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), vp.extractUrlBase(t)
        }, qd.Handlers = {
            add: function () {
                console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
            }, get: function () {
                console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
            }
        }, Gp.prototype.center = function (t) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
        }, Gp.prototype.empty = function () {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, Gp.prototype.isIntersectionBox = function (t) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        }, Gp.prototype.size = function (t) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
        }, lo.prototype.center = function (t) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
        }, lo.prototype.empty = function () {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, lo.prototype.isIntersectionBox = function (t) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        }, lo.prototype.isIntersectionSphere = function (t) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        }, lo.prototype.size = function (t) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
        }, Po.prototype.empty = function () {
            return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, Ea.prototype.setFromMatrix = function (t) {
            return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
        }, qr.prototype.flattenToArrayOffset = function (t, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        }, qr.prototype.multiplyVector3 = function (t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
        }, qr.prototype.multiplyVector3Array = function () {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        }, qr.prototype.applyToBufferAttribute = function (t) {
            return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
        }, qr.prototype.applyToVector3Array = function () {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }, qr.prototype.getInverse = function (t) {
            return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
        }, No.prototype.extractPosition = function (t) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
        }, No.prototype.flattenToArrayOffset = function (t, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        }, No.prototype.getPosition = function () {
            return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new oo).setFromMatrixColumn(this, 3)
        }, No.prototype.setRotationFromQuaternion = function (t) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
        }, No.prototype.multiplyToArray = function () {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        }, No.prototype.multiplyVector3 = function (t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        }, No.prototype.multiplyVector4 = function (t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        }, No.prototype.multiplyVector3Array = function () {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        }, No.prototype.rotateAxis = function (t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
        }, No.prototype.crossVector = function (t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        }, No.prototype.translate = function () {
            console.error("THREE.Matrix4: .translate() has been removed.")
        }, No.prototype.rotateX = function () {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        }, No.prototype.rotateY = function () {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        }, No.prototype.rotateZ = function () {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        }, No.prototype.rotateByAxis = function () {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        }, No.prototype.applyToBufferAttribute = function (t) {
            return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        }, No.prototype.applyToVector3Array = function () {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        }, No.prototype.makeFrustum = function (t, e, n, i, r, o) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, o)
        }, No.prototype.getInverse = function (t) {
            return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
        }, Sa.prototype.isIntersectionLine = function (t) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
        }, ro.prototype.multiplyVector3 = function (t) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
        }, ro.prototype.inverse = function () {
            return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
        }, ko.prototype.isIntersectionBox = function (t) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        }, ko.prototype.isIntersectionPlane = function (t) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
        }, ko.prototype.isIntersectionSphere = function (t) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        }, xs.prototype.area = function () {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        }, xs.prototype.barycoordFromPoint = function (t, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
        }, xs.prototype.midpoint = function (t) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
        }, xs.prototypenormal = function (t) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
        }, xs.prototype.plane = function (t) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
        }, xs.barycoordFromPoint = function (t, e, n, i, r) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), xs.getBarycoord(t, e, n, i, r)
        }, xs.normal = function (t, e, n, i) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), xs.getNormal(t, e, n, i)
        }, Hh.prototype.extractAllPoints = function (t) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
        }, Hh.prototype.extrude = function (t) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new gd(this, t)
        }, Hh.prototype.makeGeometry = function (t) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new yd(this, t)
        }, jr.prototype.fromAttribute = function (t, e, n) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        }, jr.prototype.distanceToManhattan = function (t) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
        }, jr.prototype.lengthManhattan = function () {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }, oo.prototype.setEulerFromRotationMatrix = function () {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        }, oo.prototype.setEulerFromQuaternion = function () {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        }, oo.prototype.getPositionFromMatrix = function (t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
        }, oo.prototype.getScaleFromMatrix = function (t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
        }, oo.prototype.getColumnFromMatrix = function (t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
        }, oo.prototype.applyProjection = function (t) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
        }, oo.prototype.fromAttribute = function (t, e, n) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        }, oo.prototype.distanceToManhattan = function (t) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
        }, oo.prototype.lengthManhattan = function () {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }, eo.prototype.fromAttribute = function (t, e, n) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        }, eo.prototype.lengthManhattan = function () {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }, ls.prototype.getChildByName = function (t) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
        }, ls.prototype.renderDepth = function () {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        }, ls.prototype.translate = function (t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
        }, ls.prototype.getWorldRotation = function () {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }, ls.prototype.applyMatrix = function (t) {
            return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
        }, Object.defineProperties(ls.prototype, {
            eulerOrder: {
                get: function () {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                }, set: function (t) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                }
            }, useQuaternion: {
                get: function () {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }, set: function () {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }), aa.prototype.setDrawMode = function () {
            console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }, Object.defineProperties(aa.prototype, {
            drawMode: {
                get: function () {
                    return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                }, set: function () {
                    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                }
            }
        }), ju.prototype.initBones = function () {
            console.error("THREE.SkinnedMesh: initBones() has been removed.")
        }, ma.prototype.setLens = function (t, e) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
        }, Object.defineProperties(Kd.prototype, {
            onlyShadow: {
                set: function () {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            }, shadowCameraFov: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                }
            }, shadowCameraLeft: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                }
            }, shadowCameraRight: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                }
            }, shadowCameraTop: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                }
            }, shadowCameraBottom: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                }
            }, shadowCameraNear: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                }
            }, shadowCameraFar: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                }
            }, shadowCameraVisible: {
                set: function () {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            }, shadowBias: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                }
            }, shadowDarkness: {
                set: function () {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            }, shadowMapWidth: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                }
            }, shadowMapHeight: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                }
            }
        }), Object.defineProperties(Is.prototype, {
            length: {
                get: function () {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                }
            }, dynamic: {
                get: function () {
                    return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Or
                }, set: function () {
                    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Or)
                }
            }
        }), Is.prototype.setDynamic = function (t) {
            return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Or : Ir), this
        }, Is.prototype.copyIndicesArray = function () {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }, Is.prototype.setArray = function () {
            console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }, Gs.prototype.addIndex = function (t) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
        }, Gs.prototype.addAttribute = function (t, e) {
            return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Is(arguments[1], arguments[2])))
        }, Gs.prototype.addDrawCall = function (t, e, n) {
            void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
        }, Gs.prototype.clearDrawCalls = function () {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        }, Gs.prototype.computeOffsets = function () {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }, Gs.prototype.removeAttribute = function (t) {
            return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
        }, Gs.prototype.applyMatrix = function (t) {
            return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
        }, Object.defineProperties(Gs.prototype, {
            drawcalls: {
                get: function () {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                }
            }, offsets: {
                get: function () {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                }
            }
        }), bu.prototype.setDynamic = function (t) {
            return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Or : Ir), this
        }, bu.prototype.setArray = function () {
            console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }, gd.prototype.getArrays = function () {
            console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
        }, gd.prototype.addShapeList = function () {
            console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
        }, gd.prototype.addShape = function () {
            console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
        }, _u.prototype.dispose = function () {
            console.error("THREE.Scene: .dispose() has been removed.")
        },Bp.prototype.onUpdate = function () {
            return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
        },Object.defineProperties(bs.prototype, {
            wrapAround: {
                get: function () {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }, set: function () {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }
            }, overdraw: {
                get: function () {
                    console.warn("THREE.Material: .overdraw has been removed.")
                }, set: function () {
                    console.warn("THREE.Material: .overdraw has been removed.")
                }
            }, wrapRGB: {
                get: function () {
                    return console.warn("THREE.Material: .wrapRGB has been removed."), new Ps
                }
            }, shading: {
                get: function () {
                    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                }, set: function (t) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
                }
            }, stencilMask: {
                get: function () {
                    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                }, set: function (t) {
                    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
                }
            }, vertexTangents: {
                get: function () {
                    console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                }, set: function () {
                    console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                }
            }
        }),Object.defineProperties(pa.prototype, {
            derivatives: {
                get: function () {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                }, set: function (t) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                }
            }
        }),vu.prototype.clearTarget = function (t, e, n, i) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i)
        },vu.prototype.animate = function (t) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
        },vu.prototype.getCurrentRenderTarget = function () {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        },vu.prototype.getMaxAnisotropy = function () {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        },vu.prototype.getPrecision = function () {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        },vu.prototype.resetGLState = function () {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        },vu.prototype.supportsFloatTextures = function () {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        },vu.prototype.supportsHalfFloatTextures = function () {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        },vu.prototype.supportsStandardDerivatives = function () {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        },vu.prototype.supportsCompressedTextureS3TC = function () {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        },vu.prototype.supportsCompressedTexturePVRTC = function () {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },vu.prototype.supportsBlendMinMax = function () {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        },vu.prototype.supportsVertexTextures = function () {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        },vu.prototype.supportsInstancedArrays = function () {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        },vu.prototype.enableScissorTest = function (t) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
        },vu.prototype.initMaterial = function () {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },vu.prototype.addPrePlugin = function () {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },vu.prototype.addPostPlugin = function () {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },vu.prototype.updateShadowMap = function () {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },vu.prototype.setFaceCulling = function () {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        },vu.prototype.allocTextureUnit = function () {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        },vu.prototype.setTexture = function () {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        },vu.prototype.setTexture2D = function () {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        },vu.prototype.setTextureCube = function () {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        },vu.prototype.getActiveMipMapLevel = function () {
            return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
        },Object.defineProperties(vu.prototype, {
            shadowMapEnabled: {
                get: function () {
                    return this.shadowMap.enabled
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                }
            }, shadowMapType: {
                get: function () {
                    return this.shadowMap.type
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                }
            }, shadowMapCullFace: {
                get: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                }, set: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                }
            }, context: {
                get: function () {
                    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                }
            }, vr: {
                get: function () {
                    return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                }
            }, gammaInput: {
                get: function () {
                    return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                }, set: function () {
                    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                }
            }, gammaOutput: {
                get: function () {
                    return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? Pr : Ar
                }
            }, toneMappingWhitePoint: {
                get: function () {
                    return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                }, set: function () {
                    console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                }
            }
        }),Object.defineProperties(su.prototype, {
            cullFace: {
                get: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                }, set: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                }
            }, renderReverseSided: {
                get: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                }, set: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                }
            }, renderSingleSided: {
                get: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                }, set: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                }
            }
        }),Object.defineProperties(no.prototype, {
            wrapS: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                }
            }, wrapT: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                }
            }, magFilter: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                }
            }, minFilter: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                }
            }, anisotropy: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                }
            }, offset: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                }
            }, repeat: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                }
            }, format: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                }
            }, type: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                }
            }, generateMipmaps: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                }
            }
        }),Mp.prototype.load = function (t) {
            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
            const e = this;
            return (new bp).load(t, (function (t) {
                e.setBuffer(t)
            })), this
        },va.prototype.updateCubeMap = function (t, e) {
            return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
        },va.prototype.clear = function (t, e, n, i) {
            return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, i)
        },Qr.crossOrigin = void 0,Qr.loadTexture = function (t, e, n, i) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            const r = new Qd;
            r.setCrossOrigin(this.crossOrigin);
            const o = r.load(t, n, void 0, i);
            return e && (o.mapping = e), o
        },Qr.loadTextureCube = function (t, e, n, i) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            const r = new Zd;
            r.setCrossOrigin(this.crossOrigin);
            const o = r.load(t, n, void 0, i);
            return e && (o.mapping = e), o
        },Qr.loadCompressedTexture = function () {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        },Qr.loadCompressedTextureCube = function () {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        };
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail: {revision: Yi}})), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Yi);

        class Jp {
            constructor(t, e, n, i, r) {
                this.scene = e, this.asscroll = n, this.allMeshes = i, this.imageLength = r, this.viewport = {
                    width: window.innerWidth,
                    height: window.innerHeight
                }, this.clock = new wp, "item--video" === t.classList.value ? this.createVideo(t) : this.createMedia(t)
            }

            createMedia(t) {
                this.bounds = t.getBoundingClientRect(), this.media = new Image, this.media.src = t.src, this.media.dataset.scrollmodifier = t.dataset.scrollmodifier, this.media.dataset.itemposition = t.dataset.itemposition, this.media.crossOrigin = "anonymous", this.media.onload = t => {
                    this.createTexture()
                }
            }

            createVideo(t) {
                this.bounds = t.getBoundingClientRect(), this.media = t, this.media.crossOrigin = "anonymous", this.media.dataset.scrollmodifier = t.dataset.scrollmodifier, this.createTexture(this.media)
            }

            createTexture() {
                "item--video" === this.media.classList.value ? this.texture = new yh(this.media) : this.texture = new $r(this.media), this.texture.needsUpdate = !0, this.createMaterial()
            }

            createMaterial() {
                this.baseMaterial = new pa({
                    uniforms: {
                        uTime: {value: 0},
                        uImage: {value: null},
                        uScrollSpeed: {value: this.scrollSpeed},
                        uScrollModifier: {value: this.media.dataset.scrollmodifier},
                        uScrollProgress: {value: this.asscroll.currentPos},
                        uViewportSizes: {value: new jr(this.viewport.width, this.viewport.height)},
                        uStrength: {value: 0},
                        uProgress: {value: 1}
                    },
                    vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n#define PI 3.1415926535897932384626433832795\n\nuniform float uScrollSpeed;\nuniform vec2 uViewportSizes;\nuniform float uScrollModifier;\nuniform float uScrollProgress;\n\nvoid main() {\n\n    vec4 newPosition = modelViewMatrix * vec4(position, 1.0);\n\n    newPosition.z += sin(newPosition.y / uViewportSizes.y * PI + PI / 2.0) * - (uScrollSpeed * 8.0);\n    newPosition.y += -uScrollModifier * uScrollProgress * 0.02;\n\n    gl_Position = projectionMatrix * newPosition;\n\n    vUv = uv;\n}",
                    fragmentShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nuniform sampler2D uImage;\nvarying float vTime;\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec4 textureImg = texture2D(uImage, vUv);\n\n    gl_FragColor = textureImg;\n}",
                    side: 2
                }), this.materials = [], this.material = this.baseMaterial.clone(), this.materials.push(this.material), this.material.uniforms.uImage.value = this.texture, this.createGeometry()
            }

            createGeometry() {
                this.geometry = new La(this.bounds.width, this.bounds.height, 16, 16), this.createMesh()
            }

            createMesh() {
                this.mesh = new aa(this.geometry, this.material), this.mesh.frustumCulled = !1, this.mesh.elementTop = this.bounds.top, this.mesh.scrollDataModifier = this.media.dataset.scrollmodifier, this.mesh.itemposition = this.media.dataset.itemposition, this.allMeshes.push(this.mesh), this.scene.add(this.mesh), this.setImagesPositions(), this.addEventListeners()
            }

            setImagesPositions() {
                this.mesh.position.y = this.asscroll.currentPos - this.bounds.top + this.viewport.height / 2 - this.bounds.height / 2, this.mesh.position.x = this.bounds.left - this.viewport.width / 2 + this.bounds.width / 2, this.mesh.baseY = this.mesh.position.y, this.mesh.baseX = this.mesh.position.x
            }

            addEventListeners() {
                window.addEventListener("wheel", (t => {
                    this.material.uniforms.uScrollSpeed.value = (this.asscroll.currentPos - this.asscroll.targetPos) / this.viewport.width * 15, this.material.uniforms.uScrollProgress.value = this.asscroll.currentPos
                }))
            }
        }

        class Zp {
            constructor(t) {
                this.element = t.dom, this.asscroll = t.asscroll, this.viewport = {
                    width: window.innerWidth,
                    height: window.innerHeight
                }, this.closable = 0, this.allMeshes = [], this.basePositions = [], this.loader = new Qd, this.scrollSpeed = 0, this.clock = new wp, this.update = this.update.bind(this), this.allImages = [...document.querySelectorAll(".playground__gallery img")], this.allVideos = [...document.querySelectorAll(".item--video")], this.loadedLength = 0, this.mouse = new jr, this.raycaster = new Fp, Promise.all(this.allImages.filter((t => !t.complete)).map((t => new Promise((e => {
                    t.onload = t.onerror = e
                }))))).then((() => {
                    this.init()
                }))
            }

            init() {
                this.addCanvas(), this.addScene(), this.addCamera(), this.addImages(), this.allVideos.length > 0 && this.addVideos(), this.setImagesPositions(), this.onMouseMovement(), this.onResize(), this.addEventListeners(this.closable), this.update()
            }

            addCanvas() {
                this.renderer = new vu({
                    antialias: !0,
                    alpha: !0,
                    powerPreference: "high-performance"
                }), this.canvas = this.renderer.domElement, this.canvas.classList.add("playground__canvas"), this.element.appendChild(this.canvas)
            }

            addScene() {
                this.scene = new _u
            }

            addCamera() {
                this.camera = new ma(70, this.viewport.width / this.viewport.height, 100, 2e3), this.scene.add(this.camera)
            }

            addImages() {
                this.imageStore = this.allImages.map((t => {
                    new Jp(t, this.scene, this.asscroll, this.allMeshes, this.allImages.length)
                }))
            }

            addVideos() {
                this.allVideos.forEach((t => {
                    new Jp(t, this.scene, this.asscroll, this.allMeshes, this.allImages.length)
                }))
            }

            setImagesPositions() {
                this.allMeshes && this.allMeshes.forEach((t => {
                    let e = -this.asscroll.currentPos * -t.scrollDataModifier - t.elementTop + this.viewport.height / 2 - t.geometry.parameters.height / 2;
                    t.position.y = e, t.updatedY = e
                }))
            }

            addEventListeners() {
                window.addEventListener("resize", this.onResize.bind(this)), window.addEventListener("click", (t => {
                    t.preventDefault(), this.mouse.x = t.clientX / this.viewport.width * 2 - 1, this.mouse.y = -t.clientY / this.viewport.height * 2 + 1, this.raycaster.setFromCamera(this.mouse, this.camera);
                    const e = this.raycaster.intersectObjects(this.scene.children);
                    if (e.length > 0) {
                        let t = e[0].object;
                        this.allMeshes.forEach((e => {
                            e.position.x >= t.position.x ? e.uuid !== t.uuid && Ai.to(e.position, {
                                x: e.position.x + window.innerWidth + e.geometry.parameters.width,
                                duration: 1.5,
                                ease: yn.easeInOut,
                                stagger: .1
                            }) : e.uuid !== t.uuid && Ai.to(e.position, {
                                x: e.position.x - window.innerWidth - e.geometry.parameters.width,
                                duration: 1.5,
                                ease: yn.easeInOut
                            })
                        })), Ai.to(t.position, {
                            x: (window.innerWidth / 2 - 2 * t.geometry.parameters.width) / 2,
                            duration: 1.5,
                            delay: .13,
                            ease: yn.easeInOut,
                            onStart: () => this.initialCameraPositionY = this.camera.position.y,
                            onComplete: () => this.closable = 1
                        }), Ai.to(t.scale, {
                            x: 1.2,
                            y: 1.2,
                            z: 1.2,
                            duration: 1.5,
                            delay: 1.25,
                            ease: yn.easeInOut
                        }), 700 === this.camera.position.z && Ai.to(this.camera.position, {
                            y: t.position.y - 10 * t.itemposition,
                            duration: 1.5,
                            delay: 1.25,
                            ease: yn.easeInOut
                        }), Ai.to(".l__navbar", {
                            filter: "blur(4px)",
                            duration: .75,
                            delay: .13,
                            ease: yn.easeInOut
                        }), Ai.to(".playground__header", {
                            filter: "blur(4px)",
                            duration: .75,
                            delay: .13,
                            ease: yn.easeInOut
                        }), document.querySelector(".playground__canvas").classList.add("canvas--close"), this.asscroll.disable()
                    }
                })), window.addEventListener("click", (t => {
                    0 === this.raycaster.intersectObjects(this.scene.children).length && 1 === this.closable && (t.preventDefault(), this.asscroll.enable(), this.allMeshes.forEach(((t, e) => {
                        Ai.to(this.camera.position, {
                            z: 700,
                            y: this.initialCameraPositionY,
                            duration: 1.5,
                            ease: yn.easeInOut
                        }), Ai.to(t.position, {
                            y: t.baseY,
                            x: t.baseX,
                            delay: 1,
                            duration: 1.5,
                            ease: yn.easeInOut
                        }), Ai.to(t.scale, {
                            x: 1,
                            y: 1,
                            z: 1,
                            duration: 1.5,
                            ease: yn.easeInOut
                        }), Ai.to(".l__navbar", {
                            filter: "blur(0px)",
                            duration: .75,
                            delay: .13,
                            ease: yn.easeInOut
                        }), Ai.to(".playground__header", {
                            filter: "blur(0px)",
                            duration: .75,
                            delay: .13,
                            ease: yn.easeInOut
                        })
                    })), document.querySelector(".playground__canvas").classList.remove("canvas--close"))
                }))
            }

            onResize() {
                this.viewport = {
                    width: window.innerWidth,
                    height: window.innerHeight
                }, this.camera.position.z = 700, this.camera.fov = 2 * Math.atan(this.viewport.height / 2 / this.camera.position.z) * (180 / Math.PI), this.camera.aspect = this.viewport.width / this.viewport.height, this.camera.updateProjectionMatrix(), this.renderer.setSize(this.viewport.width, this.viewport.height), this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5))
            }

            onMouseMovement() {
                window.addEventListener("mousemove", (t => {
                }), !1)
            }

            update() {
                this.setImagesPositions(), this.render(), window.requestAnimationFrame(this.update)
            }

            render() {
                this.renderer.render(this.scene, this.camera)
            }
        }

        class Qp extends Li {
            constructor() {
                super({
                    id: "playground",
                    element: ".l__content",
                    elements: {}
                }), this.asscroll = new (zi())({disableRaf: !0}), this.initScroll(this.asscroll), this.splitText(), this.isMobile = window.innerWidth < 1024, this.isMobile || this.initPlaygroundCanvas(), this.addEventListeners()
            }

            initPlaygroundCanvas() {
                new Zp({dom: document.querySelector(".main__container"), asscroll: this.asscroll})
            }

            splitText() {
                document.querySelectorAll(".splitText").forEach((t => {
                    new (Fi())(t)
                }))
            }

            initScroll(t) {
                Ai.ticker.add(t.update), t.enable({horizontalScroll: !1, reset: !0}), setTimeout((() => {
                    t.currentPos = 0, t.resize()
                }), 500)
            }

            show() {
                Ai.set(".l__content", {pointerEvents: "all"});
                const t = Ai.timeline({delay: 1.3, ease: yn.easeInOut});
                t.to("#cursor span", {backgroundColor: "black"}, "showProject"), t.to("#cursor", {mixBlendMode: "unset"}, "showProject"), t.to(".navbar__menu--logo", {filter: "invert(1)"}, "showProject"), t.to(".playground__title .SplitTextJS-char", {
                    rotateX: 0,
                    y: 0,
                    x: 0,
                    opacity: 1,
                    stagger: .06,
                    duration: 1,
                    ease: yn.easeInOut
                }, "showProject"), t.to(".playground__label", {
                    y: 0,
                    opacity: 1
                }, "showProject+=0.60"), t.to(".playground--scrollIcon img", {
                    y: 0,
                    x: 0,
                    opacity: 1,
                    duration: 1,
                    ease: yn.easeInOut,
                    delay: "-0.5"
                }), t.to(".navbar__menu--trigger", {
                    transitionDelay: .2,
                    transitionDuration: .6,
                    duration: 0,
                    onComplete: () => this.asscroll.resize()
                }, "showProject+=0.5")
            }

            create() {
                super.create(), document.querySelector(".l__navbar").classList.add("navbar--black"), this.navigation = new ji(this.asscroll), new qi
            }

            addEventListeners() {
            }
        }

        const Kp = "#define GLSLIFY 1\nvarying vec2 vUv;\n#define PI 3.1415926535897932384626433832795\n\nuniform float uScrollSpeed;\nuniform vec2 uViewportSizes;\nuniform float uTime;\n\nvoid main() {\n\n    vec4 newPosition = modelViewMatrix * vec4(position, 1.0);\n\n    newPosition.z += sin(newPosition.y / uViewportSizes.y * PI + PI / 2.0) * - (uScrollSpeed * 15.0);\n\n    gl_Position = projectionMatrix * newPosition;\n\n    vUv = uv;\n}",
            $p = "#define GLSLIFY 1\nvarying vec2 vUv;\nuniform sampler2D uImage;\nvarying float vTime;\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec4 textureImg = texture2D(uImage, vUv);\n\n    gl_FragColor = textureImg;\n}";

        class tf {
            constructor(t, e, n) {
                this.img = t, this.scene = e, this.asscroll = n, this.viewport = {
                    width: window.innerWidth,
                    height: window.innerHeight
                }, this.isSafari = /constructor/i.test(window.HTMLElement) || "[object SafariRemoteNotification]" === (!window.safari || "undefined" != typeof safari && window.safari.pushNotification).toString(), "item--video" === t.classList.value && this.isSafari && t.classList.add("safari-video"), "item--video" === t.classList.value ? this.createVideo(t) : this.createMedia(t), this.addEventListeners()
            }

            createMedia(t) {
                this.bounds = t.getBoundingClientRect(), this.media = new Image, this.media.src = t.src, this.media.alt = t.alt, this.media.crossOrigin = "anonymous", this.media.onload = t => {
                    this.createTexture()
                }
            }

            createVideo(t) {
                this.bounds = t.getBoundingClientRect(), this.media = t, this.media.crossOrigin = "anonymous", this.createTexture(this.media)
            }

            createTexture() {
                "item--video" === this.media.classList.value ? this.texture = new yh(this.media) : this.texture = new $r(this.media), this.texture.needsUpdate = !0, this.createMaterial()
            }

            createMaterial() {
                this.baseMaterial = new pa({
                    uniforms: {
                        uTime: {value: 0},
                        uImage: {value: null},
                        uScrollSpeed: {value: this.scrollSpeed},
                        uViewportSizes: {value: new jr(this.viewport.width, this.viewport.height)}
                    }, vertexShader: Kp, fragmentShader: $p, side: 2
                }), this.materials = [], this.material = this.baseMaterial.clone(), this.materials.push(this.material), this.material.uniforms.uImage.value = this.texture, this.createGeometry()
            }

            createGeometry() {
                this.geometry = new La(this.bounds.width, this.bounds.height, 16, 16), this.createMesh()
            }

            createMesh() {
                this.mesh = new aa(this.geometry, this.material), this.scene.add(this.mesh), this.setMeshPosition()
            }

            setMeshPosition() {
                this.mesh.position.y = -this.bounds.top + this.viewport.height / 2 - this.bounds.height / 2, this.mesh.position.x = this.bounds.left - this.viewport.width / 2 + this.bounds.width / 2
            }

            addEventListeners() {
                window.addEventListener("wheel", (t => {
                    this.material.uniforms.uScrollSpeed.value = (this.asscroll.currentPos - this.asscroll.targetPos) / this.viewport.width * 15
                }))
            }
        }

        class ef {
            constructor(t) {
                this.element = t.dom, this.asscroll = t.asscroll, this.viewport = {
                    width: window.innerWidth,
                    height: window.innerHeight
                }, this.loader = new Qd, this.loader.crossOrigin = "Anonymous", this.scrollSpeed = 0, this.clock = new wp, this.update = this.update.bind(this), this.allImages = [...document.querySelectorAll(".webgl__image")], this.allVideos = [...document.querySelectorAll(".project__details--content video")], this.loadedLength = 0, this.mouse = new jr, this.raycaster = new Fp, Promise.all(this.allImages.filter((t => !t.complete)).map((t => new Promise((e => {
                    t.onload = t.onerror = e
                }))))).then((() => {
                    this.init()
                })), this.imagesGroup = new hu
            }

            init() {
                this.addCanvas(), this.addScene(), this.addCamera(), this.addImages(), this.allVideos.length > 0 && this.addVideos(), this.setImagesPositions(), this.onResize(), this.addEventListeners(), this.update()
            }

            addCanvas() {
                this.renderer = new vu({
                    antialias: !0,
                    alpha: !1,
                    powerPreference: "high-performance"
                }), this.canvas = this.renderer.domElement, this.canvas.classList.add("webgl"), this.element.appendChild(this.canvas)
            }

            addScene() {
                this.scene = new _u
            }

            addCamera() {
                this.camera = new ma(70, this.viewport.width / this.viewport.height, 100, 2e3), this.scene.add(this.camera)
            }

            addImages() {
                this.material = new pa({
                    uniforms: {
                        uTime: {value: 0},
                        uImage: {value: 0},
                        uHover: {value: new jr(.5, .5)},
                        uHoverState: {value: 0},
                        uScrollSpeed: {value: this.scrollSpeed},
                        uViewportSizes: {value: new jr(this.viewport.width, this.viewport.height)}
                    }, fragmentShader: $p, vertexShader: Kp, wireframe: !0
                }), this.materials = [], this.imageStore = this.allImages.map((t => {
                    new tf(t, this.scene, this.asscroll)
                }))
            }

            addVideos() {
                this.allVideos.forEach((t => {
                    new tf(t, this.scene, this.asscroll)
                }))
            }

            createTexture() {
            }

            setImagesPositions() {
                this.scene.add(this.imagesGroup), this.camera.position.y = -this.asscroll.currentPos
            }

            addEventListeners() {
                window.addEventListener("resize", this.onResize.bind(this)), window.addEventListener("wheel", (t => {
                    this.scrollSpeed = (this.asscroll.currentPos - this.asscroll.targetPos) / this.viewport.width * 15
                }))
            }

            onResize() {
                this.viewport = {
                    width: window.innerWidth,
                    height: window.innerHeight
                }, this.camera.position.z = 700, this.camera.fov = 2 * Math.atan(this.viewport.height / 2 / this.camera.position.z) * (180 / Math.PI), this.camera.aspect = this.viewport.width / this.viewport.height, this.camera.updateProjectionMatrix(), this.renderer.setSize(this.viewport.width, this.viewport.height), this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5))
            }

            onMouseMovement() {
                window.addEventListener("mousemove", (t => {
                    this.mouse.x = t.clientX / this.viewport.width * 2 - 1, this.mouse.y = -t.clientY / this.viewport.height * 2 + 1, this.raycaster.setFromCamera(this.mouse, this.camera);
                    const e = this.raycaster.intersectObjects(this.scene.children);
                    if (e.length > 0) {
                        e[0].object.material.uniforms.uHover.value = e[0].uv
                    }
                }), !1)
            }

            update() {
                const t = this.clock.getElapsedTime();
                this.materials.forEach((e => {
                    e.uniforms.uTime.value = t, e.uniforms.uScrollSpeed.value = this.scrollSpeed
                })), this.setImagesPositions(), this.render(), window.requestAnimationFrame(this.update)
            }

            render() {
                this.renderer.render(this.scene, this.camera)
            }
        }

        class nf extends Li {
            constructor() {
                super({
                    id: "project",
                    element: ".l__content",
                    elements: {}
                }), this.asscroll = new (zi())({disableRaf: !0}), this.initScroll(this.asscroll), this.allProjectLinks = Ai.utils.toArray(document.querySelectorAll("[data-transition-project]")), this.isMobile = window.innerWidth < 1024, this.isSafari = /constructor/i.test(window.HTMLElement) || "[object SafariRemoteNotification]" === (!window.safari || "undefined" != typeof safari && window.safari.pushNotification).toString(), this.isMobile || this.initProjectCanvas(), this.addEventListeners(), this.initSwiper(), this.splitText()
            }

            initProjectCanvas() {
                new ef({dom: document.querySelector(".main__container"), asscroll: this.asscroll})
            }

            initScroll(t) {
                Ai.ticker.add(t.update), t.enable({horizontalScroll: !1, reset: !0}), setTimeout((() => {
                    t.currentPos = 0, t.resize()
                }), 1e3)
            }

            expandYoutubeVideo() {
                Ai.to(".preloader__overlay--black", {top: 0, ease: yn.easeInOut, duration: 1.5});
                let t = document.querySelector(".preloader__overlay--black");
                t.classList.add("iframed");
                const e = `${document.querySelector(".embed__trigger").dataset.youtube}?autoplay=1&mute=1`,
                    n = document.createElement("iframe");
                n.id = "youtube_embed", n.setAttribute("src", e), t.appendChild(n)
            }

            splitText() {
                document.querySelectorAll(".splitText").forEach((t => {
                    new (Fi())(t)
                }))
            }

            show() {
                Ai.set(".l__content", {pointerEvents: "all"});
                const t = Ai.timeline({delay: 1.3, ease: yn.easeInOut});
                t.to(".project__title .SplitTextJS-char", {
                    rotateX: 0,
                    y: 0,
                    x: 0,
                    opacity: 1,
                    stagger: .06,
                    duration: 1.2,
                    ease: yn.easeInOut
                }, "showProject"), t.to(".project__label", {
                    y: 0,
                    opacity: 1
                }, "showProject+=0.60"), t.to(".project__animateIn", {
                    y: 0,
                    opacity: 1,
                    duration: .6,
                    stagger: .15
                }, "showProject+=0.60"), t.to(".project__details--link", {
                    y: 0,
                    opacity: 1,
                    duration: .6,
                    delay: "-0.50"
                }), t.to(".project__details--scrollIcon img", {
                    y: 0,
                    x: 0,
                    opacity: 1,
                    duration: 1,
                    ease: yn.easeInOut,
                    delay: "-0.5"
                }), t.to(".navbar__menu--trigger", {
                    transitionDelay: .2,
                    transitionDuration: .6,
                    duration: 0,
                    onComplete: () => this.asscroll.resize()
                }, "showProject+=2")
            }

            create() {
                super.create(), this.navigation = new ji(this.asscroll), new qi
            }

            addEventListeners() {
                document.querySelector(".embed__trigger") && document.querySelector(".embed__trigger").addEventListener("click", (() => {
                    this.expandYoutubeVideo()
                })), this.allProjectLinks.forEach((t => {
                    t.addEventListener("click", (e => {
                        e.preventDefault();
                        const n = Ai.timeline();
                        n.to(".preloader__overlay--yellow", {
                            top: 0,
                            duration: 1.3,
                            ease: yn.easeInOut
                        }), n.to(".preloader__overlay--black", {
                            top: 0,
                            delay: -1.2,
                            duration: 1.3,
                            ease: yn.easeInOut,
                            onComplete: () => {
                                window.location.href = t.getAttribute("href")
                            }
                        })
                    }))
                })), document.body.addEventListener("click", (function (t) {
                    t.target.classList.contains("iframed") && Ai.to(".preloader__overlay--black", {
                        top: "100%",
                        ease: yn.easeInOut,
                        duration: 1.5,
                        onComplete: () => {
                            document.querySelector(".iframed").innerHTML = "", document.querySelector(".iframed").classList.remove("iframed")
                        }
                    })
                }))
            }

            initSwiper() {
                new Swiper(".swiper", {
                    direction: "horizontal",
                    preventClicks: !0,
                    freeMode: {enabled: !0, momentumBounce: !1},
                    slidesPerView: "auto",
                    breakpoints: {1024: {slidesPerView: 4}}
                })
            }
        }

        var rf = n(714), of = n.n(rf);

        class sf extends Li {
            constructor() {
                super({id: "notFound", element: ".l__notFound", elements: {}}), this.setup404()
            }

            setup404() {
                var t = of().Engine, e = of().Render, n = of().Common, i = of().Runner, r = of().MouseConstraint,
                    o = of().Mouse, s = of().Composite, a = of().Bodies;
                n.setDecomp(this.decomp);
                var l = t.create(), c = l.world, u = e.create({
                    element: document.querySelector(".l__notFound"),
                    engine: l,
                    options: {background: "#000", width: window.innerWidth, height: window.innerHeight, wireframes: !1}
                });
                e.run(u);
                var h = i.create();
                i.run(h, l), setTimeout((() => {
                    s.add(c, [a.rectangle(window.innerWidth / 2, 10, window.innerWidth, 10, {
                        isStatic: !0,
                        render: {visible: !1}
                    }), a.rectangle(window.innerWidth / 2 + 10, window.innerHeight, window.innerWidth, 10, {
                        isStatic: !0,
                        render: {visible: !1}
                    }), a.rectangle(window.innerWidth, window.innerHeight / 2 + 10, 10, window.innerHeight, {
                        isStatic: !0,
                        render: {visible: !1}
                    }), a.rectangle(10, window.innerHeight / 2, 10, window.innerHeight, {
                        isStatic: !0,
                        render: {visible: !1}
                    }), a.circle(740, 100, window.innerHeight / 6, {
                        isStatic: !1,
                        render: {fillStyle: "#212020"}
                    }), a.circle(740, 150, window.innerHeight / 6, {
                        isStatic: !1,
                        render: {fillStyle: "#FFFFFF"}
                    }), a.circle(250, 352, window.innerHeight / 6, {
                        isStatic: !1,
                        render: {fillStyle: "#FFC400"}
                    }), a.circle(window.innerWidth - 250, 468, window.innerHeight / 6, {
                        isStatic: !1,
                        render: {fillStyle: "#212020"}
                    }), a.circle(126, 308, window.innerHeight / 6, {
                        isStatic: !1,
                        render: {fillStyle: "#FFFFFF"}
                    }), a.circle(54, 469, window.innerHeight / 6, {isStatic: !1, render: {fillStyle: "#FFC400"}})])
                }), 1e3);
                var d = o.create(u.canvas),
                    p = r.create(l, {mouse: d, constraint: {stiffness: .2, render: {visible: !1}}});
                return s.add(c, p), u.mouse = d, e.lookAt(u, {
                    min: {x: 0, y: 0},
                    max: {x: window.innerWidth, y: window.innerHeight}
                }), {
                    engine: l, runner: h, render: u, canvas: u.canvas, stop: function () {
                        of().Render.stop(u), of().Runner.stop(h)
                    }
                }
            }

            show() {
            }

            addEventListeners() {
            }
        }

        const af = document.getElementById("cursor"), lf = Math.floor(6);
        let cf, uf = 0, hf = {x: 0, y: 0}, df = [], pf = !1;

        class ff {
            constructor(t = 0) {
                this.index = t, this.anglespeed = .05, this.x = 0, this.y = 0, this.scale = 1 - .05 * t, this.range = 13 - 13 * this.scale + 2, this.limit = 19.5 * this.scale, this.element = document.createElement("span"), Ai.set(this.element, {scale: this.scale}), af.appendChild(this.element)
            }

            lock() {
                this.lockX = this.x, this.lockY = this.y, this.angleX = 2 * Math.PI * Math.random(), this.angleY = 2 * Math.PI * Math.random()
            }

            draw(t) {
                !pf || this.index <= lf || (this.angleX += this.anglespeed, this.angleY += this.anglespeed, this.y = this.lockY + Math.sin(this.angleY) * this.range, this.x = this.lockX + Math.sin(this.angleX) * this.range), Ai.set(this.element, {
                    x: this.x,
                    y: this.y
                })
            }
        }

        function mf() {
            clearTimeout(cf), cf = setTimeout(gf, 150), pf = !1
        }

        function gf() {
            pf = !0;
            for (let t of df) t.lock()
        }

        const vf = t => {
            hf.x = t.clientX - 13, hf.y = t.clientY - 13, mf()
        }, yf = () => {
            hf.x = event.touches[0].clientX - 13, hf.y = event.touches[0].clientY - 13, mf()
        }, xf = t => {
            _f(t - uf), uf = t, requestAnimationFrame(xf)
        }, _f = t => {
            let e = hf.x, n = hf.y;
            df.forEach(((i, r, o) => {
                let s = o[r + 1] || o[0];
                if (i.x = e, i.y = n, i.draw(t), !pf || r <= lf) {
                    const t = .35 * (s.x - i.x), r = .35 * (s.y - i.y);
                    e += t, n += r
                }
            }))
        };
        window.addEventListener("mousemove", vf), window.addEventListener("touchmove", yf), uf += new Date, function () {
            for (let t = 0; t < 20; t++) {
                let e = new ff(t);
                df.push(e)
            }
        }(), xf();
        new class {




            createPages() {
                "project" === this.template ? this.page = new nf : "playground" === this.template ? this.page = new Qp : "404" === this.template ? this.page = new sf : "home" === this.template && (this.page = new Xi), this.page.create()
            }

            onPreloaded() {
                this.page.show()
            }

            createPreloader() {
                this.preloader = new Pi, this.preloader.once("completed", this.onPreloaded.bind(this))
            }

            reloadOnResize() {
                var t, e, n;
                window.addEventListener("resize", (t = function () {
                    location.reload()
                }, e = (e = 150) || 100, function (i) {
                    n && clearTimeout(n), n = setTimeout(t, e, i)
                }))
            }

            addEventListeners() {
                window.addEventListener("resize", (() => {
                    window.innerWidth > 1200 && this.reloadOnResize()
                })), window.addEventListener("orientationchange", (function (t) {
                    document.querySelectorAll("canvas").length > 0 && document.querySelectorAll("canvas").forEach((t => {
                        t.remove()
                    }))
                }))
            }
        }
    })()
})();